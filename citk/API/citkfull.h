// This file was generated by HExpand v 1.6
//
///////////////////////////////// [_citkfull.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef _CITKFULL_H_INCLUDED_
#define _CITKFULL_H_INCLUDED_
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#define FULL_CITK
///////////////////////////////// [_citk.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef _CITK_H_INCLUDED_
#define _CITK_H_INCLUDED_
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_CoreVersion.h]
// This file was generated by HExpand v 1.6
//
#define CITK_CORE_VER 559
///////////////////////////////// [citk_CoreVersion.h] END
///////////////////////////////// [citk_Versions.h]
// Must fix HExpand so we can move these into citk_CoreVersion.h?
#define CITK_MAJOR	2
#define CITK_MINOR	6
// Stringizing macros
#define __S(x) #x
#define _S(x) __S(x)
// Use these macros in a resource file to create a 4 digit file version number
#define VERNUMBER	CITK_MAJOR,CITK_MINOR,CITK_CORE_VER+CITK_TYPES_VER,BUILDNO
#define PRODVERNUMBER	CITK_MAJOR,CITK_MINOR,0,0
#ifdef _DEBUG
#define VERSTRING	_S(CITK_MAJOR) "." _S(CITK_MINOR) "." _S(CITK_CORE_VER) "." _S(BUILDNO) " Debug\0"
#define PRODVERSTRING	_S(CITK_MAJOR) ", " _S(CITK_MINOR) " Debug\0"
#else
#define VERSTRING	_S(CITK_MAJOR) "." _S(CITK_MINOR) "." _S(CITK_CORE_VER) "." _S(BUILDNO) "\0"
#define PRODVERSTRING	_S(CITK_MAJOR) ", " _S(CITK_MINOR) "\0"
#endif
// Use these macros in a resource file
#define RES_COMPANY		"Crystal 5D Technologies"
#define RES_PRODUCT		"Crystal 5D"
#define RES_COPYRIGHT	"Copyright (c) 2008 Crystal 5D Technologies. All rights reserved."
#define RES_PLUGIN		"Plug-in for Crystal 5D applications."
#define RES_TRADEMARK	"Crystal 5D, 5D.View, 5D.Plan, 5D.Design are trademarks of Crystal 5D Technologies."
// Put this macro in each file, passing "$Revision:$" as argument
#define DECLARE_VSS_REVISION(str)	static const char vssRevision[] = str
// This converts the string declared by the previous macro into a revision number
#define REVISION_NO	(CITK_MAJOR*1000+CITK_MINOR*100+atoi(vssRevision+11))
///////////////////////////////// [citk_Versions.h] END
#ifndef ONLY_VERSION_INFO
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// Defines for MS VC++ compiler
#ifdef _MSC_VER
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
#ifndef CITK_NO_DEFAULTLIB
# ifdef CITK_IMPORTS
#   pragma comment (lib,"citkcore.lib")
# endif
#endif   // !CITK_NO_DEFAULTLIB
#endif // _MSC_VER
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// THIS ONE FIRST, I think 
///////////////////////////////// [citk_Main.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_MAIN_H_INCLUDED
#define CITK_MAIN_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#include <citkTypes.h>
namespace citk{
using namespace citkTypes;
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// Defines for MS VC++ compiler
#ifdef _MSC_VER
#define DLL_EXPORT __declspec(dllexport)
#define DLL_IMPORT __declspec(dllimport)
#else
#define DLL_EXPORT
#define DLL_IMPORT
#endif
///////////////////////////////////////////////////////////////////////////////
#define CITK_API
#ifdef CITK_EXPORTS
#undef CITK_API
#define CITK_API DLL_EXPORT
#endif
#ifdef CITK_IMPORTS
#undef CITK_API
#define CITK_API DLL_IMPORT
#endif
#ifdef _DEBUG
#define CITK_CORE_DEBUG 1
#else
#define CITK_CORE_DEBUG 2
#endif
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_ClassDesc.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_CLASSDSC_H_INCLUDED
#define CITK_CLASSDSC_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_Copyright.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_COPYRIGHT_H_INCLUDED
#define CITK_COPYRIGHT_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
using namespace citkTypes;
///////////////////////////////////////////////////////////////////////////////
class Copyright
{
public:
	long_ptr	Tag;
	virtual unsigned long	GetID() const = 0;
	virtual	String		GetAuthorName() const = 0;				
	virtual	String		GetEmail() const = 0;					
	virtual	String		GetCompanyName() const =0;				
	virtual	String		GetURL() const =0;						
};
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
	
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#define DECLARE_COPYRIGHT(cr_name) \
	extern citk::Copyright* GetCopyright_##cr_name()
#define DLL_DECLARE_COPYRIGHT(cr_name) \
	extern CITK_API citk::Copyright* GetCopyright_##cr_name()
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#define IMPLEMENT_COPYRIGHT(cr_id,cr_name,author,email,company,url)	\
	class CR_##cr_name : public Copyright {							\
	public:															\
		virtual unsigned long GetID() const { return cr_id; }		\
		virtual String GetAuthorName() const { return author; }		\
		virtual String GetEmail() const { return email; }			\
		virtual String GetCompanyName() const { return company; }	\
		virtual String GetURL() const {	return url; }				\
	} _CR_##cr_name;												\
	Copyright* GetCopyright_##cr_name() {							\
		return (Copyright*)&_CR_##cr_name; }
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// Specify 'Nobody' if no copyright info is needed in the classdesc
DLL_DECLARE_COPYRIGHT(Nobody);
// Macro for implementing 'Nobody' copyright info [OBSOLETE]
#define IMPLEMENT_COPYRIGHT_NOBODY() 
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_COPYRIGHT_H_INCLUDED
///////////////////////////////// [citk_Copyright.h] END
#ifndef __TIMESTAMP__
// Define a dummy time stamp for compilers that don't define this.
# define __TIMESTAMP__ "unknown time"
#endif
///////////////////////////////////////////////////////////////////////////////
#define DECLARE_CLASSDESC(class_name)							\
	class CD_##class_name;										\
	extern const citk::cdid_t CDID_##class_name;				\
	extern citk::ClassDesc* GetClassDesc_##class_name()
#define DLL_DECLARE_CLASSDESC(class_name)						\
	class CD_##class_name;										\
	extern CITK_API const citk::cdid_t CDID_##class_name;		\
	extern CITK_API citk::ClassDesc* GetClassDesc_##class_name()
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
	
/////////////////////////////////////////////////////////////////////////////
typedef unsigned long cdid_t;				// Type for the Class-ID
typedef long cdb_t;							// Type for the Build of a class
class CITK_API CTPlugInLib;					// forwarded for citk_ThisPlugInLib
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
class CITK_API ClassDesc
{
public:
	long_ptr			Tag;							// for identification
	ClassDesc();
	bool			CheckID( cdid_t id ) const	{ return (_ID==id); }
	bool			CheckName( cstr_t n ) const;
	bool			IsKindOf( ClassDesc* ) const;		// fastest
	bool			IsKindOfID( const cdid_t ) const;
	bool			IsKindOfName( cstr_t ) const;
	int				GetInstances() const		{ return _Instances; }
	bool			IsAbstract() const			{ return _IsAbstract; }
	ClassDesc*		GetInheritedCD() const		{ return _InheritedCD; }
	Copyright*		GetCopyright() const		{ return _Copyright; }
	size_t			GetSize() const				{ return _Size; }
	cdid_t			GetID() const				{ return _ID; }
	String			GetName() const				{ return _Name; }
	cdb_t			GetBuild() const			{ return _Build; }
	cstr_t			GetBuildDate() const		{ return _BuildDate; }
	String			GetDesc() const				{ return _Desc; }
	cstr_t			GetProductName() const		{ return _ProductName; }
	// The inherited ClassDesc's level might not be initialized in our constructor.
	int				GetLevel() const			{ if (_Level) return _Level; return _Level=_GetLevel(); }
	int				_GetLevel() const;					// recursive SLOW
	virtual	void*	Create();				
	virtual void	Delete( void* );		
	virtual	CTPlugInLib* GetPlugInLib() const	{ return NULL; }
protected:
	ClassDesc*		_InheritedCD;
	Copyright*		_Copyright;
	size_t			_Size;
	cdid_t			_ID;
	cstr_t			_Name;
	cdb_t			_Build;
	cstr_t			_BuildDate;
	cstr_t			_Desc;
	cstr_t			_ProductName;
	int				_Instances;
	mutable int		_Level;								// cached
	bool			_IsAbstract;
};
///////////////////////////////////////////////////////////////////////////////
//! Top-level classes (not inheriting) specify 'NoBase' as their inherited-class
class CITK_API NoBase 
{
public: 
	static citk::ClassDesc* _CD()				{ return NULL; }
	virtual citk::ClassDesc* GetCD() const		{ return NULL; }
};
DLL_DECLARE_CLASSDESC(NoBase);
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//! This method is to be implemented by the IMPLEMENT_PLUGINCLASS macros.
extern citk::CTPlugInLib* citk_ThisPlugInLib();
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// Macro for obtaining the ClassDesc for a class
#define CD(class_name) \
	GetClassDesc_##class_name()
// Macro for obtaining the unique ClassDesc-ID for a class
#define CDID(class_name) \
	CDID_##class_name
//	CD(class_name)->GetID()
// Macro for implementing a specific ClassDesc, with all optional fields
#define IMPLEMENT_CLASSDESC_ABSTRACT(class_id,class_name,base_name,build,copyright,desc,url,product )	\
	static_assert(sizeof(class_name)>=sizeof(class_name::inherited));			\
	const cdid_t CDID_##class_name = class_id;						\
	DECLARE_COPYRIGHT(copyright);									\
	class CD_##class_name : public citk::ClassDesc {				\
	public:															\
		CD_##class_name() { 										\
			_InheritedCD = class_name::inherited::_CD();			\
			_Size = sizeof(class_name);								\
			_ID = class_id;											\
			_Name = _T(#class_name);								\
			_Build = build;											\
			_BuildDate = _T(__TIMESTAMP__);							\
			_Copyright = GetCopyright_##copyright();				\
			_Desc = _T(desc);										\
			_ProductName = _T(product);								\
		}															\
		virtual	citk::CTPlugInLib* GetPlugInLib() const {			\
			return citk_ThisPlugInLib(); }							\
	} _CD_##class_name;												\
	citk::ClassDesc* GetClassDesc_##class_name() {					\
		return (citk::ClassDesc*)&_CD_##class_name; }
// Macro for implementing a specific ClassDesc, with all optional fields
#define IMPLEMENT_CLASSDESC2(class_id,class_name,base_name,build,copyright,desc,url,product )	\
	static_assert(sizeof(class_name)>=sizeof(class_name::inherited));			\
	const cdid_t CDID_##class_name = class_id;						\
	DECLARE_COPYRIGHT(copyright);									\
	class CD_##class_name : public citk::ClassDesc {				\
	public:															\
		CD_##class_name() { 										\
			_InheritedCD = class_name::inherited::_CD();			\
			_Size = sizeof(class_name);								\
			_ID = class_id;											\
			_Name = _T(#class_name);								\
			_Build = build;											\
			_BuildDate = _T(__TIMESTAMP__);							\
			_Copyright = GetCopyright_##copyright();				\
			_Desc = _T(desc);										\
			_ProductName = _T(product);								\
			_IsAbstract = false;									\
		}															\
		virtual	void*		Create() {								\
			_Instances++;											\
			return (void*)new class_name(); }						\
		virtual	void		Delete( void *ptr ) {					\
			if (_Instances) _Instances--;							\
			/*delete (class_name*)ptr;*/ }							\
		virtual	citk::CTPlugInLib* GetPlugInLib() const {			\
			return citk_ThisPlugInLib(); }							\
	} _CD_##class_name;												\
	citk::ClassDesc* GetClassDesc_##class_name() {					\
		return (citk::ClassDesc*)&_CD_##class_name; }
// Macro for implementing a specific ClassDesc, with no optional fields
#define IMPLEMENT_CLASSDESC(class_id,class_name)					\
	static_assert(sizeof(class_name)>=sizeof(class_name::inherited));		\
	class CD_##class_name : public citk::ClassDesc {				\
	public:															\
		CD_##class_name() { 										\
			_InheritedCD = class_name::inherited::_CD();			\
			_Size = sizeof(class_name);								\
			_ID = class_id;											\
			_Name = _T(#class_name);								\
			_BuildDate = _T(__TIMESTAMP__);							\
			_Desc = _Name;											\
			_IsAbstract = false;									\
		}															\
		virtual	void*		Create() {								\
			_Instances++;											\
			return (void*)new class_name(); }						\
		virtual	void		Delete( void *ptr ) {					\
			if (_Instances) _Instances--;							\
			/*delete (class_name*)ptr;*/ }							\
		virtual	citk::CTPlugInLib* GetPlugInLib() const {			\
			return citk_ThisPlugInLib(); }							\
	} _CD_##class_name;												\
	citk::ClassDesc* GetClassDesc_##class_name() {					\
		return (citk::ClassDesc*)&_CD_##class_name; }
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_CLASSDSC_H_INCLUDED
///////////////////////////////// [citk_ClassDesc.h] END
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// Forward declarations used by this file
namespace citk {
class CTManager;
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
CITK_API void citk_Init(void);
CITK_API void citk_Deinit(void);
CITK_API void citk_Settings( cstr_t default_key );
///////////////////////////////////////////////////////////////////////////////
CITK_API citk::CTManager*	citk_GetService( citk::ClassDesc* );
CITK_API citk::CTManager*	citk_FindService( citk::ClassDesc* );
CITK_API citk::CTManager*	citk_GetService( citk::cdid_t );
CITK_API citk::CTManager*	citk_GetServiceByName( cstr_t );
CITK_API citk::CTManager*	citk_FindService( citk::cdid_t );
CITK_API citk::CTManager*	citk_FindServiceByName( cstr_t );
///////////////////////////////////////////////////////////////////////////////
#define GET_SERVICE(class_name) ((class_name*)citk_GetService(CD(class_name)))
#define FIND_SERVICE(class_name) ((class_name*)citk_FindService(CD(class_name)))
/////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_MAIN_H_INCLUDED
///////////////////////////////// [citk_Main.h] END
///////////////////////////////// [citk_3DTypes.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_3DTYPES_H_INCLUDED
#define CITK_3DTYPES_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
/////////////////////////////////////////////////////////////////////////////
typedef ulong			frameid_t;
typedef unsigned short	vtxid_t;		// vertex ID type
typedef Line3			Line;			// line type for engine
typedef Plane3			Plane;			// plane type for engine
typedef Vector3			Vector;			// vector type for engine
typedef Matrix33		Matrix;			// matrix type for engine
typedef Normal3			Normal;			// normal type for engine
typedef const Vector&	cvec_t;			// type for vectors (parameters)
typedef const Matrix&	cmat_t;			// type for matrices (parameters)
typedef const Normal&	cnormal_t;		// type for normals (parameters)
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// We uses meters as default unit (only adjust these three defines)
#define METER			/**(100)*/
#define UNIT2METER(u)	(u)
#define METER2UNIT(m)	(m)
// Don't touch these since they're all using METER
#define MILLIMETER		*(1 MILLI METER)
#define KILOMETER		*(1 KILO METER)
#define CENTIMETER		*(0.01f METER)
#define INCH			*(0.0254f METER)
#define FEET			*(0.3048f METER)	// 12 inches
#define MILE			*(1610 METER)
#define NAUTICAL_MILE	*(1852 METER)
#define MILES			MILE
#define KMH				*((1 KILOMETER)/3600.0f)
#define MPH				*((1 MILE)/3600.0f)
#define NAUTICAL		*(1.15f)			// f.e: MoveBy( 2 NAUTICAL MILE )
// We use radians as default unit for angles
#define RADIANS			*(1)
#define DEGREES			*((float)M_PI/180.0f)
/////////////////////////////////////////////////////////////////////////////
} // namespace citk
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_Transform.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_TRANSFORM_H_INCLUDED
#define CITK_TRANSFORM_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
/////////////////////////////////////////////////////////////////////////////
#define TH_DEFAULT			0x00000000			// Default
// General flags:
#define TH_POS				0x00000001			// Transform contains a translation
#define TH_ROT				0x00000002			// Transform contains a rotation
#define TH_DEFORM			0x00000004			// Transform contains a deformation
#define TH_MAT				0x00000008			// Total matrix is up-to-date
#define TH_INVMAT			0x00000010			// Inverse matrix is up-to-date
#define TH_NUDEFORM			0x01000000			// Transform will change length of normals!
#define TH_RIGHTHANDED		0x02000000			// Right handed transform (left handed by default)
// Identifies valid (up-to-date) fields:
#define TH_ROT_MAT			0x00000100			// Rotmat is valid
#define TH_ROT_EULER		0x00000200			// Euler is valid
#define TH_ROT_QUAT			0x00000400			// Quaternion is valid
#define TH_ROT_DIR			0x00000800			// Direction is valid
#define TH_ROT_WORLDPT		0x00001000			// WorldLookAtPoint is valid (Not used)
#define TH_ROT_MASK			0x0000FF00			// Rotation-source-mask
#define TH_USE_AZ			0x00100000			// Azimuth is nonzero
#define TH_USE_EL			0x00200000			// Elevation is nonzero
#define TH_USE_TW			0x00400000			// Twist is nonzero
#define TH_USE_EULER		(TH_USE_AZ|TH_USE_EL|TH_USE_TW)
// Source for constructing 'Deform':
#define TH_DEF_MAT			0x00010000			// Default, 'Deform' is always filled/valid
#define TH_DEF_USCALE		0x00020000			// either:	Uniform scaling
#define TH_DEF_NUSCALE		0x00040000			// or:		NonUniform scaling
#define TH_DEF_MASK			0x000F0000
///////////////////////////////////////////////////////////////////////////////
typedef ulong timeid_t;
///////////////////////////////////////////////////////////////////////////////
class CITK_API DTransform
{
public:
	static const DTransform	I;
	//
	// Default constructor:
	//
	DTransform();
	DTransform( const DTransform& );
	DTransform& operator = ( const DTransform& );
	//
	// Functions to check whether any component changed since a specified time
	//
	timeid_t	LastChange( ) const									{ return changetime; }
	bool		HasChangedSince( timeid_t tijd ) const				{ return ((long)(tijd-changetime))<0; }
	bool		HasMatrixChangedSince( timeid_t tijd ) const		{ return ((long)(tijd-mattime))<0; }
															
	bool		HasRotationChangedSince( timeid_t tijd ) const		{ return ((long)(tijd-rottime))<0; }
	bool		HasDeformationChangedSince( timeid_t tijd ) const	{ return ((long)(tijd-deftime))<0; }
	bool		HasPositionChangedSince( timeid_t tijd ) const		{ return ((long)(tijd-postime))<0; }
	//
	// Identification methods; which parts of this transform are actually used?
	//
	// Returns true if this transform has a rotational component
	bool		HasRotation() const						{ return Flags(TH_ROT)!=0; }
	// Returns true if this transform has a translation
	bool		HasPosition() const						{ return Flags(TH_POS)!=0; }
	// Returns true if this transform has a deformation component
	bool		HasDeformation() const					{ return Flags(TH_DEFORM)!=0; }
	// Returns true if this transform has a non-uniform deformation
	bool		HasNUDeform() const						{ return Flags(TH_NUDEFORM)!=0; }
	// Returns true if final-matrix is not indentity
	bool		HasTotalMatrix() const					{ return Flags.Any(TH_ROT|TH_DEFORM); }
	bool		HasInverseMatrix() const				{ return Flags.Any(TH_ROT|TH_DEFORM); }
	// Returns true if this transform contains anything at all
	bool		IsIdentity() const						{ return !Flags.Any(TH_ROT|TH_POS|TH_DEFORM); }
	// Returns true if this transform defines a left handed coordinate system
	bool		IsLeftHanded() const					{ return !Flags.Any(TH_RIGHTHANDED); }
	//
	// Update methods; will convert one component into another if necessary
	//
	// Update only the rotationmatrix; call this before transforming normals
	bool		UpdateRotationMatrix() const			{ if (!Flags(TH_ROT_MAT)) CalcRotationMatrix(); return HasRotation(); }
	// Update only the quaternion
	bool		UpdateQuaternion() const				{ if (!Flags(TH_ROT_QUAT)) CalcQuaternion(); return HasRotation(); }
	// Update the final transformation matrix; returns true if mat!=identity
	bool		UpdateTotalMatrix() const				{ if (!Flags(TH_MAT)) CalcTotalMatrix(); return HasTotalMatrix(); }
	// Update look-at direction
	bool		UpdateDirection() const					{ if (!Flags(TH_ROT_DIR)) CalcDirection(); return HasRotation(); }
	// Update the final position; returns true if pos!=zero
	bool		UpdatePosition() const					{ return HasPosition(); }
	// Update the final transformation matrix; returns true if rot!=identity
	bool		UpdateEuler() const						{ if (!Flags(TH_ROT_EULER)) CalcEuler(); return HasRotation(); }
	// Update deformation matrix
	bool		UpdateDeformationMatrix() const			{ if (!Flags(TH_DEF_MAT)) CalcDeformationMatrix(); return HasDeformation(); }
	// Update the whole transformation; call this before transforming points
	bool		UpdateTotal() const						{ return UpdateTotalMatrix() || UpdatePosition(); }
	bool		UpdateInverseMatrix() const				{ if (!Flags(TH_INVMAT)) CalcInverseMatrix(); return HasInverseMatrix(); }
	bool		UpdateInverse() const					{ return UpdateInverseMatrix() || UpdatePosition(); }
	//
	// Set individual transformations:
	//
	void		SetPosition( const Vector &p )			{ IPos(); Pos=p; }
	void		SetScale( cfloat__t s )				{ IDef( TH_DEF_USCALE ); Scale=s; }
	void		SetScaleNU( const Vector &s )			{ IDef( TH_DEF_NUSCALE ); ScaleNU=s; }
	void		SetDeformationMatrix( const Matrix &d ){ IDef( TH_DEF_MAT ); Deform=d; }
	void		SetMatrix( const Matrix &m )			{ IMat(); Mat=m; }
	void		SetTotalMatrix( const Matrix &m )		{ IMat(); Mat=m; }		// idem
	void		SetRotationMatrix( const Matrix &m )	{ IRot( TH_ROT_MAT ); Rot=m; }
	void		SetQuat( const Quaternion &q )			{ IRot( TH_ROT_QUAT ); Quat=q; }
	void		SetAz( cfloat__t az )				{ UpdateEuler(); IRot( TH_ROT_EULER|TH_USE_AZ ); Az=az; }
	void		SetEl( cfloat__t el )				{ UpdateEuler(); IRot( TH_ROT_EULER|TH_USE_EL ); El=el; }
	void		SetTw( cfloat__t tw )				{ UpdateEuler(); IRot( TH_ROT_EULER|TH_USE_TW ); Tw=tw; }
	void		_SetDirection( const Vector &v )		{ IRot( TH_ROT_DIR ); Rot.V_PN = v; }
//	void		SetLocalLookAt( const Vector &v )		{ IRot( TH_ROT_WORLDPT ); LookAt = v - Pos; }
//	void		SetWorldLookAt( const Vector &v )		{ IRot( TH_ROT_WORLDPT ); LookAt = v; }
	void		SetEuler( cfloat__t a, cfloat__t e, cfloat__t t ) {
		IRot( TH_ROT_EULER|TH_USE_EULER ); Az=a; El=e; Tw=t; }
	void		_SetLeftHanded( bool left =true )		{ Flags.Set(TH_RIGHTHANDED,!left); }
	//
	// Reset individual transformations:
	//
	inline void			ResetPosition()					{ Flags.Clear( TH_POS ); Pos.Zero(); postime = _Invalidate(); }
														
	void				ResetDeformation();
	void				ResetRotation();
	inline void			ResetMatrix()					{ Flags.Clear( TH_DEFORM|TH_DEF_MASK|TH_ROT|TH_ROT_MASK|TH_MAT|TH_NUDEFORM ); mattime = rottime = deftime = _Invalidate(); }
	inline void			Reset()							{ Flags=TH_DEFAULT; Pos.Zero(); postime = mattime = rottime = deftime = _Invalidate(); }
	//
	// Get individual transformations:
	//
	inline const Vector&	_Position() const			{ return Pos; }
	inline const Matrix&	_DeformationMatrix() const	{ /*UpdateDeformationMatrix();*/ return Deform; }
	inline float__t			_Scale() const				{ return Scale; }
	inline const Vector&	_ScaleNU() const			{ return ScaleNU; }
	inline const Matrix&	_RotationMatrix() const		{ /*UpdateRotationMatrix();*/ return Rot; }
	inline const Quaternion& _Quaternion() const		{ /*UpdateQuaternion();*/ return Quat; }
	inline const Vector&	_Direction() const			{ return Rot.V_PN; }
	inline float__t			_Az() const					{ /*UpdateEuler();*/ return Az; }
	inline float__t			_El() const					{ /*UpdateEuler();*/ return El; }
	inline float__t			_Tw() const					{ /*UpdateEuler();*/ return Tw; }
	inline const Matrix&	_TotalMatrix() const		{ /*UpdateTotalMatrix();*/ return Mat; }
	inline const Matrix&	_InverseMatrix() const		{ /*UpdateTotalMatrix();*/ return InvMat; }
	//
	// Use individual transformations: (updates if necessary)
	//
	inline const Vector&	GetPosition() const			{ return Pos; }
	inline const Matrix&	GetDeformationMatrix() const{ UpdateDeformationMatrix(); return Deform; }
	inline const Matrix&	GetRotationMatrix() const	{ UpdateRotationMatrix(); return Rot; }
	inline const Quaternion& GetQuaternion() const		{ UpdateQuaternion(); return Quat; }
	inline const Vector&	GetDirection() const		{ UpdateDirection(); return Rot.V_PN; }
	inline float__t			GetAz() const				{ UpdateEuler(); return Az; }
	inline float__t			GetEl() const				{ UpdateEuler(); return El; }
	inline float__t			GetTw() const				{ UpdateEuler(); return Tw; }
	const Matrix&			GetMatrix() const;			// Does not always update TotalMatrix
	inline const Matrix&	GetTotalMatrix() const		{ UpdateTotalMatrix(); return Mat; }
	inline const Matrix&	GetInverseMatrix() const	{ UpdateInverseMatrix(); return InvMat; }
	//
	// Use these to get, change & invalidate any part of the transform:
	//
	inline Vector&		GetPositionRef()				{ IPos(); return Pos; }
	inline Matrix&		GetDeformationMatrixRef()		{ UpdateDeformationMatrix(); IDef(TH_DEF_MAT); return Deform; }
	inline Matrix&		GetRotationMatrixRef()			{ UpdateRotationMatrix(); IRot(TH_ROT_MAT); return Rot; }
	inline Quaternion&	GetQuaternionRef()				{ UpdateQuaternion(); IRot(TH_ROT_QUAT); return Quat; }
	inline Vector&		GetDirectionRef()				{ UpdateDirection(); IRot(TH_ROT_DIR); return Rot.V_PN; }
	inline float__t&	GetAzRef()						{ UpdateEuler(); IRot(TH_USE_AZ|TH_ROT_EULER); return Az; }
	inline float__t&	GetElRef()						{ UpdateEuler(); IRot(TH_USE_EL|TH_ROT_EULER); return El; }
	inline float__t&	GetTwRef()						{ UpdateEuler(); IRot(TH_USE_TW|TH_ROT_EULER); return Tw; }
	inline Matrix&		GetTotalMatrixRef()				{ UpdateTotalMatrix(); IMat(); return Mat; }
	//
   	//  Postition transformations (Some of these should do 'UpdatePosition()' }
	//
	inline void		MoveBy( Vector const &v )			{ IPos(); Pos += v; }
	inline void		MoveTo( Vector const &v )			{ IPos(); Pos = v; }
	inline void		MoveToX( cfloat__t a )			{ IPos(); Pos.x = a;}
	inline void		MoveToY( cfloat__t a )			{ IPos(); Pos.y = a;}
	inline void		MoveToZ( cfloat__t a )			{ IPos(); Pos.z = a;}
	
	inline void		MoveByX( cfloat__t a )			{ IPos(); Pos.x += a;}
	inline void		MoveByY( cfloat__t a )			{ IPos(); Pos.y += a;}
	inline void		MoveByZ( cfloat__t a )			{ IPos(); Pos.z += a;}
	
	inline void		MoveRight( cfloat__t a )		{ UpdateRotationMatrix(); IPos(); Pos += a*Rot.V_RIGHT;}
	inline void		MoveUp( cfloat__t a )			{ UpdateRotationMatrix(); IPos(); Pos += a*Rot.V_UP;}
	inline void		MoveForward( cfloat__t a )		{ UpdateDirection(); IPos(); Pos += a*Rot.V_PN;}
	
	inline void		MoveLeft( cfloat__t a )			{ UpdateRotationMatrix(); IPos(); Pos -= a*Rot.V_RIGHT;}
	inline void		MoveDown( cfloat__t a )			{ UpdateRotationMatrix(); IPos(); Pos -= a*Rot.V_UP;}
	inline void		MoveBack( cfloat__t a )			{ UpdateDirection(); IPos(); Pos -= a*Rot.V_PN;}
	//
	// Orientation transformations:
	//
	 
	// Euler angle functions:
	inline void		IncreaseAz( cfloat__t a )		{ UpdateEuler(); IRot( TH_ROT_EULER|TH_USE_AZ ); Az+=a; }
	inline void		IncreaseEl( cfloat__t a )		{ UpdateEuler(); IRot( TH_ROT_EULER|TH_USE_EL ); El+=a; }
	inline void		IncreaseTw( cfloat__t a )		{ UpdateEuler(); IRot( TH_ROT_EULER|TH_USE_TW ); Tw+=a; }
	// Quaternion functions:
//	inline void		RotateQuatToAz( cfloat__t a )	{ IRot( TH_ROT_QUAT ); Quat.RotationY(a); }
//	inline void		RotateQuatToEl( cfloat__t a )	{ IRot( TH_ROT_QUAT ); Quat.RotationX(a); }
//	inline void		RotateQuatToTw( cfloat__t a )	{ IRot( TH_ROT_QUAT ); Quat.RotationZ(a); }
	inline void		RotateQuatByAz( cfloat__t a )	{ UpdateQuaternion(); IRot( TH_ROT_QUAT ); Quat.RotateByY(a); }
	inline void		RotateQuatByEl( cfloat__t a )	{ UpdateQuaternion(); IRot( TH_ROT_QUAT ); Quat.RotateByX(a); }
	inline void		RotateQuatByTw( cfloat__t a )	{ UpdateQuaternion(); IRot( TH_ROT_QUAT ); Quat.RotateByZ(a); }
	// Matrix functions:
	inline void		RotateToAz( cfloat__t a )		{ IRot( TH_ROT_MAT ); Rot.RotationY(a); }
	inline void		RotateToEl( cfloat__t a )		{ IRot( TH_ROT_MAT ); Rot.RotationX(a); }
	inline void		RotateToTw( cfloat__t a )		{ IRot( TH_ROT_MAT ); Rot.RotationZ(a); }
	inline void		RotateByAz( cfloat__t a )		{ UpdateRotationMatrix(); IRot( TH_ROT_MAT ); Rot.RotateByY(a); }
	inline void		RotateByEl( cfloat__t a )		{ UpdateRotationMatrix(); IRot( TH_ROT_MAT ); Rot.RotateByX(a); }
	inline void		RotateByTw( cfloat__t a )		{ UpdateRotationMatrix(); IRot( TH_ROT_MAT ); Rot.RotateByZ(a); }
	// Direction functions:
	inline void		SetDirection( const Vector &v )	{ _SetDirection( v.Normalized() ); }
	inline void		LookAt( const Vector &v )		{ _SetDirection( (v - Pos).Normalized() ); }
	//
	// Deformation methods:
	//
	inline void		ScaleTo( cfloat__t a )			{ SetScale(a); }
	void			ScaleBy( cfloat__t a );
	inline void		ScaleTo( Vector const &a )		{ SetScaleNU(a); }
	void			ScaleBy( Vector const &a ); 
	inline void		ScaleTo( cfloat__t x, cfloat__t y, cfloat__t z ) { ScaleTo( Vector(x,y,z) ); } 
	inline void		ScaleBy( cfloat__t x, cfloat__t y, cfloat__t z ) { ScaleBy( Vector(x,y,z) ); } 
	//
	// General:
	//
	// Inverts the transform; inverts Mat, and Rot / Deform if possible
	DTransform&		Invert();
	// Sets 'this' to the inverse of the given transform
	void			SetInverse( const DTransform& );
	// Optimizes the transform (removes void position/rotation/scaling)
	DTransform&		Optimize();
	// Combine two transformations into 'this'
	DTransform&		Combine ( const DTransform& loc, const DTransform& wld);
	DTransform&		CombinePosition ( const DTransform& loc, const DTransform& wld);
	DTransform&		CombineRotation ( const DTransform& loc, const DTransform& wld);
	DTransform&		CombineDeformation ( const DTransform& loc, const DTransform& wld);
	// Combine two transformations into 'this'; only OLD components will be calculated
	DTransform&		CombineOptimized ( const DTransform& loc, const DTransform& wld);
	DTransform&		CombinePositionOptimized ( const DTransform& loc, const DTransform& wld);
	DTransform&		CombineRotationOptimized ( const DTransform& loc, const DTransform& wld);
	DTransform&		CombineDeformationOptimized ( const DTransform& loc, const DTransform& wld);
	DTransform&		operator *= ( const DTransform& ); 
//	DTransform		operator * ( const DTransform& ) const;
	inline Vector	operator * ( const Vector &v ) const { return (v * Mat) + Pos; } 
	// Vector / Normal transformations
	inline Vector	operator () ( const Vector &v ) const { return (v * Mat) + Pos; }
	inline Normal	TransformNormal( const Normal &v ) const			{ return UpdateRotationMatrix()?(v * Rot):v; }
	inline Normal	TransformNormalBest( const Normal &v ) const		{ return UpdateTotalMatrix()?(v * Mat).Normalized():v; }
	inline Normal	BackTransformNormal( const Normal &v ) const		{ return UpdateRotationMatrix()?(v / Rot):v; }
	inline Normal	BackTransformNormalBest( const Normal &v ) const	{ return UpdateInverseMatrix()?(v * InvMat).Normalized():v; }
	inline Vector	TransformPoint( const Vector &v ) const				{ return (UpdateTotalMatrix()?(v * Mat):v) + Pos; }
	inline Vector	BackTransformPoint( const Vector &v ) const			{ return UpdateInverseMatrix()?(v - Pos) * InvMat:(v - Pos); }
	// Transformations for arrays:
	void			TransformPoints( Vector *base, int count, int stride=0 ) const;
	void			TransformPointsToArray( const Vector *base, int count, Vector* dest, int base_stride = 0, int dest_stride = 0 ) const ;
	void			TransformNormals( Normal *base, int count, int stride=0 ) const;
	void			TransformNormalsToArray( const Normal *base, int count, Normal* dest, int base_stride = 0, int dest_stride = 0 ) const ;
	void			TransformNormalsBest( Normal *base, int count, int stride=0 ) const;
	void			BackTransformPoints( Vector *base, int count, int stride=0 ) const;
	void			BackTransformPointsToArray( const Vector *base, int count, Vector* dest, int base_stride = 0, int dest_stride = 0 ) const ;
	void			BackTransformNormals( Normal *base, int count, int stride=0 ) const;
	void			BackTransformNormalsToArray( const Normal *base, int count, Normal *dest, int base_stride = 0, int dest_stride = 0 ) const ;
	void			BackTransformNormalsBest( Normal *base, int count, int stride=0 ) const;
private:
	mutable DFlags		Flags;
	// Translation
	Vector		Pos;
	// Rotation
	mutable float__t		Az, El, Tw;
	mutable Quaternion	Quat;
//	Vector		Dir;
//	Vector		LookAt;
	mutable Matrix		Rot;								// RotationMatrix
	// Deformation
	mutable float__t		Scale;
	mutable Vector		ScaleNU;
	mutable Matrix		Deform;								// DeformationMatrix
						  	
	// Total transformation (Combined)
	mutable Matrix		Mat;								// TransformationMatrix = Deform*Rot
	mutable Matrix		InvMat;								// Inverse Transformation Matrix
	// Time-IDs for the components
	timeid_t			changetime, mattime, rottime, postime, deftime;
	static timeid_t		timeid;
	//
	// Functions to calculate components form other components
	//
	void			CalcTotalMatrix() const;
	void			CalcDeformationMatrix() const;
	void			CalcEuler() const;
	void			CalcQuaternion() const;
	void			CalcRotationMatrix() const;
	void			CalcDirection() const;
	void			CalcInverseMatrix() const;
	// Split the final matrix into Deformation and Rotation
	void			SplitTotalMatrix() const;
	// Returns 'true' if the final matrix is the only source of information
	bool			OnlyTotalMatrix() const { return Flags(TH_MAT) && Flags.None(TH_ROT_MASK|TH_DEF_MASK); }
	// Announce change in position
	inline void		IPos() { 
		postime = _Invalidate(); Flags.Set(TH_POS); }
	// Announce change in rotation
	inline void	 	IRot( flags_t f=0 ) { 
		mattime = rottime = _Invalidate(); Flags.Clear(TH_ROT_MASK|TH_MAT|TH_INVMAT); Flags.Set(f|TH_ROT); }
	// Announce change in deformation
	inline void	 	IDef( flags_t f=0 ) { 
		deftime = mattime = _Invalidate(); Flags.Clear(TH_DEF_MASK|TH_MAT|TH_INVMAT); Flags.Set(f|TH_DEFORM); }
	// Announce change in final (total) matrix
	inline void		IMat() { 
		mattime = rottime = deftime = _Invalidate(); Flags.Clear(TH_DEF_MASK|TH_ROT_MASK|TH_INVMAT); Flags.Set(TH_MAT|TH_ROT|TH_DEFORM);  }
	// Announce global transform change
	inline timeid_t	_Invalidate() { return changetime = timeid++; }
};
///////////////////////////////////////////////////////////////////////////////
typedef const DTransform&	ctransform_t;	// Type for transforms
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
/////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_TRANSFORM_H_INCLUDED
///////////////////////////////// [citk_Transform.h] END
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITK_3DTYPES_H_INCLUDED
///////////////////////////////// [citk_3DTypes.h] END
///////////////////////////////// [citk_3DText.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_3DTEXT_H_INCLUDED
#define CITK_3DTEXT_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_MultiMtlGeometry.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_MULTIMTLGEOMETRY_H_INCLUDED
#define CITK_MULTIMTLGEOMETRY_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_Geometry.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_GEOMETRY_H_INCLUDED
#define CITK_GEOMETRY_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_Entity.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_ENTITY_H_INCLUDED
#define CITK_ENTITY_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_Process.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_PROCESS_H_INCLUDED
#define CITK_PROCESS_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_Named.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef	CITK_NAMED_H_INCLUDED
#define	CITK_NAMED_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_Interface.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_INTERFACE_H_INCLUDED
#define CITK_INTERFACE_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_Aggregated.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef	CITK_AGGREGATED_H_INCLUDED
#define	CITK_AGGREGATED_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_Streamed.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef	CITK_STREAMED_H_INCLUDED
#define	CITK_STREAMED_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_Referenced.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef	CITK_REFERENCED_H_INCLUDED
#define	CITK_REFERENCED_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_Basic.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef	CITK_BASIC_H_INCLUDED
#define	CITK_BASIC_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTBasic);
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CTAggregated;									// forward for OnDelete
///////////////////////////////////////////////////////////////////////////////
#define DECLARE_DEBUG() \
	friend class WorldDebugger
//! Macro for defining the typedef 'inherited' within a class; use with ';'
#define DECLARE_INHERITED(b) \
	public: typedef b inherited
//! Macro for declaring the prototype for GetCD(); use with ';'
#define DECLARE_GETCD(class_name)										\
	public: static citk::ClassDesc* _CD() { return CD(class_name); }	\
	public: virtual citk::ClassDesc* GetCD() const { return CD(class_name); }	\
	friend class CD_##class_name
//! All classes derived from CTBasic can use this macro instead; use with ';'
#define DECLARE_ALL(a,b)	\
	DECLARE_DEBUG();		\
	DECLARE_INHERITED(b);	\
	DECLARE_GETCD(a)
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//
// CTBasic includes methods for RTTI (using descendants from 
// ClassDesc) and also has an event for removing any references
// to a CTAggregated object
class CITK_API CTBasic
{
	// A.o. returns a pointer to a global Class-Descriptor for this class
	DECLARE_ALL( CTBasic, NoBase );
protected:
	// Protected virtual destructor (TODO: make this the first virtual)
	// Don't use 'delete xxx' but 'xxx->RemoveRef()' or 'xxx->Delete()'
	virtual ~CTBasic() {}
public:
	// Function to delete an object; safer than 'delete ...'
	// Call inherited::Delete() if you override this.
	virtual	void	Delete();
	// OnDelete gets called if an object 'this' referenced,
	//  gets deleted. (needs 'Reason'?)
	// Call inherited::OnDelete() if you override this.
	virtual void	OnDelete( CTAggregated* ) {}		// do nothing
	// You can inherit this call and return aggregate objects; call inherited!
	virtual bool	QueryInterface( const cdid_t, void** =0 );
	// Override and call inherited, adding the size of class specific data.
	virtual size_t	GetSizeEstimate();
	// Ask for a particular interface to this object.
	// If the pointer returned by this function is NULL, 
	//  then the asked interface is not available.
	// The returned pointer should be specifically (de)referenced.
	CTBasic*		DynamicCast( const cdid_t );
	CTBasic*		DynamicCast( ClassDesc* );			// fastest
};
///////////////////////////////////////////////////////////////////////////////
typedef DSmartPtr<CTBasic> PBasic;
///////////////////////////////////////////////////////////////////////////////
#define CITK_NEW(class_name)		((class_name*)(CD(class_name)->Create()))
#define CITK_DELETE(class_instance)	(class_instance)->Delete()
///////////////////////////////////////////////////////////////////////////////
//! Inline template function to convert any pointer into specific class
template <class T>
inline T* citk_cast( CTBasic* b )
{
	if (b && b->GetCD()->IsKindOf(T::_CD()))
		return static_cast<T*>(b);
	else
		return NULL;
}
//! Inline template function to convert any const pointer into specific class
template <class T>
inline const T* citk_cast( const CTBasic* b )
{
	if (b && b->GetCD()->IsKindOf(T::_CD()))
		return static_cast<const T*>(b);
	else
		return NULL;
}
//! Inline template function (asserts object type)
template <class T>
static inline T* citk_cast_assert( CTBasic* str )
{
	T* ptr = citk_cast<T>(str);
	CITK_ASSERT( !str || ptr,
		_T("Expected an object of class ") + T::_CD()->GetName() );
	return ptr;
}
//! Inline template function (asserts object type)
template <class T>
static inline const T* citk_cast_assert( const CTBasic* str )
{
	const T* ptr = citk_cast<T>(str);
	CITK_ASSERT( !str || ptr,
		_T("Expected an object of class ") + T::_CD()->GetName() );
	return ptr;
}
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif	// !CITK_BASIC_H_INCLUDED
///////////////////////////////// [citk_Basic.h] END
///////////////////////////////// [citk_StrongPtr.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef	CITK_STRONGPTR_H_INCLUDED
#define	CITK_STRONGPTR_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
enum NewNow_t { NewNow=1 };
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
template <class T>
class StrongPtr : public DSmartPtr<T>
{
public:
	//! Default constructor (initializes to NULL)
	StrongPtr()								{ }	// ptr = NULL
	StrongPtr( T* p )						{ _CheckClassDesc(); ptr=p; if (ptr) ptr->AddRef(); }
	StrongPtr( const StrongPtr<T> &sp )		{ _CheckClassDesc(); ptr=(T*)sp; if (ptr) ptr->AddRef(); }
	//! Create a strong pointer for any object; checks its type with DynamicCast
	explicit StrongPtr( CTBasic* p )		{ _CheckClassDesc(); if (ptr = citk_cast<T>(p)) ptr->AddRef(); }
	//! Use StrongPtr<> ptr(NewNow) to create a new instance (very handy-dandy)
	explicit StrongPtr( NewNow_t )			{ New(); }
#ifdef _SAFEMODE
	~StrongPtr() { Release(); }
#else
	~StrongPtr() { if (ptr) ptr->RemoveRef(); }
#endif
	// Create a new instance of T; overrides SmartPtr<>::New()
	//  (Note: uses the ClassDesc's Create() if available, if not, new )
	T*				New();
	//! Remove a reference (returns 0 if gone)
	inline  int		Release() { if (!ptr) return 0; int i = ptr->RemoveRef(); ptr = NULL; return i; }
	//! Alternate DynamicCast method; similar to SP = citk_cast( T, p );
	inline bool		DynamicCast( CTBasic *p ) { return PointTo(citk_cast<T>(p))!=NULL; }
	//! Point to another object (updates references)
	inline T*		PointTo( T* p );
	//! Pointer to the ClassDesc of the class this pointer can point to
	ClassDesc*		GetTypeCD() const { return T::_CD(); }
	// Assignment operators:
	StrongPtr& operator = ( T* p ) { PointTo(p); return  *this; }
	StrongPtr& operator = ( const StrongPtr& sp ) { PointTo((T*)sp); return *this; }
	// Returns 'true' if the associated class has an invalid classdesc
	static inline bool	_InvalidClassDesc() { return sizeof(T)!=T::_CD()->GetSize(); }
	static inline void	_CheckClassDesc() { CITK_ASSERT( !_InvalidClassDesc(),_T("Class has wrong class-descriptor")); }
};
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T>
T* StrongPtr<T>::New() 
{ 
	//  (Note: uses the ClassDesc's Create() if available, if not, new )
	return PointTo( _InvalidClassDesc()?new T:(T*)T::_CD()->Create() ); 
}
///////////////////////////////////////////////////////////////////////
template <class T>
inline T* StrongPtr<T>::PointTo( T* newptr )
{ 
	// We attach first to the new object, then release the old.
	// Important because it would be possible that due to ptr's release, 
	//  new-ptr could get released and deleted too, even before we attach to it.
	//  (for example, when ptr==newptr)
	if (newptr) 
		newptr->AddRef(); 
	if (ptr) 
		ptr->RemoveRef();
	return ptr = newptr;
}
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_STRONGPTR_H_INCLUDED
///////////////////////////////// [citk_StrongPtr.h] END
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTReferenced );
// Uncomment this if you want the RefCount to be updated thread safe
// NOTE: this makes no sense, since the thread should already have a ref
//  before you can add/remove one.
//#define INTERLOCKED_REFCOUNT
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////
class CITK_API CTReferenced : public CTBasic
{
	DECLARE_ALL(CTReferenced,CTBasic);
public:
	//! Constructor. Initialize RefCount to 0
	CTReferenced() : RefCount(0) { }
	//! Increments RefCount
	// Returns the new RefCount (success when >0)
	int				AddRef();
	//! Decreases RefCount; 'this' will only get deleted when RefCount==0.
	// Returns the new RefCount (0 means object is gone!)
	int				RemoveRef();
#ifdef _DEBUG
	//! Marks the object as deleting and calls inherited (asserts that RefCount is 0)
	virtual void	Delete();						// check RefCount
	virtual void	OnDelete( CTAggregated* );		// check RefCount
#endif
protected:
	inline bool		_IsDeleting() const			{ return RefCount<0; }
#ifdef _DEBUG
	virtual ~CTReferenced();						// sets RefCount to -1
#endif // _DEBUG
private:
	enum {
		REFCOUNT_REACHED_0  = -64,					// in RemoveRef
		REFCOUNT_DELETE		= -128,					// in Delete
		REFCOUNT_DTOR		= -256					// in dtor
	};
	int				RefCount;						// reference count
	// Hidden members (to avoid generated copy)
	CTReferenced( const CTReferenced& );					// invalid
	void operator = ( const CTReferenced& );				// invalid
};
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
inline int CTReferenced::AddRef()
{
#ifdef INTERLOCKED_REFCOUNT
	::InterlockedIncrement( &RefCount );
#else
	RefCount++;
#endif // !INTERLOCKED_REFCOUNT
	return RefCount;
}
///////////////////////////////////////////////////////////////////////
inline int CTReferenced::RemoveRef()
{
	// If object is currently being deleted, ignore RemoveRef
	CITK_ASSERT( RefCount!=0, _T("Referenced.RemoveRef") );
#ifdef INTERLOCKED_REFCOUNT
	if (::InterlockedDecrement( &RefCount )!=0)
#else
	if (--RefCount != 0)
#endif // !INTERLOCKED_REFCOUNT
		return RefCount;
	RefCount = REFCOUNT_REACHED_0;	// Deleting
	Delete();						// Virtual, deletes this
	return 0;						// 'this' is gone!
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTReferenced> PReferenced;
///////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
#endif // !CITK_REFERENCED_H_INCLUDED
///////////////////////////////// [citk_Referenced.h] END
///////////////////////////////// [citk_Stream.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_STREAM_INCLUDED
#define CITK_STREAM_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CTStreamed;
///////////////////////////////////////////////////////////////////////////////
typedef ulong chunkid_t;
typedef ulong streamid_t;
typedef ulong streamlod_t;
///////////////////////////////////////////////////////////////////////////////
#define STREAMLOD_TREEDOWN					0x00000001	// Only for CTGroup: write all children
#define STREAMLOD_ITEMDATA					0x00000002	// Write the "info" of the object: no large data portions
#define STREAMLOD_ALLOBJECTS				0x00000004	// Write all objects that the object references to (except entity's Parent and group's Children)
#define STREAMLOD_TREEUP					0x00000008	// Only for CTEntity: write the parent
#define STREAMLOD_FILEDATA					0x00000010	// Write large data portions
#define	STREAMLOD_FILEDATA_IN_INCLUDEFILE	0x00000020	// Write large data portions to a separate file-
#define	STREAMLOD_FILEDATA_THUMBNAIL		0x00000040	// Write large data portions as small thumbnails
#define	STREAMLOD_COMMENTS					0x00000080	// Write stream comments (ignored when reading)
#define	STREAMLOD_CACHE						0x00000100	// Write cached data (CTCached)
#define	STREAMLOD_ISOLATED					0x00004000	// Load/save isolated (no RegisterWithService)
#define	STREAMLOD_ASYNC						0x00008000	// Optimize for async loading
// Default stream-LOD: parent nodes and raw data will not be included (only the filename)
#define STREAMLOD_DEFAULT	(STREAMLOD_TREEDOWN|STREAMLOD_ITEMDATA|STREAMLOD_ALLOBJECTS|STREAMLOD_FILEDATA_IN_INCLUDEFILE)
// Same as STREAMLOD_DEFAULT but will include parent nodes and raw file-data as well
//  (resulting in very large files)
#define STREAMLOD_FULL		(STREAMLOD_TREEDOWN|STREAMLOD_ITEMDATA|STREAMLOD_ALLOBJECTS|STREAMLOD_TREEUP|STREAMLOD_FILEDATA)
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTStream : public CTBasic
{
public:
	virtual bool		OpenURL( cstr_t ) = 0;
	virtual cstr_t		GetCurrentURL() = 0;
	virtual streamlod_t	GetLevelOfDetail() = 0;
	virtual filepos_t	GetCurrentPosition() = 0;
	// Reading:
	virtual int			ReadBlock( void*, int size ) = 0;
	virtual CTStreamed*	ReadReference() = 0;
	virtual DynString	ReadString();
	virtual double		ReadDouble();
	virtual float		ReadFloat();
	virtual int			ReadInt();
	virtual int			ReadByte();
	virtual Vector		ReadVector();
	virtual Quaternion	ReadQuat();
	virtual Matrix		ReadMatrix();
	virtual flags_t		ReadTransform( DTransform& );
	virtual bool		Skip( filepos_t nbytes ) = 0;
	// Writing:
	virtual bool		WriteBlock( const void*, int size ) = 0;
	// Write a reference to an object in the stream
	// (Will never write the object)
	virtual bool		WriteReference( CTStreamed* ) = 0; 
	
	virtual bool		WriteString( cstr_t );
	virtual bool		WriteDouble( const double& );
	virtual bool		WriteFloat( const float );
	virtual bool		WriteInt( const int );
	virtual bool		WriteByte( const char );
	virtual bool		WriteVector(const Vector&);
	virtual bool		WriteQuat(const Quaternion&);
	virtual bool		WriteMatrix(const Matrix&);
	virtual bool		WriteTransform( const DTransform&, flags_t lock =0 );
	
	// Chunk stuff
	virtual bool		StartChunk( chunkid_t chid, cstr_t chunkdesc ) = 0;
	virtual bool		EndChunk() = 0;
	// Include a comment in the stream (ignored when reading)
	virtual bool		WriteComment( cstr_t );		// NOP by default
	// (Will write the object if it doesn't exist in the stream already)
	virtual bool		WriteObject( CTStreamed* ) = 0; 
	// (Will start an 'object data' chunk and write the objects' data in it)
	virtual bool		WriteObjectData( CTStreamed* ) = 0; 
	virtual bool		WriteObjectChunk( CTStreamed*, chunkid_t chid ) = 0;
	// Find and replace a reference in the stream 
	virtual void		ReplaceReferences( CTStreamed* find, CTStreamed* repl ) = 0;
};
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_STREAM_INCLUDED
///////////////////////////////// [citk_Stream.h] END
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTStreamed);
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
// netid (NetworkID) is a unique identifier for an object across a network
typedef ulong netid_t;
#define NETID_NONE		0x00000000			// Not networked
#define NETID_MASTER	0x80000000			// Object is a master
#define NETID_AUTO		0xffffffff			// Request an ID from NetMgr
///////////////////////////////////////////////////////////////////////
class CITK_API CTStreamed : public CTReferenced
{
	DECLARE_ALL( CTStreamed, CTReferenced );
public:
	enum {
		FIRST_CHANGE = 0					// initial value of _Changed
	};
	//! Tag for general identification (used by property pages, etc)
	long_ptr		Tag;								
	// Default constructor
	CTStreamed();										
	//! Universal cloning method: creates a memory stream and reads it back in.
	StrongPtr<CTStreamed>	CloneByStream( streamlod_t );
	///// Change detection
	// Returns the frame-id that represents the current version in memory
	ulong			LastChange() const { return _Changed; }
	// Check to see if the object has changed
	bool			HasChanged( ulong t ) const { return t!=_Changed; }
	// Notify this object that its contents have changed
	virtual void	Invalidate() { _Changed++; }
	///// Network synchronisation functions:
	// Creates a net-ID (and enables network synchronisation)
	void			SetNetID( netid_t = NETID_AUTO );
	// Removes the net-ID (and disables network synchronisation)
	void			ResetNetID();
	// Return the current net-ID
	netid_t			GetNetID() const { return NetID; }
	// Returns 'true' if this object is indeed networked
	bool			HasNetID() const { return NetID!=NETID_NONE; }
	// Returns 'true' if 'this' is the master across the network
	bool			IsNetMaster() const;
	// Broadcast your data (specific lod) across the network
	// Used for synchronization
	void			BroadcastStream( streamlod_t lod );
	void			BroadcastChunk( chunkid_t chid );
	///// Streaming functions: (overridable; call inherited)
	// Write data to a stream
	virtual void	WriteToStream( CTStream* stream, streamlod_t lod );
	// Write a single chunk to a stream	(not necessary; use WriteToStream)
	virtual void	WriteChunk( CTStream* stream, chunkid_t chid );
	// Process a chunk from a stream
	virtual bool	ProcessChunk( CTStream* stream, chunkid_t chid );
	///// Caching functions:
	// Restore file data (from bookmark, if present)
	virtual bool	RestoreFileData();
	// Remove any restore point (RestoreFileData will fail)
	void			RemoveRestorePoint()			{ _StreamURL.Clear(); }
protected:
	// Destructor
	virtual ~CTStreamed();								
	// Write a restore point in the stream, for use with RestoreFileData
	bool			SetRestorePoint( CTStream* );
private:
	// Frame ID when this object was last changed (use for caching)
	ulong				_Changed;
	// Network ID (for network synchronisation)
	netid_t				NetID;						
	/////////////////////////////////////
	// Bookmark:
	DynString			_StreamURL;
	filepos_t			_StreamPos;
};
///////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTStreamed> PStreamed;
///////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
#endif	// !CITK_STREAMED_H_INCLUDED
///////////////////////////////// [citk_Streamed.h] END
///////////////////////////////// [citk_SafePtr.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef	CITK_SAFEPTR_H_INCLUDED
#define	CITK_SAFEPTR_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_BasicPtr.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_BASICPTR_H_INCLUDED
#define CITK_BASICPTR_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTBasicPtr );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CTAggregated;
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
class CITK_API CTBasicPtr : public CTBasic
{
	DECLARE_ALL( CTBasicPtr, CTBasic );
protected:
	CTBasicPtr() {}
	CTBasicPtr( CTAggregated* );
	// Change the pointer from one to the other (adjust referencing)
	CTAggregated* ChangePtr( CTAggregated*, CTAggregated* );
public:
	// Get the current target
	virtual CTAggregated* GetTarget() const = 0;
};
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_BASICPTR_H_INCLUDED
///////////////////////////////// [citk_BasicPtr.h] END
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
template <class T>
class SafePtr : public CTBasicPtr
{
protected:
	T* ptr;
public:
	SafePtr() : ptr(NULL) {}
	explicit SafePtr( CTBasic* p ) { ptr=citk_cast<T>(p); if (ptr) ptr->AddSubscriber(this); }
	explicit SafePtr( const SafePtr<T> &sp ) : ptr((T*)sp) { if (ptr) ptr->AddSubscriber(this); }
	explicit SafePtr( T* p ) : ptr(p) { if (ptr) ptr->AddSubscriber(this); }
	~SafePtr() { if (ptr) ptr->RemoveSubscriber(this); }
	// Get the current target
	virtual CTAggregated* GetTarget() const { return (CTAggregated*)ptr; }
	// OnDelete gets called when the target is no longer available
	virtual void	OnDelete( CTAggregated* a ) { assert(a==ptr); ptr=NULL; }
//	inline void		New() { if (!ptr) ptr = new T; }
//	inline void		Delete() { if (ptr) ptr->Delete(); }
	// Alternate DynamicCast method; similar to SP = citk_cast( T, p );
	inline bool		DynamicCast( CTBasic *p ) { return PointTo(citk_cast<T>(p))!=NULL; }
	// Pointer to the ClassDesc of the class this pointer can point to
	ClassDesc*		GetTypeCD() const { return T::_CD(); }
	inline T*		Target() const { return (T*)ptr; }
	inline T*		PointTo( T *to ) { return ptr = (T*)ChangePtr(ptr,to); }
	inline void		Release() { if (ptr) ptr = (T*)ChangePtr(ptr,NULL); }
	inline T*		operator -> (void) const { assert(ptr!=NULL); return ptr; }
	inline T&		operator * (void) const { assert(ptr!=NULL); return *ptr; }
	// Assignment operators:
	inline SafePtr& operator = ( T* ref ) { PointTo(ref); return *this; }
	inline SafePtr& operator = ( const SafePtr& bp ) { PointTo((T*)bp); return *this; }
	// Conversion operators:
	inline operator T* (void) const { return ptr; }
//	inline operator void* (void) const { return (void*)ptr; }
//	inline operator long (void) const { return (long)ptr; }
///	inline operator int (void) const { return ptr!=NULL; }
//	inline operator bool (void) const { return ptr!=NULL; }
	// Compare
	inline bool operator == ( T* const rhs ) const { return ptr == rhs; }
	inline bool operator != ( T* const rhs ) const { return ptr != rhs; }
	inline bool operator ! (void) const { return !ptr; }
};
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_SAFEPTR_H_INCLUDED
///////////////////////////////// [citk_SafePtr.h] END
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTAggregated );
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////
class CTBrowseInfo;								// forward reference
typedef int				msgid_t;				// message ID
typedef const void*		msgdata_t;				// message data
///////////////////////////////////////////////////////////////////////
// Update manager constants:
#define UM_TIME_ASAP			(0)
#define UM_TIME_EVERY_FRAME		(0)
#define UM_COUNT_FOREVER		(-1)
#define UM_COUNT_ONCE			(1)
class CTAggregated;
typedef void (CDECL CTAggregated::*updatefunc_t)( ctime_t );
#define UPDATEFUNC void CDECL
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
class CITK_API CTAggregated : public CTStreamed
{
	DECLARE_ALL( CTAggregated, CTStreamed );
public:
	CTAggregated();
	// Add to / Remove from the object's aggregator list
	void			AddAggregator( CTBasic* );
	void			RemoveAggregator( CTBasic* );
	// Querying aggregators 
	int				GetAggregatorCount() const;
	CTBasic*		GetAggregatorNo( int ) const;
	bool			IsAggregator( CTBasic* ) const;
	CTBasic*		FindAggregator( ClassDesc* ) const;
	// Add to / Remove from the object's subscriber list
	void			AddSubscriber( CTBasic* );
	void			RemoveSubscriber( CTBasic* );
	// Querying subscribers 
	int				GetSubscriberCount() const;
	CTBasic*		GetSubscriberNo( int ) const;
	// Make a notification-reference between two objects
	void			MakeRef( CTAggregated* );
	// Break a link between two objects
	void			BreakRef( CTAggregated* );
	// Returns a browse-info object for this specific object+type
	//  User is resposible for deleting this object by ref'ing and deref'ing it.
	virtual CTBrowseInfo*	CreateBrowseInfo( CTBrowseInfo* Parent, int subdir_id );
	///// For registering with an object's service
	bool			RegisterWithService();
	bool			UnregisterWithService();
	bool			IsRegistered() const { return _IsRegistered; }
	///// For messaging
	// Message handler (must call inherited when overriding)
	virtual void	OnMessage( msgid_t, msgdata_t );
	// Broadcast a message to all subscribers
	void			NotifySubscribers( msgid_t, msgdata_t =0 );
	// Broadcast a message to my equivalents in the network
	void			BroadcastMessage( msgid_t, long = 0 );
	// Broadcast a message with corresponding data
	// Don't use this for synchronizing! (Use CTStreamed::BroadcastStream instead)
	void			BroadcastData( msgid_t, msgdata_t, int msgdata_size );
	// Inherited. OnDelete gets called if an object 'this' referenced,
	//  gets deleted. Removes any references between them.
	virtual void	OnDelete( CTAggregated* );
	// Inherited. Delete will notify all subscribers via OnDelete
	virtual void	Delete();
	// Inherited. Adds the data occupied by the subscribers array
	virtual size_t	GetSizeEstimate();
protected:
	// For registering with an objects service
	virtual bool	DoRegisterWithService() { return false; }
	virtual bool	DoUnregisterWithService() { return false; }
private:
	// Is the object registered with its managing service? (for streaming)
	bool			_IsRegistered;
	// Objects that refer to this AND Subscribers
	ArrayPtr<CTBasic>	Subscribers;
};
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
#define FINDAGGREGATOR( __class ) \
	((__class*)(this->FindAggregator(CD(__class))))
///////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTAggregated> PAggregated;
///////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
#endif // !CITK_AGGREGATED_H_INCLUDED
///////////////////////////////// [citk_Aggregated.h] END
///////////////////////////////// [citk_Property.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_PROPERTY_H_INCLUDED
#define CITK_PROPERTY_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
typedef long	pid__t;								// DProperty ID's
typedef int		psize_t;							// Size of property
typedef void*	pvar_t;								// Ptr to actual var
#define PIDOF(v)		((pid__t)&(v))				// DProperty ID of a variable
#define CMP_PROP(p,v)	((p).ID()==PIDOF(v))		// Compares two 'properties'
#define PF_READONLY		0x00000001					// Read only
#define	PF_CHANGED		0x00000002					// Set if value changed
#define	PF_PERSISTENT	0x00000004					// Written/read to/from registry
#define PF_NOAPPLY		0x00000008					// No need for apply
#define	PF_ARRAYOF		0x00000010					// Pointing to more than 1 values
#define	PF_UNSAVED		0x00000100					// Has not yet been saved
#define PF_STREAMED		0x00000200					// Saved to/loaded from file/stream
#define	PF_COUNT_ONE	0x01000000					// Default number of values (1)
#define	PF_COUNT_MASK	0xFF000000					// Number of values (mask)
#define	PF_COUNT_SHIFT	24							// Number of values (shift)
#define PF_DEFAULT		(PF_NOAPPLY|PF_COUNT_ONE)
/////////////////////////////////////////////////////////////////////////////
class CTBasic;
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class CITK_API DProperty
{
public:
//	static DProperty pNULL;							// NULL property
	typedef enum 
	{
		ptNull,
		ptByte, ptWord, ptDWord, ptPtr,				// Fixed size
		ptInt, ptBool, ptFloat, ptDouble,			// Fixed size
		ptString, ptDynString,
		ptData, ptAsciiz,							// Variable size
		ptBasic,									// CTBasic
		ptBasicPtr,									// Pointer to CTBasic
		ptSmartPtr,									// SmartPointer to CTBasic
		ptCustom									// 'name=value'
	} ptype_t;
	flags_t		Flags;				// Flags (PF_...)
	CTBasic*	Owner;				// Pointer to owner of this property
	cdid_t		ClassID;			// Class ID for this property
	// Default constructor
	DProperty();
	// Assignment operator to prevent changing pNULL
//	DProperty& operator = ( const DProperty& );
	// Memory block
	DProperty& _Set( void	* v, psize_t s ) { return Set( (pvar_t)v, ptData, s ); }
	// ASCII memory block
	DProperty& _Set( char	* v, psize_t s ) { return Set( (pvar_t)v, ptAsciiz, s ); }
	// Simple types, passed by reference
	DProperty& _Set( bool				&v ) { return Set( (pvar_t)&v, ptBool ); }
	DProperty& _Set( float				&v ) { return Set( (pvar_t)&v, ptFloat ); }
	DProperty& _Set( double				&v ) { return Set( (pvar_t)&v, ptDouble ); }
	DProperty& _Set( char				&v ) { return Set( (pvar_t)&v, ptByte ); }
	DProperty& _Set( short				&v ) { return Set( (pvar_t)&v, ptWord ); }
	DProperty& _Set( int				&v ) { return Set( (pvar_t)&v, ptInt ); }
	DProperty& _Set( long				&v ) { return Set( (pvar_t)&v, ptDWord ); }
	DProperty& _Set( unsigned char		&v ) { return Set( (pvar_t)&v, ptByte ); }
	DProperty& _Set( unsigned short		&v ) { return Set( (pvar_t)&v, ptWord ); }
	DProperty& _Set( unsigned int		&v ) { return Set( (pvar_t)&v, ptInt ); }
	DProperty& _Set( unsigned long		&v ) { return Set( (pvar_t)&v, ptDWord ); }
	DProperty& _Set( String				&v ) { return Set( (pvar_t)&v, ptString ); }
	DProperty& _Set( DynString			&v ) { return Set( (pvar_t)&v, ptDynString ); }
	DProperty& _Set( const bool			&v ) { return SetConst( (const pvar_t)&v, ptBool ); }
	DProperty& _Set( const float		&v ) { return SetConst( (const pvar_t)&v, ptFloat ); }
	DProperty& _Set( const double		&v ) { return SetConst( (const pvar_t)&v, ptDouble ); }
	DProperty& _Set( const char			&v ) { return SetConst( (const pvar_t)&v, ptByte ); }
	DProperty& _Set( const short		&v ) { return SetConst( (const pvar_t)&v, ptWord ); }
	DProperty& _Set( const int			&v ) { return SetConst( (const pvar_t)&v, ptInt ); }
	DProperty& _Set( const long			&v ) { return SetConst( (const pvar_t)&v, ptDWord ); }
	DProperty& _Set( const unsigned char	&v ) { return SetConst( (const pvar_t)&v, ptByte ); }
	DProperty& _Set( const unsigned short	&v ) { return SetConst( (const pvar_t)&v, ptWord ); }
	DProperty& _Set( const unsigned int		&v ) { return SetConst( (const pvar_t)&v, ptInt ); }
	DProperty& _Set( const unsigned long	&v ) { return SetConst( (const pvar_t)&v, ptDWord ); }
	DProperty& _Set( const String			&v ) { return SetConst( (const pvar_t)&v, ptString ); }
	DProperty& _Set( const DynString		&v ) { return SetConst( (const pvar_t)&v, ptDynString ); }
	// Pointers, passed by reference
	DProperty& _Set( void*				&v ) { return Set( (pvar_t)&v, ptPtr ); }
	DProperty& _Set( CTBasic			&v ) { return Set( (pvar_t)&v, ptBasic ); }		
	DProperty& _Set( CTBasic*			&v ) { return Set( (pvar_t)&v, ptBasicPtr ); }		
	template <class _T>
	DProperty& _Set( DSmartPtr<_T> &v )		{ return Set( (pvar_t)&v, ptSmartPtr ); }
	// Methods
	bool		IsValid() const { return (this!=NULL) && (Type!=ptNull); };
	String		GetName() const;
	DynString	GetNameValue() const;					// returns "property_name=value"
	ptype_t		GetType() const { return Type; }
	pvar_t		GetPointer() const { return Var; }
	psize_t		GetSize() const { return Size; }
	String		GetTypeString() const;					// returns "Integer", "String" etc..
	cstr_t		_Name() const { return Name; }
	DProperty&	Set( pvar_t, ptype_t, psize_t =0, cstr_t =NULL, flags_t =PF_DEFAULT, cdid_t =0 );
	DProperty&	SetName( cstr_t );
	DProperty&	SetConst( const pvar_t, ptype_t, psize_t =0, cstr_t =NULL, flags_t =PF_DEFAULT, cdid_t =0 );
	DProperty&	SetSimple( cstr_t name, cstr_t value=NULL );
	DProperty&	FromInt( const long );
	DProperty&	FromString( cstr_t );
	DProperty&	FromProperty( const DProperty& );
	// ArrayOf methods:
	DProperty&	SetCount( int i );
	int			GetCount() const { return Flags>>PF_COUNT_SHIFT; }
	// For reading properties
	long		ToInt() const;
	double		ToFloat() const;
	DynString	ToString() const;
//	operator char* () const { return (char*)ToString(); }
	operator DynString () const { return ToString(); }
	operator String () const { return (String)ToString(); }
	operator long () const { return (long)ToInt(); }
	operator int () const { return (int)ToInt(); }
	operator float () const { return (float)ToFloat(); }
	operator double () const { return (double)ToFloat(); }
	operator bool () const { return ToInt()!=0; }
	operator short () const { return (short)ToInt(); }
	operator char () const { return (char)ToInt(); }
	// Call Invalidate() if you changed a property's value manually
	DProperty&	Invalidate();
	DProperty&	SetChanged( bool changed =true );
	DProperty&	SetPersistent( bool persistent =true );
	// Use ID() to obtain a unique identifier (for switch..case)
	pid__t		ID() const { return (pid__t)Var; }
	bool		HasChanged() const { return (Flags & PF_CHANGED)!=0; }
	bool		IsReadOnly() const { return (Flags & PF_READONLY)!=0; }
	bool		IsPersistent() const { return (Flags & PF_PERSISTENT)!=0; }
private:
	ptype_t			Type;				// type of the value pointed to by Var
	mutable pvar_t	Var;				// pointer to actual data
	psize_t			Size;				// size of the value pointed to by Var
	DynString		Name;				// name of property
	DynString	_ToString( const void* ) const;
	void		_FromString( const void*, cstr_t );
};
///////////////////////////////////////////////////////////////////////////////
#define PROPERTY(p) DProperty(p,#p)
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_PROPERTY_H_INCLUDED
///////////////////////////////// [citk_Property.h] END
///////////////////////////////// [citk_ExtraData.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_EXTRADATA_H_INCLUDED
#define CITK_EXTRADATA_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTExtraData );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTExtraData : public CTStreamed
{
	DECLARE_ALL( CTExtraData, CTStreamed );
public:
//	CTExtraData() {}				// useless
	CTExtraData*	GetNext() { return next; }
//	void			SetNext( CTExtraData* n ) { next = n; }
	void			Append( CTExtraData* );
	bool			Remove( CTExtraData* );
	CTExtraData*	GetNext( ClassDesc* );
	CTExtraData*	GetNext( cdid_t );
	// Streaming:
	virtual void	WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool	ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	StrongPtr<CTExtraData>	next;				// strong
};
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTExtraData> PExtraData;
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_EXTRADATA_H_INCLUDED
///////////////////////////////// [citk_ExtraData.h] END
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTInterface);
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citk {
/////////////////////////////////////////////////////////////////////////////
class CTBrowseInfo;									// Forward reference
/////////////////////////////////////////////////////////////////////////////
/*
struct DProperties
{
	ArrayPtr<DProperty>	_Properties;
	~DProperties() { _Properties.DeleteAll(); }
};
*/
/////////////////////////////////////////////////////////////////////////////
class CITK_API CTInterface : public CTAggregated
{
	DECLARE_ALL( CTInterface, CTAggregated );
public:
	CTInterface();
	PExtraData		ExtraData;
	CTExtraData*	FindExtraData( cdid_t classid ) const;
	void			AddExtraData( CTExtraData* add );
	bool			RemoveExtraData( CTExtraData* );
	// Inherited from CTReferenced:
	// Returns a browse-info object for this specific object+type
	//  User is responsible for deleting this object by ref'ing and deref'ing it.
//	virtual CTBrowseInfo*	CreateBrowseInfo( CTBrowseInfo* Parent, int subdir_id );
	// Get the name of the actual configuration
	virtual String	GetConfigName();
	// Will call OnPropertyChanged for all changed properties
	void			ApplyChanges();
	// Read all properties from the registry (current configuration); call inherited
	virtual void	ReadProperties();
	// Write all properties to the registry (current configuration); call inherited
	virtual void	WriteProperties();
	// Call this to obtain the description for a property; call inherited
	virtual cstr_t	GetPropertyDescription( DProperty& );
	// Immediately apply a changed property
	DProperty*		ApplyPtr( void* );
	// Use this to change a property's value (or create a custom property)
	bool			SetProperty( cstr_t prop_name, cstr_t value =NULL );
	bool			SetProperty( cstr_t prop_name, long value );
	bool			RemoveProperty( cstr_t prop_name  );
	// Copy [custom] properties to another object
	void			CopyPropertiesTo( CTInterface *other, bool only_custom =true ) const;
	void			CopyPropertiesFrom( const CTInterface *other, bool only_custom =true );
	// Get number of properties in array
	int				CreateProperties();			// creates properties (if needed)
	bool			HasCustomProperties();
	int				GetPropertyCount();			// does not create properties
	// Call this when the properties are no longer needed
	void			RemoveProperties();
	// Get property at offset x in array (returns NULL if none)
	DProperty*		GetPropertyNo( const int ) const;
	// Get property by property name (case insensitive)
	DProperty*		GetPropertyByName( cstr_t );
	// Get property by variable pointer
	DProperty*		GetPropertyByPtr( void* );
	// Find a property by prefix (does not create properties)
	DProperty*		FindPropertyPrefix( cstr_t ) const;
	// Inherited. Adds the size of the properties
	virtual size_t	GetSizeEstimate();
	// Streaming:
	virtual void	WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool	ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	virtual ~CTInterface();						// Delete properties
	// Add a property to the array
	DProperty*		AddProperty( cstr_t, ClassDesc* =NULL );
	DProperty*		AddPropertyReg( cstr_t, ClassDesc* =NULL );	// Persistent
	DProperty*		AddPropertyRO( cstr_t, ClassDesc* =NULL );	// Read-only
	// Add the properties to the array; call inherited
	virtual	void	DoAddProperties();
	// Gets called if a property's value has changed; call inherited
	virtual void	OnPropertyChanged( DProperty& );
private:
	ArrayPtr<DProperty>	_Properties;
//	DProperties*	_Properties;
	int				_PropsCreated;
	DProperty*		_GetPropertyByName( cstr_t ) const;
	bool			_SetProperty( cstr_t, cstr_t );		// "clone"
};
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Macros to aid in adding properties
// Use these in DoAddProperties; remember to call inherited first!
// Normal variables (REG=Registry/persistent; RO=Read Only)
// Usage: <variable> [property_name]
#define ADDPROPERTY(a)			AddProperty(_T(#a),_CD())->_Set(a)
#define ADDPROPERTY2(a,b)		AddProperty( b,_CD())->_Set(a)
#define ADDPROPERTYREG(a)		AddPropertyReg(_T(#a),_CD())->_Set(a)
#define ADDPROPERTYREG2(a,b)	AddPropertyReg( b,_CD())->_Set(a)
#define ADDPROPERTYRO(a)		AddPropertyRO(_T(#a),_CD())->_Set(a)
#define ADDPROPERTYRO2(a,b)		AddPropertyRO( b,_CD())->_Set(a)
// Arrays
// Usage: <first_element> <element_count> [property_name]
#define ADDARRAY(a,s)			AddProperty(_T(#a),_CD())->_Set(a).SetCount(s)
#define ADDARRAY2(a,s,b)		AddProperty( b,_CD())->_Set(a).SetCount(s)
#define ADDARRAYREG(a,s)		AddPropertyReg(_T(#a),_CD())->_Set(a).SetCount(s)
#define ADDARRAYREG2(a,s,b)		AddPropertyReg( b,_CD())->_Set(a).SetCount(s)
#define ADDARRAYRO(a,s)			AddPropertyRO(_T(#a),_CD())->_Set(a).SetCount(s)
#define ADDARRAYRO2(a,s,b)		AddPropertyRO( b,_CD())->_Set(a).SetCount(s)
// RAW data (bytes)
// Usage: <pointer> <size_in_bytes> [property_name]
#define ADDDATA(a,s)			AddProperty(_T(#a),_CD())->_Set((void*)&(a),s)
#define ADDDATA2(a,s,b)			AddProperty( b,_CD())->_Set((void*)&(a),s)
// Pointer to CTBasic (or descendant)
// Usage: <pointer_to_CT`Basic> [property_name]
#define ADDPOINTER(a)			AddPropertyRO(_T(#a),_CD())->_Set((CTBasic*&)a)
#define ADDPOINTER2(a,b)		AddPropertyRO( b,_CD())->_Set((CTBasic*&)a)
// SmartPtr / StrongPtr / ServicePtr / DevicePtr
// Usage: <smart_pointer> [property_name]
#define ADDSMARTPTR(a)			AddPropertyRO(_T(#a),_CD())->_Set((PBasic&)a)
#define ADDSMARTPTR2(a,b)		AddPropertyRO( b,_CD())->_Set((PBasic&)a)
#define FINDEXTRADATA(clas)		(clas*)FindExtraData( CDID(clas) )
/////////////////////////////////////////////////////////////////////////////
} // namespace citk
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITK_INTERFACE_H_INCLUDED
///////////////////////////////// [citk_Interface.h] END
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTNamed);
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
namespace citk {
/////////////////////////////////////////////////////////////////////////////
class CITK_API CTNamed : public CTInterface
{
	DECLARE_ALL( CTNamed, CTInterface );
public:
	// Name of the object
	DynString		Name;								
	// Default constructor
	CTNamed() { }
	CTNamed( cstr_t );	
	// Return this object's name; creates a name if it has none
	cstr_t			GetName() const;
	// Inherited from CTBasic.
	virtual size_t	GetSizeEstimate();
	// Inherited: Streaming
	virtual void	WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool	ProcessChunk( CTStream* stream, chunkid_t chid );
};
///////////////////////////////////////////////////////////////////////
} // namespace citk
/////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
#endif	// !CITK_NAMED_H_INCLUDED
///////////////////////////////// [citk_Named.h] END
///////////////////////////////// [citk_ProcessInfo.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_PROCESSINFO_H_INCLUDED
#define CITK_PROCESSINFO_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_RenderState.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_RENDERSTATE_H_INCLUDED
#define CITK_RENDERSTATE_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_StrongArray.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef	CITK_STRONGARRAY_H_INCLUDED
#define	CITK_STRONGARRAY_H_INCLUDED
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////
template <class T>
class StrongArray : public ArrayPtr<T>
{
public:
	typedef T*		PT;								// pointer to pointer typedef
	
	// Constructors:
	StrongArray() { }
	StrongArray( const PT *data, size_t data_size ) { AddFrom(data,data_size); }
	StrongArray( const ArrayPtr<T> &ar ) { AddFrom(ar); }
	StrongArray( const StrongArray<T> &ar ) { AddFrom(ar); }
	// Destructor:
	~StrongArray() { if (Data) RemoveAll(); }
	// Methods:
	size_t		FindAndReplaceFrom( PT const, PT const, size_t );
	size_t		FindAndReplace( PT const d, PT const r ) { return FindAndReplaceFrom(d,r,0); }
	size_t		Push( PT const a ) { return Add(a); }
	PT			Pop() { PT p=NULL; assert(NumItems); if (NumItems!=0) p=Data[--NumItems]; return (p&&p->RemoveRef()!=0)?p:NULL; }
	size_t		Add( PT const );
	PT			AddNew();
	bool		AddUnique( PT const );
	PT			Remove( PT const );				// these can change the order
	PT			RemoveNo( size_t );				// these can change the order
	void		RemoveAll();
	void		RemoveEvery( PT const );		// removes every occurence of ...
	PT			SetNo( size_t, PT const );		// checks the input + grows
	size_t 		SetCount( size_t n );
	void		Empty();
	const PT*	Lock()								{ return ArrayPtr<T>::Lock(); }
	const PT*	GetData() const						{ return ArrayPtr<T>::GetData(); }
	void		AddFrom( const PT *data, size_t count );
	void		CopyFrom( const PT *data, size_t count ) { Empty(); AddFrom(data,count); }
	void		AddFrom( const ArrayPtr<T> &ar )	{ AddFrom(ar.GetData(),ar.Count()); }
	void		CopyFrom( const ArrayPtr<T> &ar )	{ Empty(); AddFrom(ar); }
	bool		AddUniqueID( PT, int& );
	bool		RemoveUniqueID( PT, int& );
	// Overloaded operators:
	void		operator = ( const StrongArray<T> &av )		{ CopyFrom(av); }
				operator const PT* () const			{ return Data; }
private:
	// The following methods are hidden; we use reference counting
	operator PT* () const;			// not implemented
	bool		Delete( PT const );
	bool		DeleteNo( size_t );
	void		DeleteAll();
};
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T>
size_t StrongArray<T>::Add( T* const d )
{
	if (NumItems >= MaxItems)
		_Larger();
	Data[NumItems] = d;
	if (d) d->AddRef();						// add a reference
	return NumItems++;
}
///////////////////////////////////////////////////////////////////////
template <class T>
bool StrongArray<T>::AddUnique( T* const d )
{
	int i = Find(d);
	return i==INVALID_ITEM?(Add(d),true):false;
}
///////////////////////////////////////////////////////////////////////
template <class T>
T* StrongArray<T>::AddNew()
{
	// Create a new instance; use ClassDesc if trustworthy, 'new' otherwise
	PT p = sizeof(T)!=T::_CD()->GetSize()?new T:(T*)T::_CD()->Create();
	Add( p );
	return p;
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T>
size_t StrongArray<T>::SetCount( size_t nn )
{ 
	if (nn>MaxItems) Reserve(nn); 
	size_t t;
	// Set new items to NULL
	for (t=NumItems; t<nn; ++t)
		Data[t] = NULL;
	// Remove references
	for (t=nn; t<NumItems; ++t)
		if (Data[t])
			Data[t]->RemoveRef();
	return NumItems = nn; 
}
///////////////////////////////////////////////////////////////////////
template <class T>
void StrongArray<T>::Empty()
{ 
	// Use this way so that DURING emptying, when this array is accessed only the items still referenced are accessible.
	while (NumItems>0)
	{
		NumItems--;
		if (Data[NumItems])
			Data[NumItems]->RemoveRef();
	}
	// This way may cause problems when objects removed somehow during deletion access this array and encounter deleted objects
/*	// Remove all references
	for (size_t t=0;t<NumItems;t++)
		if (Data[t]) 
			Data[t]->RemoveRef();
	NumItems = 0;*/
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T>
T* StrongArray<T>::Remove( T* const d )
{
	for (size_t t=0; t<NumItems; t++)
		if (Data[t] == d)
			return RemoveNo(t);
	return NULL;
}
///////////////////////////////////////////////////////////////////////
template <class T>
void StrongArray<T>::RemoveEvery( T* const d )
{
	size_t last=0;
	for (size_t t=0;t<NumItems;t++)	// Remove obsolete entries
	{
		if (Data[t]!=d)
		{
			if (last!=t)
				Data[last] = Data[t];
			last++;
		}
		else
		if (d)
			d->RemoveRef();			// Remove reference
	}
	NumItems = last;
}
///////////////////////////////////////////////////////////////////////
template <class T>
T* StrongArray<T>::RemoveNo( size_t i )
{
	if (!ContainsNo(i))
		return NULL;
	PT d = Data[i];
	NumItems--;
	if (NumItems != i)
		Data[i] = Data[NumItems];
#ifdef ARRAY_AUTO_SMALLER
	if (MaxItems > NumItems+Delta)		// >=
		_Smaller();
#endif // ARRAY_AUTO_SMALLER
	// Only return the pointer if there's a reference left
	return (d&&d->RemoveRef())?d:NULL;
}
///////////////////////////////////////////////////////////////////////
template <class T>
void StrongArray<T>::RemoveAll()
{
	// Removes references
	Empty();
	// Remove array
	_delete( Data );
	Data = NULL;
	MaxItems = 0;
}
///////////////////////////////////////////////////////////////////////
template <class T>
T* StrongArray<T>::SetNo( size_t i, PT const d )
{
	if (i<0)
		return NULL;
	if (i>=MaxItems)
		Reserve(i+Delta);				// i+1
	for (;NumItems<=i;NumItems++)		// fill the array up with NULL's
		Data[NumItems] = NULL;
	if (d) 
		d->AddRef();					// add reference first
	if (Data[i])
		Data[i]->RemoveRef();			// remove reference
	Data[i] = d;
	return d;
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T>
size_t StrongArray<T>::FindAndReplaceFrom( PT const p1, PT const p2, size_t f )
{
	if (p1==p2)
		return 0;
	size_t c=0;
	int i=f;
	while (1)
	{
		i = FindFrom(p1,i);
		if (i==INVALID_ITEM)
			break;
		c++;
		if (p2) 
			p2->AddRef();				// add new reference first
		if (Data[i]) 
			Data[i]->RemoveRef();		// remove old reference
		Data[i++] = p2;
	}
	return c;
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T>
void StrongArray<T>::AddFrom( const PT *data, size_t count )
{
	size_t ni = NumItems;
	SetCount( NumItems + count );
	// Copy data
	memcpy( (void*)&Data[ni], (void*)data, sizeof(PT)*count );
	// Add references
	for (size_t t=0;t<count;t++)
		if (data[t]) data[t]->AddRef();
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
template <class T>
bool StrongArray<T>::AddUniqueID( PT obj, int &ID )
{
	if (ID!=INVALID_ITEM)
	{
		THIS_ASSERT(GetNo(ID)==obj," Invalid ID");
		return false;
	}
	size_t iter = 0;
	// Search for first empty ID
	for (;iter<NumItems;iter++)
		if (!Data[iter])
			break;
	// Add to list
	SetNo(iter,obj);
	// Set ID
	ID = iter;
	return true;
}
///////////////////////////////////////////////////////////////////////////////
template <class T>
bool StrongArray<T>::RemoveUniqueID( PT obj, int &ID )
{
	if (ID==INVALID_ITEM)
		return false;
	// Cross check with list
	if (GetNo(ID)!=obj)
	{
		THIS_ASSERT(0," Invalid ID");
		return false;
	}
	// Remove from list
	SetNo( ID, NULL );
	// Remove ID
	ID = INVALID_ITEM;
	return true;
}
///////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
#endif // !CITK_STRONGARRAY_H_INCLUDED
///////////////////////////////// [citk_StrongArray.h] END
///////////////////////////////// [citk_RenderProperty.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_RENDERPROPERTY_H_INCLUDED
#define CITK_RENDERPROPERTY_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTRenderProperty );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTRenderProperty : public CTStreamed
{
	DECLARE_ALL( CTRenderProperty, CTStreamed );
public:
	int		Priority;
	bool	Combine;		// combine with parent property?
	// Default constructor (combining by default)
	CTRenderProperty() : Priority(0), Combine(true), _ID(ID_NONE) {}
	// Copy constructor
	CTRenderProperty( const CTRenderProperty *r ) : 
		Priority(r->Priority), Combine(r->Combine), _ID(ID_NONE) {}
	// Unique property ID (for hardware caching)
	id__t			GetID() const { return _ID; }
	id__t			RequestID() const;
	virtual CTRenderProperty* Clone() const = 0;					// CONST!
	// Method for combining two properties (no class check!)
	virtual bool	_Combine( const CTRenderProperty* ) { return false; }
	// Method for comparing two properties (const; no class check!)
	virtual bool	_Compare( const CTRenderProperty* ) const = 0;	// CONST!
	// For networking, loading & saving (inherited from CTStreamed)
	virtual void	WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool	ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	mutable id__t	_ID;
	static IDBroker	property_ids;
	// Destructor (frees the ID)
	virtual ~CTRenderProperty();
};
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTRenderProperty> PRenderProperty;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITK_RENDERPROPERTY_H_INCLUDED
///////////////////////////////// [citk_RenderProperty.h] END
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTRenderState );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTRenderState : public CTNamed
{
	DECLARE_ALL( CTRenderState, CTNamed );
public:
	// Array of unspecified property classes
	StrongArray<CTRenderProperty>	RenderProperties;
	// Default constructor
	CTRenderState() : _ID(ID_NONE) {}
	// Copy constructor
	CTRenderState( const CTRenderState* );
	// Returns a copy, using the same render property objects
	CTRenderState*	Clone() const;
	// Unique property ID (for hardware caching)
	id__t			GetID() const						{ return _ID; }
	id__t			RequestID() const;
	// Gets a specific property from this state (combines if needed)
	// This is what you'll normally use to get the actual state.
	// NOTE: might return a temporary property! Catch it in a StrongPtr<>
	CTRenderProperty* MakeRenderProperty( ClassDesc* ) const;
	// Find a property of some kind (starting at the end)
	CTRenderProperty* FindRenderProperty( ClassDesc* ) const;
	// Creates a property of some kind or returns an existing one
	CTRenderProperty* CreateRenderProperty( ClassDesc* );
	void			SetRenderProperty( CTRenderProperty* );
	bool			RemoveRenderProperty( ClassDesc* );
	void			Reset();
	bool			IsEmpty() const { return RenderProperties.IsEmpty(); }
	// Collect all properties of a specific kind (no combining)
	int				Collect( ClassDesc*, ArrayPtr<CTRenderProperty>& ) const;
	// Compare all the properties of two render states
	bool			Compare( const CTRenderState* ) const;
	// Compare all the properties of two render states, merge equal ones
	bool			CompareAndMerge( const CTRenderState* );
	// Stack operations; return/take the amount of properties
	int				Push( CTRenderState* );
	int				Push( CTRenderProperty* );
	void			Pop( int =1 );			// pops one property by default
	// Inherited from CTStreamed:
	virtual void	WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool	ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	mutable id__t	_ID;
	static IDBroker	state_ids;
	// Destructor (frees the ID)
	virtual ~CTRenderState();
	// Inherited from CTAggregated. Registers with RenderStateManager.
	virtual bool	DoRegisterWithService();
	virtual bool	DoUnregisterWithService();
};
/////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTRenderState> PRenderState;
/////////////////////////////////////////////////////////////////////////////
#define FIND_RENDER_PROPERTY( __class, __state ) \
	(__class*) (__state)->FindRenderProperty( CD(__class) )
#define CREATE_RENDER_PROPERTY( __class, __state ) \
	(__class*) (__state)->CreateRenderProperty( CD(__class) )
/////////////////////////////////////////////////////////////////////////////
} // namespace citk
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITK_RENDERSTATE_H_INCLUDED
///////////////////////////////// [citk_RenderState.h] END
/////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
/////////////////////////////////////////////////////////////////////////////
struct DRenderContext;
class CTMicrophone;
class CTSoundDevice;
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#define INTERSECT_IN		0x80000000
#define INTERSECT_OUT		0x40000000
#define INTERSECT_UNKNOWN	0x3fffffff
///////////////////////////////////////////////////////////////////////////////
struct RenderInfo_t
{
	DRenderContext*		Context;			// Current context
	flags_t				FrustumFlags;		// Frustum flags
	CTRenderState*		State;
	const DTransform*	WorldTransform;
	// Default constructor
	RenderInfo_t() : State(NULL), WorldTransform(&DTransform::I), FrustumFlags(INTERSECT_UNKNOWN), Context(NULL) {}
	// Obsolete: (will me removed soon)
	RenderInfo_t( DRenderContext* c ) : State(NULL), WorldTransform(&DTransform::I), FrustumFlags(INTERSECT_UNKNOWN), Context(c) {}
	void	SetWorldTransform( const DTransform &T ) { WorldTransform = &T; }
	void	SetRenderContext( DRenderContext *rc ) { Context = rc; }
	void	SetFrustumFlags( flags_t f ) { FrustumFlags = f; }
	void	SetRenderState( CTRenderState* rs ) { State = rs; }
};
///////////////////////////////////////////////////////////////////////////////
struct SoundInfo_t
{
	CTMicrophone*	Microphone;
	CTSoundDevice*	SoundDevice;
	// Default constructor
	SoundInfo_t() : Microphone(NULL), SoundDevice(NULL) {}
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// This structure is passed to CTEntity::Process(..)
struct ProcessInfo_t
{
	DFlags					ProcessFlags;		// PF_KIND_xxx and EH_DRAW_xxx
	const DTransform*		OverrideWorldTransform;
//	const DTransform*		WorldTransform;
	
	ctime_t					WorldTime;
	PRenderState			RenderState;
	RenderInfo_t			RenderInfo;
	SoundInfo_t				SoundInfo;
	ProcessInfo_t() : OverrideWorldTransform(NULL) {}
};
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
/////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_PROCESSINFO_H_INCLUDED
///////////////////////////////// [citk_ProcessInfo.h] END
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTProcess);
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citk {
/////////////////////////////////////////////////////////////////////////////
// Messages:
#define MSG_PROCESS_KINDSCHANGED			0x5AB8F58F
// Additional flags passed in ProcessInfo_t
#define PF_PROCESSPOINT		0x00000001		// start processing here
#define PF_DRAW_PRE			0x00001000
#define PF_DRAW_TREE		0x00002000
#define PF_DRAW_POST		0x00004000
#define PF_DRAW_2D			0x00008000
#define PF_DRAW_MASK		0x0000F000
#define PF_USER_MASK		0x0000FFFF		// users can change only these flags
#define PF_KIND_NULL		0x00000000		// NULL object (nothing)
#define PF_KIND_DRAW		0x00010000		// drawable object
#define PF_KIND_SOUND		0x00020000		// hearable object
#define PF_KIND_LIGHT		0x00040000		// object is a light
#define PF_KIND_SOUND_MOD	0x00080000		// changes appearance of hearable objects
#define PF_KIND_OCCLUDER	0x00100000		// object is an occluder (big)
#define PF_KIND_OTHER2		0x00200000		// (for future expansion)
#define PF_KIND_OTHER3		0x00400000
#define PF_KIND_OTHER4		0x00800000
#define PF_KIND_MASK		0x00FF0000
#define PF_KIND_FIRST		0x00010000		// first kind flag
#define PF_KIND2MASK(f)		(((f)&PF_KIND_MASK)<<8)
#define PF_MASK2KIND(f)		(((f)>>8)&PF_KIND_MASK)
// Some easy to read kind-masks
#define PF_HIDE				(PF_KIND_DRAW<<8)
#define PF_MUTE				(PF_KIND_SOUND<<8)
#define PF_LIGHTOFF			(PF_KIND_LIGHT<<8)
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class CITK_API CTProcess : public CTNamed
{
	DECLARE_ALL(CTProcess,CTNamed);
public:
	//	Flags to identify object kind: (also used in ProcessInfo_t)
	enum kind_t
	{
		DRAW=0,							// 0 drawable object
		SOUND,							// 1 hearable object
		LIGHT,							// 2 object is a light
		SOUND_MOD,						// 3 modifies the way we hear stuff
		OCCLUDER,						// 4 object is an occluder
		OTHER1,							// 5 (for future expansion)
		OTHER2,							// 6
		OTHER3,							// 7
		KINDCOUNT						// 8 number of kind flags
	};
	// Constructor (2 in 1)
	CTProcess( cstr_t name =NULL );
	
	// Copy constructor:
	CTProcess( const CTProcess * copy_this_one);
	/////////////////////////////////////////////////////////////////////////////
	// Flags methods:
	void				ClearFlags( flags_t f )	{ Flags.Clear(f&PF_USER_MASK); }
	void				SetFlags( flags_t f )	{ Flags.Set(f&PF_USER_MASK); }
	flags_t				GetFlags() const		{ return Flags; }
	/////////////////////////////////////////////////////////////////////////////
	// General
	// Process function; override this 
	virtual void		Process( ProcessInfo_t& ) = 0;
	/////////////////////////////////////////////////////////////////////////////
	// Kind methods:
	void				SetMask( flags_t kind );
	flags_t				GetMask() const { return PF_MASK2KIND(Flags); }
	void				ClearMask( flags_t kind );
	inline flags_t		GetKindBits() { return PF_MASK2KIND(~Flags)&Flags; }
	// Disable/enable all processing beyond this process
	void				Disable() { SetMask(PF_KIND_MASK); }
	void				Enable() { ClearMask(PF_KIND_MASK); }
	// Simple methods for visuals
	inline void			Hide() { SetMask(PF_KIND_DRAW); }
	inline void			Show() { ClearMask(PF_KIND_DRAW); }
	inline bool			IsHidden() { return Flags(PF_HIDE)!=0; }
	// Simple methods for sounds
	inline void			Mute() { SetMask(PF_KIND_SOUND); }
	inline void			Unmute() { ClearMask(PF_KIND_SOUND); }
	inline bool			IsMuted() { return Flags(PF_MUTE)!=0; }
	/////////////////////////////////////////////////////////////////////////////
	// For networking, loading & saving (inherited)
	virtual void		WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool		ProcessChunk( CTStream* stream, chunkid_t chid );
	/////////////////////////////////////////////////////////////////////////////
	PRenderState		RenderState;
	CTRenderState*		CreateRenderState();			// will create if not exists
	// Set the KIND flags of this process; call this in the constructor.
	// Use depricated from OUTSIDE class, use with extreme care!
	void				_SetKind ( flags_t kindflags );
protected:
	// General process flags (PF_xxx)
	DFlags				Flags;
	// Adjusts the mask of this process (and propagates to parents)
	void				_SetMask ( flags_t kindflags );
	// Returns the actual PF_KIND_xx's to be processed (applies the PF_MASK_ flags)
	inline flags_t		_ProcessWhat( flags_t processflags ) { return (~PF_MASK2KIND(Flags))&Flags&processflags&PF_KIND_MASK; }
	// Destructor
	virtual ~CTProcess();
	// Inherited:
	virtual void		DoAddProperties();
	/////////////////////////////////////////////////////////////////////////////
};
/////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTProcess> PProcess;
/////////////////////////////////////////////////////////////////////////////
#define FINDRENDERPROPERTY( __state, __class ) \
	(__class*) (__state)->FindRenderProperty( CD(__class) )
/////////////////////////////////////////////////////////////////////////////
} // namespace citk
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !_PROCESS_H_INCLUDED
///////////////////////////////// [citk_Process.h] END
///////////////////////////////// [citk_MotionSensor.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_MOTIONSENSOR_H_INCLUDED
#define CITK_MOTIONSENSOR_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTMotionSensor);
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citk {
/////////////////////////////////////////////////////////////////////////////
class CTEntity;
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
struct MotionInfo_t
{
	DTransform	Transform;
	Vector		Vel;
	Vector		Accel;
	Vector		AngVel;
	Vector		AngAccel;
	// Default constructor
	MotionInfo_t() {Vel.Zero(); Accel.Zero(); AngVel.Zero(); AngAccel.Zero(); }
	// Reset all members
	void		Reset() { Vel.Zero(); Accel.Zero(); AngVel.Zero(); AngAccel.Zero(); Transform.Reset(); }
};
/////////////////////////////////////////////////////////////////////////////
class CITK_API CTMotionSensor : public CTAggregated
{
	DECLARE_ALL(CTMotionSensor, CTAggregated);
public:
	// Used in CTEntity::RequestMotionSensor
	CTMotionSensor( CTEntity* =NULL );
	void				SetEntity( CTEntity* );
	CTEntity*			GetEntity() const;
	const MotionInfo_t&	GetMotionInfo();
	// Called by the controller in order to share it's information
	void				ControllerSetMotionInfoSource( MotionInfo_t* );
	//	Calculating Utility fuctions
	const Vector&		GetVel();
	Vector				GetVel(const Vector& localpoint);
	const Vector&		GetAngVel();
	const Vector&		GetAcc();
	Vector				GetAcc(const Vector& localpoint);
	const Vector&		GetAngAcc();
protected:
	SafePtr<CTEntity>	Subject;
	StrongPtr<CTMotionSensor> ParentSensor;
//	MotionInfo_t*		ControllerMotionInfo;
	MotionInfo_t		MotionInfo;
//	void*				Parent;
//
	DTransform			LastTransform;
	bool				UpToDate, Sensoring;
	double				Interval;
	void				RecalcMotionInfo();
	UPDATEFUNC			IncrementFrameCount( ctime_t );
};
/////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTMotionSensor> PMotionSensor;
/////////////////////////////////////////////////////////////////////////////
} // namespace citk
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITK_MOTIONSENSOR_H_INCLUDED
///////////////////////////////// [citk_MotionSensor.h] END
///////////////////////////////// [citk_Shape.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_SHAPE_H_INCLUDED
#define CITK_SHAPE_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_Frustum.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_FRUSTUM_H_INCLUDED
#define CITK_FRUSTUM_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
/////////////////////////////////////////////////////////////////////////////
class DTransform;
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class CITK_API DFrustum
{
public:
	enum
	{
		// Prefixed since NEAR and FAR are defined by windows.h
		FP_NEAR = 0,				// the six default planes
		FP_LEFT, 
		FP_RIGHT,
		FP_BOTTOM,
		FP_TOP,
		FP_FAR,
		FP_CUSTOM,						// first custom plane
		NUM_FRUSTUM_PLANES = 6,
		MAX_FRUSTUM_PLANES = 32
	};
	flags_t				mask;
	ArrayVal<Plane3>	planes;
	//! Default constructor (creates and enables the default planes)
	DFrustum() { planes.SetCount(NUM_FRUSTUM_PLANES); mask=(1<<NUM_FRUSTUM_PLANES)-1; }
	//! Copy constructor
	DFrustum( const DFrustum &F ) : planes(F.planes), mask(F.mask) {}
	//! Constructor; create x planes and enable them
	explicit DFrustum( const int np ) { planes.SetCount(np); mask=(1<<np)-1; }
	// Operators
	DFrustum&		operator = ( const DFrustum &F ) { planes.CopyFrom(F.planes); mask=F.mask; return *this; }
	Plane3&			operator [] (int p)				{ return planes[p]; }
	const Plane3&	operator [] (int p) const		{ return planes[p]; }
	DFrustum&		operator |= ( const DFrustum &F );
	DFrustum&		operator &= ( const DFrustum &F );
	DFrustum		operator | ( const DFrustum &F ) const;
	DFrustum		operator & ( const DFrustum &F ) const;
	// Math
	int				NumPlanes() const { return planes.Count(); }
	bool			CheckVector( const Vector & ) const;
	int				CheckVectors( Vector*, int count ) const;
	bool			CheckVectorsIn( Vector*, int count ) const;
	bool			CheckVectorsOut( Vector*, int count ) const;
	// Planes
	DFrustum&		EnablePlane( int p, bool m=true ) { if (m && planes.ContainsNo(p)) mask|=(1<<p); else mask&=~(1<<p); return *this; }
	bool			HasPlane( int p ) const { return (mask&(1<<p))!=0; }
	//	These added by flipje for use with his magnificent and superb space partitioning code
	int				AddPlane( const Plane3& p ) ;
	bool			SetPlane( int i, const Plane3& p ) ;
	const Plane3&	GetPlane( int i ) const {return planes[i];}
	DFrustum&		Clear() ;
	// Boolean operations:
	DFrustum&		Narrow( const DFrustum &F );
	DFrustum&		Merge( const DFrustum &F );
	// Transformation:
	DFrustum&		Transform( const Matrix&, const Vector& );
	DFrustum&		TransformBest( const Matrix&, const Vector& );
	DFrustum&		Transform( const DTransform& );
	// Creation (all these create a frustum in camera space)
	DFrustum&		SetNearPlane( cfloat__t );
	DFrustum&		SetFarPlane( cfloat__t );
	DFrustum&		CreatePerspective( cfloat__t fov, const DRect<float> &camrect );
	DFrustum&		CreateOrthogonal( cfloat__t fov, const DRect<float> &camrect );
};
/////////////////////////////////////////////////////////////////////////////
} // namespace citk
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITK_FRUSTUM_H_INCLUDED
///////////////////////////////// [citk_Frustum.h] END
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTShape );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
// Available bounding volumes
class CTBox;
class CTSphere;
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTShape : public CTInterface
{
	DECLARE_ALL( CTShape, CTInterface );
public:
	float__t				Elasticity;
	float__t				Mass;
	Vector				InertialMass;
//	PMaterial			Material;			// legacy
//	PUVWMapper			UVWMapper;
	// Constructors:
	CTShape();
	CTShape( const CTShape* );
	// General:
	flags_t				GetFlags() const { return _Flags; }
	virtual void		SetPivot( cvec_t p );
	cvec_t		GetPivot() const { return _Pivot; }
	bool				HasPivot() const { return _Flags.TestBit(HAS_PIVOT); }
	virtual double		CalcVolume() { return 0.0; }
	virtual double		CalcArea() { return 0.0; }
	const Matrix&		GetCWMatrix() { UpdateCWMatrix(); return _CW_Matrix; }
	virtual	CTShape*	Copy() const =0;
	virtual bool		ApplyTransform( const DTransform &T );
	virtual bool		ResetTransform();
	virtual bool		SetTransform( const DTransform &T );
	// Collision detection helpers:
	virtual Vector		GetSupport( cvec_t ) =0;
	inline Vector		GetSupport2( cvec_t v ) { return GetSupport(v) + GetPivot(); }
	virtual Normal		GetNormal( cvec_t ) =0;
	virtual Vector		GetClosestPoint( cvec_t );
	virtual double		GetMaxY( cvec_t );
	virtual double		GetMaxYAndNormal( cvec_t, Normal& );
	bool				IntersectTest( const DTransform*, const CTShape*, const DTransform* );
	bool				CommonPointTest( const DTransform*, const CTShape*, const DTransform*, Vector& );
	double				ClosestPointsTest( const DTransform*, const CTShape*, const DTransform*, Vector& );
	intersect_t			ExtIntersectTest( const DTransform*, const CTShape*, const DTransform* );
	// Bounding volume
	virtual bool		IsConvex() const { return false; }
	virtual CTSphere*	GetBoundingSphere();
	virtual CTBox*		GetBoundingBox();
	virtual CTShape*	GetBoundingVolume();
	bool				GetAABB( Vector &min, Vector &max, const DTransform* =NULL );
	// Rendering [legacy]:
	virtual void		Render( const RenderInfo_t& ) =0;
	// Simple intersection tests
	virtual intersect_t	CheckWithPoint( cvec_t, const DTransform* =NULL ) { return irUnknown; }
	virtual intersect_t	CheckWithHalfspace( const Plane3&, const DTransform* =NULL ) { return irUnknown; }
	virtual intersect_t	CheckWithLine( const Line3&, const DTransform* =NULL ) { return irUnknown; }
	virtual intersect_t	CheckWithRay( const Line3&, float__t &current_t, const DTransform* =NULL ) { return irUnknown; }
	virtual intersect_t	CheckAgainstFrustum( const DFrustum &, const DTransform* =NULL, flags_t* clipplanes=NULL);
	// For networking, loading & saving
	virtual void		WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool		ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	enum {
		SHAPE_VALID = 0,	// set when only the vectors have changed
		HAS_PIVOT,			// non-zero pivot
		__RESERVED,			// reserved
		MAX_POS				// first custom bit should be inherited::MAX_POS
	};
	Vector				_Pivot;
	DFlags				_Flags;
	Matrix				_CW_Matrix;
	inline void			_SetValid() { _Flags.SetBit(SHAPE_VALID); }
	inline bool			_IsValid() const { return _Flags.TestBit(SHAPE_VALID); }
	inline void			_Invalidate() { _Flags.ClearBit(SHAPE_VALID); }
	
	// Inherited:
	virtual void		DoAddProperties();
	virtual void		UpdateCWMatrix();
};
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTShape> PShape;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_SHAPE_H_INCLUDED
///////////////////////////////// [citk_Shape.h] END
///////////////////////////////// [citk_EntityController.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_ENTITYCONTROLLER_H_INCLUDED
#define CITK_ENTITYCONTROLLER_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_Controller.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_CONTROLLER_H_INCLUDED
#define CITK_CONTROLLER_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTController );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
	
/////////////////////////////////////////////////////////////////////////////
class CITK_API CTController : public CTNamed
{
	DECLARE_ALL( CTController, CTNamed );
public:
	CTController();
	// Starts the controller; returns false if failed
	bool			Enable();
	// Stops the controller
	void			Disable();
	// Returns the current state of the controller
	bool			IsEnabled() const { return Enabled; }
	// Reset the controller to its initial state
	virtual void	Reset() {}
	// For streaming / networking:
	virtual void	WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool	ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	bool			Enabled;
	virtual	bool	DoEnable() { return true; }
	virtual void	DoDisable() {}
	virtual	void	DoAddProperties();
};
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
	
/////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_CONTROLLER_H_INCLUDED
///////////////////////////////// [citk_Controller.h] END
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTEntityController );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CTEntity;
struct MotionInfo_t;
//! Possible actions to be taken when the entity collides
enum CollisionAction_t { caNothing, caEnable, caDisable, caToggleEnable, caRemoveFromWorld };
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTEntityController : public CTController
{
	DECLARE_ALL( CTEntityController, CTController );
public:
	CTEntityController();
	void			SetObject( CTEntity* );
	CTEntity*		GetObject() const;
	//! Set the action to be taken when the entity collides
	void			SetCollisionAction( CollisionAction_t );
	virtual MotionInfo_t*	GetMotionInfoSource();
	//! Collision detection callback
	virtual void	OnCollision( CTEntity*, Vector3* local, Vector3* direction );
	//! Method for cloning (Cloned entities will have cloned controllers)
	virtual CTEntityController*	Copy() const = 0;
	// For streaming / networking:
	virtual void	WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool	ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	CTEntity*			Entity;
	CollisionAction_t	CollisionAction;
	//! You can use this update-function to update a entities bounding volume
	UPDATEFUNC			UpdateBoundingVolume( ctime_t );
	virtual void		DoAddProperties();
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTEntityController> PEntityController;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_ENTITYCONTROLLER_H_INCLUDED
///////////////////////////////// [citk_EntityController.h] END
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTEntity);
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citk {
/////////////////////////////////////////////////////////////////////////////
// Messages:
#define MSG_ENTITY_REMOVEFROMWORLD		0x5AB8F58E
#define MSG_TREE_ONNEWSUBTREE			0x2740BB13
// Flags for specific properties of entities
#define EH_STATIC			0x00000001		// static entity
#define EH_CHECKBOUNDS		0x00000002		// enable bounding volume check
#define EH_DRAWBOUNDS		0x00000004		// drawables draw their bounding volume
#define EH_DRAWCOLVOL		0x00000008		// drawables draw their collision volume
#define EH_DONT_UPDATEBV	0x00000010		// don't update bounding volume automatically
#define EH_DONT_PICK		0x00000020		// object not available for picking
#define EH_OCCL_TEST		0x00000040		// test for occlusion
#define EH_HELPER			0x00000080		// just a helper entity
#define EH_USER_MASK		0xFFFF00FF		// users can change only these flags
// Flags to lock specific transformation(s) (i.e. not inherited from parent)
#define EH_LOCK_ROT			0x00000100		// lock the totation (WorldRot = OwnRot)
#define EH_LOCK_POS			0x00000200		// lock the position (WorldPos = OwnPos)
#define EH_LOCK_DEF			0x00000400		// lock the deformation (WorldDef = OwnDef)
#define EH_LOCK_MASK		(EH_LOCK_POS|EH_LOCK_DEF|EH_LOCK_ROT)
/////////////////////////////////////////////////////////////////////////////
#define STREAMLOD_ENTITY_POS		0x00000200
#define STREAMLOD_ENTITY_ROT		0x00000400
#define STREAMLOD_ENTITY_DEF		0x00000800
#define STREAMLOD_ENTITY_TRANSFORM	0x00000E00	// POS|ROT|DEF
#define STREAMLOD_ENTITY_BOUNDS		0x00001000	// include BV objects
#define STREAMLOD_ENTITY_RESERVED	0x00002000	// (for future expansion)
/////////////////////////////////////////////////////////////////////////////
typedef unsigned long collisionmask_t;
/////////////////////////////////////////////////////////////////////////////
// Forwards:
class DTreePicker;
class CTGroup;
typedef StrongPtr<CTGroup> PGroup;
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class CITK_API CTEntity : public CTProcess
{
	DECLARE_ALL(CTEntity,CTProcess);
public:
	// Constructor (3 in 1)
	CTEntity( cstr_t name =NULL, CTGroup* parent =NULL );
	
	// Copy constructor:
	CTEntity( const CTEntity * copy_this_one);
	/////////////////////////////////////////////////////////////////////////////
	// General
	// Creates a copy
	virtual CTEntity*	Copy() const; 
	// Process function, empty
	virtual void		Process( ProcessInfo_t& )	{ }
	/////////////////////////////////////////////////////////////////////////////
	// BoundingVolume methods:
	// Creates the most efficient bounding volume
	void				UseBoundingVolume( CTShape*, kind_t kind );
	CTShape*			GetBoundingVolume( kind_t kind ) const { return _smaller(kind,KINDCOUNT)?(CTShape*)BoundingVolume[kind]:NULL; }
	CTShape*			CreateBoundingVolume( kind_t kind );
	bool				CheckVisibility( RenderInfo_t& );
	virtual CTShape*	UpdateBoundingVolume( kind_t kind );
	virtual bool		CheckWithRay( DTreePicker&, const Line3& );
	/////////////////////////////////////////////////////////////////////////////
	// Controller methods:
	void				SetController( CTEntityController* );
	CTEntityController*	GetController() const;
	// Just to check, eg. for Controllers that want to 'hint' the sensor.
	CTMotionSensor*		GetMotionSensor() const;		
	
	// Request a motion sensor (creates one if necessary). (De-)Referencing done by 'users'
	CTMotionSensor*		RequestMotionSensor();		
	/////////////////////////////////////////////////////////////////////////////
	// Parent / Child methods:
	CTGroup*			GetParent() const { return Parent; }
	int					GetTreeLevel() const { return TreeLevel; }
	// Gets the root of the tree I'm in; NULL when I'm the root
	CTGroup*			GetRoot() const { return _Root; }
	bool				IsRoot() const { return (void*)Parent==NULL; }
	void				SetParent( CTGroup* const );
	void				ChangeParent( CTGroup* const );		// Retains WorldPosition
	virtual void		UpdateRoot();						// Called by SetParent and itself (propag.)
	virtual CTGroup*	FindParent( CTGroup* const );
	virtual CTGroup*	FindParentByName( cstr_t );
	virtual CTEntity*	FindChildByName( cstr_t name ) { return Name.Equals(name)?this:NULL; }
	virtual CTEntity*	FindChildByNameIC( cstr_t name ) { return Name.EqualsIC(name)?this:NULL; }
	virtual CTEntity*	FindChild( CTEntity * const e) { return this==e?this:NULL; }
	// Method to remove me from the tree; calls SetParent(NULL)
	void				RemoveFromWorld( ctime_t delay =0 );
	// Override this call to be notified when removed from the world tree
	virtual void		OnRemoveFromWorld() {}
	virtual void		OnParentChanged();
	virtual void		MakeOtherTwin( CTEntity* i_will_change ) const;
	virtual void		MakeTwin( const CTEntity* i_am_example );
	PGroup				InsertGroupAbove( CTGroup* newgroup=NULL );
	/////////////////////////////////////////////////////////////////////////////
	// Hints methods:
	void				ClearHint( flags_t f )	{ Hints.Clear(f&EH_USER_MASK); }
	void				SetHint( flags_t f )	{ Hints.Set(f&EH_USER_MASK); }
	flags_t				GetHints() const		{ return Hints; }
	/////////////////////////////////////////////////////////////////////////////
	// Collision detection:
	void				SetCollisionVolume( CTShape* colshape );
	CTShape*			GetCollisionVolume() const;
	collisionmask_t		GetCollisionMask() const { return CollisionMask; }
	void				SetCollisionMask( collisionmask_t );
	// Collision call-back function
	virtual void		OnCollision( CTEntity*, Vector* local, Vector* direction );
	/////////////////////////////////////////////////////////////////////////////
	// Transform related methods
	// Makes sure world-space is up-to-date
	bool						UpdateWorldSpace ();
	virtual void				UpdateTreeWorldSpace ();
	inline const DTransform&	GetTransform() const		{ return Transform; }
	inline DTransform&			GetTransformRef()			{ return Transform; }
	inline const DTransform&	GetWorldTransform()	const	{ 
		return WorldTransform?*WorldTransform:(Parent?((CTEntity*)Parent)->GetWorldTransform():Transform); }
	// Update the world-space of THIS entity only!
	// Assumes the parent has been updated
	bool						UpdateMyWorldSpace ();
	/////////////////////////////////////////////////////////////////////////////
	inline void					ResetTransform()		{ Transform.Reset(); }
	inline void					ResetRotation()			{ Transform.ResetRotation(); }
	inline void					ResetPosition()			{ Transform.ResetPosition(); }
	inline void					ResetDeform()			{ Transform.ResetDeformation(); }
	/////////////////////////////////////////////////////////////////////////////
	inline const Matrix&		GetMatrix()	const		{ return Transform.GetMatrix(); }
	inline const Matrix&		GetRotation()	const	{ return Transform.GetRotationMatrix(); }
	inline const Vector&		GetPosition() const		{ return Transform.GetPosition(); }
	inline const Matrix&		GetDeform()	const		{ return Transform.GetDeformationMatrix(); }
	inline const Quaternion&	GetQuat() const			{ return Transform.GetQuaternion(); }
	inline const Vector&		GetDirection() const	{ return Transform.GetDirection(); }
	inline float__t				GetAz()	const			{ return Transform.GetAz(); }
	inline float__t				GetEl() const 			{ return Transform.GetEl(); }
	inline float__t				GetTw() const 			{ return Transform.GetTw(); }
	/////////////////////////////////////////////////////////////////////////////
	inline const Matrix&		GetWorldMatrix() const		{ return GetWorldTransform().GetMatrix(); }
	inline const Matrix&		GetWorldRotation() const	{ return GetWorldTransform().GetRotationMatrix(); }
	inline const Vector&		GetWorldPosition() const	{ return GetWorldTransform().GetPosition(); }
	inline const Matrix&		GetWorldDeform() const		{ return GetWorldTransform().GetDeformationMatrix(); }
	inline const Quaternion&	GetWorldQuat() const		{ return GetWorldTransform().GetQuaternion(); }
	inline const Vector&		GetWorldDirection() const	{ return GetWorldTransform().GetDirection(); }
	inline float__t				GetWorldAz() const		{ return GetWorldTransform().GetAz(); }
	inline float__t				GetWorldEl() const		{ return GetWorldTransform().GetEl(); }
	inline float__t				GetWorldTw() const		{ return GetWorldTransform().GetTw(); }
	/////////////////////////////////////////////////////////////////////////////
	//  Postition transformations
	inline void		MoveBy( const Vector& v )		{ Transform.MoveBy(v); }
	inline void		MoveTo( const Vector& v )		{ Transform.MoveTo(v); }
	inline void		MoveToX( cfloat__t a )			{ Transform.MoveToX(a); }
	inline void		MoveToY( cfloat__t a )			{ Transform.MoveToY(a); }
	inline void		MoveToZ( cfloat__t a )			{ Transform.MoveToZ(a); }
											    
	inline void		MoveByX( cfloat__t a )			{ Transform.MoveByX(a); }
	inline void		MoveByY( cfloat__t a )			{ Transform.MoveByY(a); }
	inline void		MoveByZ( cfloat__t a )			{ Transform.MoveByZ(a); }
	inline void		MoveRight	( cfloat__t a )		{ Transform.MoveRight(a); }
	inline void		MoveLeft	( cfloat__t a )		{ Transform.MoveLeft(a); }
	inline void		MoveUp		( cfloat__t a )		{ Transform.MoveUp(a); }
	inline void		MoveDown	( cfloat__t a )		{ Transform.MoveDown(a); }
	inline void		MoveForward	( cfloat__t a )		{ Transform.MoveForward(a); }
	inline void		MoveBack	( cfloat__t a )		{ Transform.MoveBack(a); }
	// Euler angle functions:
	inline void		SetEuler( cfloat__t az, cfloat__t el, cfloat__t tw ) { Transform.SetEuler(az,el,tw); }
	inline void		SetAz( cfloat__t az )			{ Transform.SetAz(az); }
	inline void		SetEl( cfloat__t el )			{ Transform.SetEl(el); }
	inline void		SetTw( cfloat__t tw )			{ Transform.SetTw(tw); }
	inline void		IncreaseAz( cfloat__t a )		{ Transform.IncreaseAz(a); }
	inline void		IncreaseEl( cfloat__t a )		{ Transform.IncreaseEl(a); }
	inline void		IncreaseTw( cfloat__t a )		{ Transform.IncreaseTw(a); }
	// Quaternion functions:
	inline void		SetQuat( const Quaternion& x)	{ Transform.SetQuat(x); }
	inline void		RotateQuatByAz( cfloat__t a )	{ Transform.RotateQuatByAz(a); }
	inline void		RotateQuatByEl( cfloat__t a )	{ Transform.RotateQuatByEl(a); }
	inline void		RotateQuatByTw( cfloat__t a )	{ Transform.RotateQuatByTw(a); }
	// Matrix functions:
	inline void		SetMatrix( const Matrix& x)		{ Transform.SetMatrix(x); }
	inline void		SetRotation( const Matrix& x)	{ Transform.SetRotationMatrix(x); }
	inline void		RotateToAz( cfloat__t a )		{ Transform.RotateToAz(a); }
	inline void		RotateToEl( cfloat__t a )		{ Transform.RotateToEl(a); }
	inline void		RotateToTw( cfloat__t a )		{ Transform.RotateToTw(a); }
	inline void		RotateByAz( cfloat__t a )		{ Transform.RotateByAz(a); }
	inline void		RotateByEl( cfloat__t a )		{ Transform.RotateByEl(a); }
	inline void		RotateByTw( cfloat__t a )		{ Transform.RotateByTw(a); }
	// Direction functions:
	inline void		SetDirection( const Vector &v )	{ Transform.SetDirection(v); }
//	void			LookAt( const CTEntity*);
	// Deformation methods:
	inline void		SetDeform( const Matrix& x)		{ Transform.SetDeformationMatrix(x); }
	inline void		ScaleTo( cfloat__t a )			{ Transform.ScaleTo(a); }
	inline void		ScaleBy( cfloat__t a )			{ Transform.ScaleBy(a); }
	inline void		ScaleTo( Vector const &a )		{ Transform.ScaleTo(a); }
	inline void		ScaleBy( Vector const &a )		{ Transform.ScaleBy(a); }
	/////////////////////////////////////////////////////////////////////////////
	// Transformation (un)locking (NOTE: these return the old lock status)
	flags_t			GetTransformLock() const		{ return Hints&EH_LOCK_MASK; }
	flags_t			SetTransformLock( flags_t newlock );
	
	bool			LockRotation();				// 'false' means 'was already locked'; NOP
	bool			LockPosition();
	bool			LockDeform();
	flags_t			LockTransform()					{ return SetTransformLock(EH_LOCK_MASK); }
	bool			UnlockRotation();			// 'false' means 'was not locked'; NOP
	bool			UnlockPosition();
	bool			UnlockDeform();
	flags_t			UnlockTransform()				{ return SetTransformLock(0); }
	/////////////////////////////////////////////////////////////////////////////
	// Vector transformation methods (overhead)
	Vector			TransformToWorld( Vector const & lp) { UpdateWorldSpace(); return GetWorldTransform().TransformPoint(lp); }
	Vector			TransformToLocal( Vector const & wp) { UpdateWorldSpace(); return GetWorldTransform().BackTransformPoint(wp); }
	Vector			RotateToWorld( Vector const & lv) { UpdateWorldSpace(); return GetWorldTransform().TransformNormal(lv); }
	Vector			RotateToLocal( Vector const & wv) { UpdateWorldSpace(); return GetWorldTransform().BackTransformNormal(wv); }
	/////////////////////////////////////////////////////////////////////////////
	// For networking, loading & saving (inherited)
	virtual void		WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool		ProcessChunk( CTStream* stream, chunkid_t chid );
	/////////////////////////////////////////////////////////////////////////////
	virtual size_t		GetSizeEstimate();
	virtual void		OnMessage( msgid_t, msgdata_t );
	/////////////////////////////////////////////////////////////////////////////
	int					PVSIndex ;		// used for identifying objects in a PVSet
//	PRenderState		RenderState;				// now in CTProcess
//	CTRenderState*		CreateRenderState();		// will create if not exists
	// Utility
	void				SetProcessPoint( bool ispp=true );
protected:
	// General entity hints	(EH_xxx)
	DFlags				Hints;
	// Defined as: that part of space that may be affected by this entity
	PShape				BoundingVolume[KINDCOUNT];
	// Checks for the presence of a bounding volume; creates one if necessary
	bool				_HasBoundingVolume( kind_t kind );
	CTGroup*			_Root;
	// Update the world-space of THIS entity only!
	// Assumes the parent has been updated
	bool				UpdateMyWorldSpace( const DTransform* Parent_Trans );
	// Destructor
	virtual ~CTEntity();
	// Inherited:
	virtual void		DoAddProperties();
	/////////////////////////////////////////////////////////////////////////////
private:
	int					TreeLevel;				// Level in tree
	CTGroup*			Parent;
	DTransform			Transform;
	DTransform*			WorldTransform;
	PEntityController		_Controller;
	SafePtr<CTMotionSensor> _MotionSensor;
	/////////////////////////////////////////////////////////////////////////////
	// Collision detection:
	PShape				CollisionVolume;
	collisionmask_t		CollisionMask;
};
/////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTEntity> PEntity;
/////////////////////////////////////////////////////////////////////////////
#define FINDRENDERPROPERTY( __state, __class ) \
	(__class*) (__state)->FindRenderProperty( CD(__class) )
/////////////////////////////////////////////////////////////////////////////
} // namespace citk
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !_ENTITY_H_INCLUDED
///////////////////////////////// [citk_Entity.h] END
///////////////////////////////// [citk_VertexData.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_VERTEXDATA_H_INCLUDED
#define CITK_VERTEXDATA_H_INCLUDED
 
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTVertexData);
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
struct bounds_t
{
	Vector		vMin, vMax;
	float__t	fRadius;
};
	
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTVertexData : public CTAggregated
{
	DECLARE_ALL( CTVertexData, CTAggregated );
public:
	enum geomtype_t
	{
		TRIFAN = -5,					// 012 023 034 ...
		TRISTRIP = -4,					// 012 123 234 ...
		TRISTRIPS = -3,					// #.......#.....[0triangles]
		LINE = -2,						// 0-----1-----2------3--
		PARTICLES = -1,					// render as sprites
		UNKNOWN = 0,					// not renderable
		POINTS = 1,						// 0 1 2 3 ...
		LINES = 2,						// 01 23 45 67 ...
		TRIANGLES = 3,					// 012 345 678 ...
		QUADS = 4,						// 0123 4567 ...
		CUSTOM_GEOM = 256				// hardware specific
	};
	
	// Geometry type (>0 means vertices/indices per primitive)
	geomtype_t	iGeomType;
	// Should we free the vertex data when we're done with it? (default: true)
	bool		bRemoveAll;
	// Data enumeration
	enum
	{
		INDICES,				// vtxid_t (unsigned short)			[iIndices]
		// The following are vertex based components				[iVertices]
		VECTORS,				// Vector3 (3 floats)
		NORMALS,				// Normal (3 floats)
		COLORS,					// DColorA (4 floats)
		BONEID,					// bone ID (1 byte)
		BLENDS,					// n floats
		CUSTOM,
		CUSTOM2,
		TEXTURE0 = 8,			// n floats						
		TEXTURE1,
		TEXTURE2,
		TEXTURE3,
		TEXTURE4,
		TEXTURE5,
		TEXTURE6,
		TEXTURE7,				// currently max 8 texture sets
		COUNT,
		ALL_MASK	= 0xFF
	};
	CTVertexData();
	CTVertexData( const CTVertexData* );
	~CTVertexData();					// public: allow creation on stack (!)
	CTVertexData*	Clone() const					{ return new CTVertexData(this); }
	// Type of vertex data (vertices per primitive)
	int			GetGeomType() const					{ return iGeomType; }
	void		SetGeomType( int i )				{ iGeomType = (geomtype_t)i; }
	int			GetPrimitiveCount() const;			// <0 is unknown
	// Data access
	int			GetIndexCount() const				{ return iIndices; }
	vtxid_t*	GetIndices() const					{ return (vtxid_t*)_get_ptr(INDICES); }
	int			GetVertexCount() const				{ return iVertices;}
	Vector*		GetVectors() const					{ return  (Vector*)_get_ptr(VECTORS); }
	Normal*		GetNormals() const					{ return  (Normal*)_get_ptr(NORMALS); }
	DColorA*	GetColors() const					{ return (DColorA*)_get_ptr(COLORS); }
	int			GetTextureSetCount() const			{ return COUNT - TEXTURE0; }
	float*		GetTextureSetNo( int ts ) const		{ return (float*)_GetPtr(TEXTURE0+ts); }
	int			GetTextureSetDim( int ts ) const	{ return iVertices?_GetSize(TEXTURE0+ts)/(iVertices*sizeof(float)):0; }
	vtxid_t*	DetachIndices()						{ iIndices=0; return (vtxid_t*)_Swap(INDICES,NULL); }
//	Vector*		DetachVectors()						{ return  (Vector*)_Detach(VECTORS); }
	Normal*		DetachNormals()						{ return  (Normal*)_Detach(NORMALS); }
	DColorA*	DetachColors()						{ return (DColorA*)_Detach(COLORS); }
	float*		DetachTextureSet( int ts )			{ return   (float*)_Detach(TEXTURE0+ts); }
	// Data creation
	vtxid_t*	CreateIndices( int count );
	void		SetVertexCount( int count );		// reallocates all the arrays
	Normal*		CreateNormals();
	DColorA*	CreateColors();
	float*		CreateTextureSet( int no, int dimension =2 );
	vtxid_t*	SwapIndices( vtxid_t *p )			{ return (vtxid_t*)_Swap( INDICES, p ); }
	Vector*		SwapVectors( Vector  *p )			{ return  (Vector*)_Swap( VECTORS, p ); }
	Normal*		SwapNormals( Normal  *p )			{ return  (Normal*)_Swap( NORMALS, p ); }
	DColorA*	SwapColors(  DColorA *p )			{ return (DColorA*)_Swap( COLORS,  p ); }
	float*		SwapTextureSet( int ts, float *p )	{ return   (float*)_Swap( TEXTURE0+ts, p ); }
	// Data removal
	void		RemoveAll();
	void		RemoveVertices();					// removes all but indices
	void		RemoveIndices();
	void		RemoveNormals();
	void		RemoveColors();
	void		RemoveTextureSet( int );
	void		RemoveTextureSets();
	// Bounding volume (not automatically updated)
	bounds_t*	GetBounds()	const					{ return pBounds; }
	void		InvalidateBounds()					{ delete pBounds; pBounds = NULL; }
	bounds_t*	CalculateBounds();
	// Unique shape ID (for hardware caching)
	id__t		GetID() const { if (shape_id==ID_NONE) shape_id=vertexdata_ids.RequestID(); return shape_id; }
	// Change detection (for hardware chaching)
	void		MarkAsChanged( int what )			{ flags |= (1<<what); }
	void		MarkAsChanged()						{ flags |= ALL_MASK; }
	int			GetChanges() const					{ return flags&ALL_MASK; }
	void		SetChanges()						{ shape_version++; flags &= ~ALL_MASK; }
	ulong		GetVersionID() const				{ return shape_version; }
	// Some helper methods to ease the access of vertices
	size_t		GetSizeOfVertex() const;
	flags_t		GetVertexFormat() const;			// bits represent components
	int			AddVertices( int count );			// returns first new vertex
	vtxid_t*	AddIndices( int count );			// returns first new index
	int			InsertVertices( int at, int count );
	void		CopyVertex( int to, int from, const CTVertexData *source =NULL );
	void		SetColors( const DColorA& );
	// Generic data access / creation
	void*		_Create( int what, int size_of1 );
	void*		_Swap( int what, void* );
	void*		_GetPtr( int what ) const			{ return _smaller(what,COUNT)?datas[what].ptr:NULL; }
	size_t		_GetSize( int what ) const			{ return _smaller(what,COUNT)?datas[what].size:0; }
	size_t		_GetSizeOf( int what ) const		{ return iVertices?_GetSize(what)/iVertices:0; }
	void*		_Detach( int what )					{ return what>VECTORS?_Swap(what,NULL):NULL; }
	void		_Remove( int what )					{ if (what>VECTORS) _set_size(what,0); }
	void		_CopyTo( int what, void* to, int stride =0 ) const;
	void		_CopyFrom( int what, const void* to, int stride =0 );
	// Inherited. Adds memory occupied by indices and vertices
	virtual size_t	GetSizeEstimate();
	// For networking, loading & saving (inherited)
	virtual void	WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool	ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	memoryblock_t	datas[COUNT];
	void*		_get_ptr( int i ) const { return datas[i].ptr; }
	size_t		_get_size( int i ) const { return datas[i].size; }
	void*		_set_size( int, size_t );
	int			iVertices, iIndices;
	bounds_t	*pBounds;
	flags_t		flags;
	ulong		shape_version; 
	mutable id__t	shape_id;
	static IDBroker	vertexdata_ids;
};
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTVertexData> PVertexData;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_VERTEXDATA_H_INCLUDED
///////////////////////////////// [citk_VertexData.h] END
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTGeometry );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CTLight;			// forward
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTGeometry : public CTEntity
{
	DECLARE_ALL( CTGeometry, CTEntity );
public:
	StrongArray<CTVertexData>	Datas;
	// Constructor (3 in 1)
	CTGeometry( cstr_t name =NULL, CTGroup* parent=NULL );
	// Copy constructor
	CTGeometry( const CTGeometry* );
	//! Mark this geometry as an occluder (renders it before all others)
	void				SetOccluder( bool =true );
	//! Add vertex data to this geometry; returns the index of this data
	int					Add( CTVertexData* );
	//! Apply lights to vertex data; uses current render state
	virtual bool		Illuminate( CTLight**, int lightcount );
	// Inherited:
	virtual CTEntity*	Copy() const;
	virtual CTShape*	UpdateBoundingVolume( kind_t kind =CTProcess::DRAW );
	virtual void		Process( ProcessInfo_t& );
	virtual bool		CheckWithRay( DTreePicker&, const Line3& );
	// For networking, loading & saving
	virtual void		WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool		ProcessChunk( CTStream* stream, chunkid_t chid );
};
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTGeometry> PGeometry;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_GEOMETRY_H_INCLUDED
///////////////////////////////// [citk_Geometry.h] END
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTMultiMtlGeometry );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTMultiMtlGeometry : public CTGeometry
{
	DECLARE_ALL( CTMultiMtlGeometry, CTGeometry );
public:
	StrongArray<CTRenderState>	States;
	// Constructor (3 in 1)
	CTMultiMtlGeometry( cstr_t name =NULL, CTGroup* parent =NULL );
	// Copy constructor
	CTMultiMtlGeometry( const CTMultiMtlGeometry* );
	//! Add vertex data with specific render state to this geometry
	//! Returns the index of this data/state
	int					Add( CTVertexData*, CTRenderState* );
	//! Apply lights to vertex data; uses current render state
	virtual bool		Illuminate( CTLight**, int lightcount );
	// Inherited:
	virtual CTEntity*	Copy() const;
	virtual void		Process( ProcessInfo_t& );
	// For networking, loading & saving
	virtual void		WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool		ProcessChunk( CTStream* stream, chunkid_t chid );
};
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTMultiMtlGeometry> PMultiMtlGeometry;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_MULTIMTLGEOMETRY_H_INCLUDED
///////////////////////////////// [citk_MultiMtlGeometry.h] END
///////////////////////////////// [citk_MaterialProperty.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_MATERIALPROPERTY_H_INCLUDED
#define CITK_MATERIALPROPERTY_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTMaterialProperty);
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTMaterialProperty : public CTRenderProperty
{
	DECLARE_ALL( CTMaterialProperty, CTRenderProperty );
public:
	CTMaterialProperty();
	CTMaterialProperty( const CTMaterialProperty* );
	DColor		Emissive;
	DColor		Ambient;
	DColor		Diffuse;
	DColor		Specular;
	float		Alpha;
	float		Power;
	bool		UseAmbient;
	bool		UseDiffuse;
	bool		UseSpecular;
	bool		UseEmissive;
	bool		UseAlpha;
	void		SetAlpha( cfloat__t alpha );
	void		SetAmbient( const DColor &col );
	void		SetDiffuse( const DColor &col );
	void		SetSpecular( const DColor &col );
	void		SetEmissive( const DColor &col );
	// Will set both Ambient and Diffuse
	void		SetColor( const DColor &col );
	// Inherited from CTRenderProperty:
	virtual CTRenderProperty* Clone() const;
	virtual bool	_Combine( const CTRenderProperty* );
	virtual bool	_Compare( const CTRenderProperty* ) const;
	// For networking, loading & saving (inherited from CTStreamed)
	virtual void	WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool	ProcessChunk( CTStream* stream, chunkid_t chid );
};
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTMaterialProperty> PMaterialProperty;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_MATERIALPROPERTY_H_INCLUDED
///////////////////////////////// [citk_MaterialProperty.h] END
///////////////////////////////// [citk_RenderFlagsProperty.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_RENDERFLAGSPROPERTY_H_INCLUDED
#define CITK_RENDERFLAGSPROPERTY_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTRenderFlagsProperty);
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTRenderFlagsProperty : public CTRenderProperty
{
	DECLARE_ALL( CTRenderFlagsProperty, CTRenderProperty );
public:
	CTRenderFlagsProperty();
	CTRenderFlagsProperty( const CTRenderFlagsProperty* );
	enum renderflag_t
	{
		DOUBLE_SIDED,		// no culling
		ANTI_ALIAS,			// draw with anti-aliased edges
		NO_FOG,				// no fogging
		NO_DEPTH_TEST,		// no testing against depth buffer
		NO_DEPTH_UPDATE,	// no writing to depth buffer
		NO_SORT,			// no (alpha) sorting
		WIREFRAME,			// only draw edges
		POINTS,				// only draw vertices
		FLAT_SHADED,		// no interpolation across vertices
		NO_CACHE,			// no hardware caching
		VIEWPORT_SPACE,		// -1..1 space, no projection
		PIXEL_SPACE,		// 0..640 space, no projection
		FLARE,				// perform pivot visibility test
		OCCLUDER,			// render the object as occluder (first)
		OCCLUSION_TEST,		// test the object against occluders
		DEPTH_SORT_TRIS,	// sort the triangles back to front (SLOW)
		DEPTH_BIAS,			// pretend the triangles are closer by (offset)
		FLAG_COUNT			// must be last
	};
	void		SetFlags( flags_t );
	void		SetFlagTo( renderflag_t, bool );
	void		SetFlag( renderflag_t );
	void		ClearFlag( renderflag_t );
	bool		GetFlag( renderflag_t r ) const { return (Flags>>r)&1; }
	flags_t		GetFlags() const { return Flags; }
	void		SetMasks( flags_t );
	void		SetMaskTo( renderflag_t, bool );
	void		SetMask( renderflag_t );
	void		ClearMask( renderflag_t );
	bool		GetMask( renderflag_t r ) const { return (Mask>>r)&1; }
	flags_t		GetMasks() const { return Mask; }
	// Inherited from CTRenderProperty:
	virtual CTRenderProperty* Clone() const;
	virtual bool	_Combine( const CTRenderProperty* );
	virtual bool	_Compare( const CTRenderProperty* ) const;
	// For networking, loading & saving (inherited from CTStreamed)
	virtual void	WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool	ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	flags_t		Flags;
	flags_t		Mask;
};
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTRenderFlagsProperty> PRenderFlagsProperty;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_RENDERFLAGSPROPERTY_H_INCLUDED
///////////////////////////////// [citk_RenderFlagsProperty.h] END
///////////////////////////////// [citk_TextureProperty.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_TEXTUREPROPERTY_H_INCLUDED
#define CITK_TEXTUREPROPERTY_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_Texture.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_TEXTURE_H_INCLUDED
#define CITK_TEXTURE_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_Cached.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#ifndef CITK_CACHED_H_INCLUDED
#define CITK_CACHED_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTCached );
///////////////////////////////////////////////////////////////////////////////
namespace citk {
/////////////////////////////////////////////////////////////////////////////
class CITK_API CTCached : public CTNamed
{
	DECLARE_ALL( CTCached, CTNamed );
public:
	// Constructor
	CTCached( cstr_t =NULL );
	/////////////////////////////////////
	// Cache control (for cache manager):
	// Remove the data from memory
	bool			Flush();
	// Returns the number of frames that passed since this object
	// was last used.
	ulong			GetIdle() const;
	/////////////////////////////////////
	// Access control:
	// Increase the lock count and prepare the object for use
	bool			Lock();
	// Increase the lock count if it's already prepared for use
	bool			TryLock();
	// Decrease the lock count
	void			Unlock();
	// Call this to notify this object that it's contents have been changed
	virtual void	Invalidate();
protected:
	// Whether swapping to the temp folder is allowed (default is true)
	bool			_UseSwapping;
	// Destructor (removes swapfile, if any)
	virtual ~CTCached();
	// Prepare the object for use
	bool			_CacheData();
	// Initialize the object as empty; don't forget to unlock!
	bool			_CreateData();
	// Empties the object (remove any data)
	bool			_RemoveData();
	// Set the object as used
	void			_SetUsed();
	// Recreate object in memory
	virtual	bool	DoCache() { return false; }
	// Remove all the allocated memory
	virtual	void	DoFlush() {}	
	// Inherited:
	virtual void	DoAddProperties();
	
private:
	int				Locked;						// object will not be removed
	bool			Cached;						// object resides in memory
	ulong			FrameID_Used;
	/////////////////////////////////////
	// File/disk swapping:
	bool			Swapped;					// swapfile in use
	DynString		TempPath;					// full path to swapfile
	// Swap cacheable data from disk
	bool			SwapFromFile();
	// Swap cacheable data to disk
	bool			SwapToFile();
	// Remove the swapfile
	void			RemoveSwapFile();
};
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
/////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_CACHED_H_INCLUDED
///////////////////////////////// [citk_Cached.h] END
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTTexture );
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citk {
	
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class CITK_API CTTexture : public CTCached
{
	DECLARE_ALL( CTTexture, CTCached );
public:
	enum tex_mode_t { tmWrap, tmClamp, tmMirror, tmBorder, tmSameAsU };
	enum alpha_mode_t { amNone, amChromakey, amAlpha, amIntensity };
	tex_mode_t	Mode_u, Mode_v;
	bool		Filtered;
	int			MipMaps;
	alpha_mode_t	AlphaMode;
	// ACG value for this texture
	int			AlphaQuality;			// number of bits
	int			ColorQuality;			// number of bits
	bool		Grayscale;
	float		AspectRatio;
	// Constructor
	CTTexture( cstr_t =NULL );
	// Methods, obviously:
	bool			HasAlpha() const { return AlphaQuality>0; }
	bool			IsValid() const { return (Data!=NULL); }
	cstr_t			GetFilename() const { return FileName; }
	void			SetFilename( cstr_t );
	
	void			SetUVMode( tex_mode_t u, tex_mode_t v =tmSameAsU );
	void			SetAlphaMode( alpha_mode_t u );
	void			SetACG( int, int, bool grey =false );
	// Inheritables
	virtual bool		Load( cstr_t filename );
	virtual DBitmap*	GetData();
	virtual bool		RemoveData();					// in CTCached?
	// Get/acquire a unique ID for this texture
	id__t			GetID() const { return TexID; }
	id__t			RequestID();
	// Only for static bitmap texture
	bool			SetData(DBitmap* lfb);
	DBitmap*		DetachData();
	// Inherited:
	virtual size_t	GetSizeEstimate();
	virtual void	OnPropertyChanged( DProperty& );
	// Streaming:
	virtual void	WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool	ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	// Called by CTCached::Cache if the data is needed (and not yet available)
	virtual	bool	DoCache();
	// Called by CTCached::Flush if the data should be remove from memory
	virtual	void	DoFlush();
	DBitmap*		Data;
	virtual			~CTTexture ();
	virtual bool	DoRegisterWithService();
	virtual bool	DoUnregisterWithService();
	virtual void	DoAddProperties();
	bool			_SetData(DBitmap* lfb, bool updateacg);
//private:
	String			FileName;
	enum { dsUnknown, dsLoaded, dsNoFile, dsFailed } DataState;
	id__t			TexID;
	static IDBroker texture_ids;
};
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTTexture> PTexture;
/////////////////////////////////////////////////////////////////////////////
} // namespace citk
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITK_TEXTURE_H_INCLUDED
///////////////////////////////// [citk_Texture.h] END
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTTextureProperty );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTTextureProperty : public CTRenderProperty
{
	DECLARE_ALL( CTTextureProperty, CTRenderProperty );
public:
	// Texture maps
	enum texmap_t {
		BaseMap,			// modulate
		DarkMap,			// modulate
		DetailMap,			// modulate x2
		GlossMap,			// specular map
		GlowMap,			// add
		BumpMap,			// dot3
		DecalMap,			// blend with alpha
		DecalMap2,
		DecalMap3,
		DecalMap4			// and so on, and so forth...
	};
	// Texture blending arguments (Color.argX, Alpha.argX)
	enum texarg_t { Prev=0, Color, Texture, Factor, Specular, Inv=8, Alpha=16 };
	// Texture blending operation (Color.oper, Alpha.oper)
	enum texoper_t { 
		Replace,				// arg0
		Modulate,				// arg0 * arg1
		Add, 					// arg0 + arg1
		AddSigned, 				// arg0 + arg1 - 0.5
		Subtract, 				// arg0 - arg1
		Dot3,					// arg0 ^ arg1
		MultiplyAdd,			// arg0 + arg1 * arg2
		Interpolate,			// arg0 * arg2 + arg1 * (1-arg2)
		Custom,
		Scale2=16, Scale4=32 };
	// Texture blending opcode (Color, Alpha)
	union texblend_t {
		ulong		opcode;
		struct /*no name*/ {
#ifndef _BIG_ENDIAN
			ulong	arg0:3, inv0:1, alpha0:1, signed0:1, reserved0:2,
					arg1:3, inv1:1, alpha1:1, signed1:1, reserved1:2,
					arg2:3, inv2:1, alpha2:1, signed2:1, reserved2:2,
					oper:4, scale:2;
#else
			// mirror bit-fields for big endian machines
			ulong	__fill32:2, scale:2, oper:4, 
					reserved2:2, signed2:1, alpha2:1, inv2:1, arg2:3, 
					reserved1:2, signed1:1, alpha1:1, inv1:1, arg1:3, 
					reserved0:2, signed0:1, alpha0:1, inv0:1, arg0:3;
#endif // !_BIG_ENDIAN
		};
		texblend_t() : opcode(0) {}
		texblend_t( ulong op ) : opcode(op) {}
	};
	// Texture coordinate source (Coord)
	enum texcoord_t { 
		// 0..8 = texture coordinate from vertex data
		StanMap=16, CamDir, Reflect, CubeMap,		// auto generated uvw
		VtxCol, ObjectXY, ObjectYZ, ObjectXZ, ObjectXYZ,
		WorldXY, WorldYZ, WorldXZ, WorldXYZ };
	// Texture coordinate clamping/wrapping (U, V, W)
	enum tex_uvw_t { Wrap=0, Clamp, Mirror, Border };
	// Texture stage structure
	struct TexStage_t
	{
		PTexture	Texture;
		union {
			flags_t		Flags;
			struct /*no name*/ {
#ifndef _BIG_ENDIAN
				flags_t	Coord:8, U:4, V:4, W:4,	_R:4,
						MipMap:1, Filter:1, Transform:1;
#else
				// mirror bit-fields for big endian machines
				flags_t	__fill32:5,
						Transform:1, Filter:1, MipMap:1,
						_R:4, W:4, V:4, U:4, Coord:8;
#endif // !_BIG_ENDIAN
			};
		};
		texblend_t	Color, Alpha;
		Matrix33	UVMatrix;
		Vector3		UVOffset;
		// Default constructor
		TexStage_t() : Flags(0) { MipMap=Filter=1; }
		void		SetTransform( const DTransform& );
		bool		GetTransform( DTransform& );
	};
	// Texture blending factor
	DColorA			BlendFactor;
	// Default constructor
	CTTextureProperty();
	// Copy constructor
	CTTextureProperty( const CTTextureProperty* );
	// Destructor
	~CTTextureProperty();
	// Texture maps
	TexStage_t*		SetMap( texmap_t, CTTexture* );
	TexStage_t*		GetMap( texmap_t tm ) const { return Textures.GetNo((int)tm); }
	flags_t			GetMapMask() const;
	int				GetMapCount() const;
	// Texture stage creation (deprecated)
	TexStage_t*		CreateTextureStage();
	int				AddTextureStage( TexStage_t* );
	bool			RemoveTextureStage( int );
	// Texture stage iteration (deprecated)
	int				GetTextureStageCount() const;
	TexStage_t*		GetTextureStageNo( int i ) const;
	// Inherited from CTRenderProperty:
	virtual CTRenderProperty* Clone() const;
	virtual bool	_Combine( const CTRenderProperty* );
	virtual bool	_Compare( const CTRenderProperty* ) const;
	// For networking, loading & saving (inherited from CTStreamed)
	virtual void	WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool	ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	ArrayPtr<TexStage_t>	Textures;		// may contain NULLs
};
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTTextureProperty> PTextureProperty;
///////////////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_TEXTUREPROPERTY_H_INCLUDED
///////////////////////////////// [citk_TextureProperty.h] END
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CT3DText);
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
class CITK_API CT3DText : public CTMultiMtlGeometry
{
	DECLARE_ALL( CT3DText, CTMultiMtlGeometry );
public:
	// Default constructor
	CT3DText();
	// Copy Constructor
	CT3DText( const CT3DText* );
	// Font methods
	bool			Load( cstr_t, bool proportional =true );
	bool			LoadFrom( const CT3DText* );
	void			Free();
	cstr_t			GetTextureName() const;
	CTTexture*		GetTexture() const;
	void			SetText(cstr_t);			//	Supports \n \r \t \b
	void			SetTabStop( cfloat__t );
	// Coordinate space selection
	void			UseLocalSpace();
	void			UsePixelSpace();
	void			UseViewportSpace();
	// Alignment
	void			VerAlignTop();
	void			VerAlignCenter();
	void			VerAlignBottom();
	void			HorAlignLeft();
	void			HorAlignCenter();
	void			HorAlignRight();
	void			HorAlignTotalRight(); // Not per-line!
	// Font properties
	void			SetFontSize( cfloat__t hor, cfloat__t ver );//	In chosen units
	void			SetFontSize( cfloat__t sz );	//	In chosen units
	void			UseProportional();
	void			UseFixedWidth();
	bool			IsProportional() const;
	void			SetHorSpacing( cfloat__t );		//	Relative to size
	void			SetVerSpacing( cfloat__t );		//	Relative to size
	void			SetFixedVerSpacing( cfloat__t );	//	Fixed height per line
	
	void			BasePointMoveTo( cvec_t );		//	In the selected space
	void			BasePointMoveBy( cvec_t );		//	In the selected space
	void			SetAlpha( cfloat__t );
	void			SetColor( const DColor& );
	void			SetDoubleSided( bool =true );
	// Background properties
	void			SetBackgroundProperties( const DColor& = COL_BLACK, cfloat__t alpha=0.2f, cfloat__t margin=0.0f, bool per_line = false );
	void			SetBackgroundMargin( cfloat__t );
	void			SetBackgroundColor( const DColor& );
	void			SetBackgroundAlpha( cfloat__t );
	void			SetBackgroundTexture( CTTexture* );
	void			DisableBackground();
	// Inherited:
					
	virtual	void	Process( ProcessInfo_t& );
	virtual CTEntity* Copy() const;
	PRenderState	BackgroundRS;
	PRenderState	TextRS;
protected:
	DColorA				TextColor, BackColor;
	struct letter_t;
	letter_t*			Letters[256];
	PTexture			FontTexture;
	PVertexData			back_vd;
//	PRenderState		back_state;
//	PMaterialProperty	back_mat;
	PTextureProperty	back_tex;
	PVertexData			text_vd;
//	PRenderState		text_state;
//	PMaterialProperty	text_mat;
	PTextureProperty	text_tex;
	PRenderFlagsProperty rp;
	Vector			Pivot, _dpos;
	float__t		TabStop;
	float__t		BGMargin;
	bool			Proportional ;
	int				HorAlign, VerAlign;
	float			cur_width, cur_height, cur_horspace, cur_verspace;
	bool			ver_spacing_fixed, draw_background, background_per_line;
	String			Text;
	bool			Invalid, moveby;
	virtual ~CT3DText();
	void			_Construct();
	void			CreateRenderShape();
	void			CreateFont( CTTexture * );
	int				vertices_used;
	int				addvertex(const Vector&, CTVertexData*);
	void			setindex(const int&, const vtxid_t&, CTVertexData*);
};
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CT3DText> P3DText;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_3DTEXT_H_INCLUDED
///////////////////////////////// [citk_3DText.h] END
///////////////////////////////// [citk_AnimatedGeomController.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_ANIMATEDGEOMCONTROLLER_H_INCLUDED
#define CITK_ANIMATEDGEOMCONTROLLER_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_TimedEntityController.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_TIMEDENTITYCONTROLLER_H_INCLUDED
#define CITK_TIMEDENTITYCONTROLLER_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_Track.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_TRACK_H_INCLUDED
#define CITK_TRACK_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTTrack );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
enum outofrange_t 
{ 
	ortConstant,			// aaaaaaabcdefffffff
	ortCycle,				// abcdefabcdefabcdef
	ortLoop,				// abcdefabcdefabcdef [with continuity]
	ortPingPong,			// efedcbabcdefedcbab
	ortLinear,				// 567890abcdefghijkl [extrapolates last kf]
	ortRepeat,				// 567890abcdefghijkl [relative repeat]
	ortIdentity				// ......abcdef......
};
typedef DRange<ctime_t> timerange_t;
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTTrack : public CTStreamed
{
	DECLARE_ALL( CTTrack, CTStreamed );
public:
	struct keyframe_t 
	{
		ctime_t		time;
		// Inherit custom keys from this one and add your data
	};
	// Constructor:
	CTTrack();
	// Out of range methods:
	void			SetOutOfRange( outofrange_t a ) { After = Before = a; }
	void			SetOutOfRangeBefore( outofrange_t a ) { Before = a; }
	void			SetOutOfRangeAfter( outofrange_t a ) { After = a; }
	outofrange_t	GetOutOfRangeBefore() const { return Before; }
	outofrange_t	GetOutOfRangeAfter() const { return After; }
	// Time range methods:
	const timerange_t &GetTimeRange() const { return TimeRange; }
	const ctime_t	GetStartTime() const { return TimeRange.GetBegin(); }
	const ctime_t	GetEndTime() const { return TimeRange.GetEnd(); }
	void			SetStartTime( ctime_t start );
	void			SetEndTime( ctime_t end );
	// Key methods:
	int				GetKeyCount() const;
	ctime_t			GetKeyTime( int ) const;
	bool			SetKeyTime( int, ctime_t );
	void			DeleteAllKeys();
	void			DeleteKey( int );
	virtual int		CreateKeyAt( ctime_t );
	bool			DeleteKeyAt( ctime_t );
	void			DeleteKeysBefore( ctime_t );
	void			DeleteKeysAfter( ctime_t );
	//! Find a key with exactly the specified time; returns -1 if not found
	int				FindKeyAt( ctime_t ) const;
	//! Method to get the actual key with the interpolate factor
	bool			FindKeyTime( ctime_t, int& key, float__t& ) const;
	//! Precalculate extra key info (must call inherited!)
	virtual void	Precalc();
	//! Compare the keys from two tracks (this one checks the times)
	virtual bool	Compare( const CTTrack* ) const;
	// For streaming / networking:
	virtual void	WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool	ProcessChunk( CTStream* stream, chunkid_t chid );
				
	virtual size_t	GetSizeEstimate();
protected:
	// Destructor
	virtual ~CTTrack();
	//! Create a new key (inherit this one and 'new' your own key)
	virtual keyframe_t*	NewKey( keyframe_t* old =NULL ) = 0;
	// Key methods:
	inline keyframe_t*	GetKeyNo( int t ) const { return Keys.GetNo(t); }
	// Find the latest key with time <= argument
	int				FindKey( ctime_t ) const;
	int				FindKeyFast( ctime_t, int last ) const;
	//! Set a key at a certain time (will create keys if necessary)
	keyframe_t*		SetKey( ctime_t );
	//! Get a key at a certain time; returns NULL if there's no key.
	keyframe_t*		GetKey( ctime_t ) const;
	//! Time mapping: map an absolute time to relative (to this track)
	ctime_t			GetLocalTime( ctime_t ) const;
	//! Batch creation of keys (used during streaming)
	keyframe_t**	NewKeys( int count );
private:
	ArrayPtr<keyframe_t>	Keys;
	outofrange_t		Before, After;
	timerange_t			TimeRange;
	int				_FindKey( ctime_t, int, int ) const;
	void			_DeleteKeys( int, int count=1 );
};
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTTrack> PTrack;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_TRACK_H_INCLUDED
///////////////////////////////// [citk_Track.h] END
///////////////////////////////// [citk_TextTrack.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_TEXTTRACK_H_INCLUDED
#define CITK_TEXTTRACK_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTTextTrack );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
	
/////////////////////////////////////////////////////////////////////////////
class CITK_API CTTextTrack : public CTTrack
{
	DECLARE_ALL( CTTextTrack, CTTrack );
public:
	// Track methods:
	cstr_t		GetText( ctime_t ) const;			// NULL: no key
	cstr_t		GetTextFast( ctime_t, int &cache ) const;
	void		SetText( ctime_t, cstr_t );
	// Key methods:
	cstr_t		GetKeyText( int ) const;			// NULL: no key
//	virtual int	CreateKeyAt( ctime_t );
	// Inherited from CTTrack
	virtual bool		Compare( const CTTrack* tr ) const;
	// For streaming / networking:
	virtual void	WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool	ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	virtual keyframe_t*	NewKey( keyframe_t* );
};
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTTextTrack> PTextTrack;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
	
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_TEXTTRACK_H_INCLUDED
///////////////////////////////// [citk_TextTrack.h] END
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTTimedEntityController );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTTimedEntityController : public CTEntityController
{
	DECLARE_ALL( CTTimedEntityController, CTEntityController );
public:
	CTTimedEntityController();
	CTTimedEntityController( const CTTimedEntityController* );
	CTTextTrack*	GetTextTrack() const { return Text; }
	void			SetTextTrack( CTTextTrack* );
	void			SetReversed( bool =true );
	bool			GetReversed() const { return speed<0.0f; }
	void			SetTime( ctime_t );			// calls _UpdateEntity
	ctime_t			GetTime() const { return __ftoi(time); }
	void			SetOutOfRange( outofrange_t );
	void			SetOutOfRangeBefore( outofrange_t );
	void			SetOutOfRangeAfter( outofrange_t );
	void			SetStartTime( ctime_t start );
	void			SetEndTime( ctime_t end );
	ctime_t			GetStartTime() const;
	ctime_t			GetEndTime() const;
	void			SetSpeed( cfloat__t factor );
	cfloat__t		GetSpeed() const;
	//! Reset the controller to its initial state (call inherited)
	virtual void	Reset();
	// For streaming / networking:
	virtual void	WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool	ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	//! Optional text-track containing script commands or whatever
	PTextTrack		Text;
	float__t		speed;
	float__t		time; // float for more accurate 'speed' multiplying
	outofrange_t	Before, After;
	timerange_t		TimeRange;
	//! This time is returned by _GetLocalTime to signal the end
	static const ctime_t	TIME_STOP;
	ctime_t			_GetLocalTime( ctime_t time ) const;
	bool			_ApplyAfter( ctime_t& );
	bool			_ApplyBefore( ctime_t& );
	//! Use this update method to update the time (calls _UpdateEntity)
	UPDATEFUNC		UpdateFrame( ctime_t );
	//! Inherited this method and update the entity's transformation
	virtual	void	_UpdateEntity( ctime_t ) = 0;
	virtual void	DoAddProperties();
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTTimedEntityController> PTimedEntityController ;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_TIMEDENTITYCONTROLLER_H_INCLUDED
///////////////////////////////// [citk_TimedEntityController.h] END
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTAnimatedGeomController );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTAnimatedGeomController : public CTTimedEntityController
{
	DECLARE_ALL( CTAnimatedGeomController, CTTimedEntityController );
public:
	CTAnimatedGeomController();
	CTAnimatedGeomController( const CTAnimatedGeomController* );
	// Inherited from CTEntityController:
	virtual CTEntityController*	Copy() const;
private:
	virtual bool	DoEnable();
	virtual void	DoDisable();
	//! Inherited from CTTimedEntityController, updates animgeom's time
	virtual	void	_UpdateEntity( ctime_t );
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTAnimatedGeomController> PAnimatedGeomController ;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_ANIMATEDGEOMCONTROLLER_H_INCLUDED
///////////////////////////////// [citk_AnimatedGeomController.h] END
///////////////////////////////// [citk_AnimatedGeometry.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_ANIMATEDGEOMETRY_H_INCLUDED
#define CITK_ANIMATEDGEOMETRY_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTAnimatedGeometry );
/////////////////////////////////////////////////////////////////////////////
namespace citk {
	
/////////////////////////////////////////////////////////////////////////////
class CITK_API CTAnimatedGeometry : public CTGeometry
{
	DECLARE_ALL( CTAnimatedGeometry, CTGeometry );
public:
	bool			Loop;
	float__t		FPS;
	//! Current interpolated vertex data
	PVertexData		Current;
	CTAnimatedGeometry();
	CTAnimatedGeometry( const CTAnimatedGeometry* );
	void		SetReversed(bool r =true) { if (r!=GetReversed()) FPS=-FPS; }
	bool		GetReversed() const { return FPS<0.0; }
	void		SetFPS( cfloat__t fps ) { FPS=fps; }
	cfloat__t	GetFPS() const { return FPS; }
	void		SetDuration(ctime_t t) { FPS=Datas.Count()/TIME(t); };
	ctime_t		GetDuration() const { return __ftoi((Datas.Count()/FPS) SECONDS); };
	void		SetTime(ctime_t t) { SetFrame( FPS * TIME(t) ); };
	ctime_t		GetTime() const { return __ftoi((frame/FPS) SECONDS); };
	void		SetFrame( cfloat__t t ) { frame=t; invalid=true; }
	cfloat__t	GetFrame() const { return frame; }
	void		Start();
	void		Stop();
	bool		IsRunning() const { return running; }
	//! Updates the 'Current' vertex data to match current 'frame'
	bool		UpdateVertexData();
	//! Checks whether the vertex datas are suitable for interpolation
	bool		Prepare();
	// Inherited:
	virtual CTEntity*	Copy() const;
	virtual void		Process(ProcessInfo_t& processinfo);
	virtual bool		CheckWithRay( DTreePicker&, const Line3& );
	virtual void		WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool		ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	virtual	void		OnPropertyChanged( DProperty& );
private:
	bool		running;
	bool		invalid;
	float__t	frame;
	
	UPDATEFUNC	_Update(ctime_t dt);
	// Inherited:
	virtual void DoAddProperties();
};
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTAnimatedGeometry> PAnimatedGeometry;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_ANIMATEDGEOMETRY_H_INCLUDED
///////////////////////////////// [citk_AnimatedGeometry.h] END
///////////////////////////////// [citk_BillBoardGroup.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_BILLBOARDGROUP_H_INCLUDED
#define CITK_BILLBOARDGROUP_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_Group.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_GROUP_H_INCLUDED
#define CITK_GROUP_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTGroup);
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citk {
/////////////////////////////////////////////////////////////////////////////
class CITK_API CTGroup: public CTEntity
{
	DECLARE_ALL(CTGroup, CTEntity);
public:
	// Constructor (3 in 1)
	CTGroup ( cstr_t name =NULL, CTGroup* parent =NULL );
	// Copy Constructor
	CTGroup ( const CTGroup * copy_this_one );
	//! Copy Constructor that does not copy children
	explicit CTGroup ( const CTEntity *copy_this_one );
	/////////////////////////////////////////////////////////////////////////////
	// Attach a child to this group
	void				AddChild ( CTEntity* child);
	// Detach a child from this group (internal; use child->SetParent)
	void				RemoveChild ( CTEntity* child);
	// Updates KINDS of (grand)children (internal)
	void				IncreaseKindCount ( flags_t ); 
	void				DecreaseKindCount ( flags_t ); 
	// Delete all the children
	void				DeleteChildren();
	// Move the children from one group to the other
	void				AddChildren( CTGroup* from );
	// Swap two children in the children list (use for sorting)
	void				SwapChildren(int,int);
	// Returns the number of children
	int					GetChildCount() const { return ChildrenList.Count(); }
	// Returns child number 'n' or NULL
	CTEntity*			GetChildNo( int n ) const { return ChildrenList.GetNo(n); }
	// Adds parentless entities from the file to ChildrenList
	bool				LoadTree( cstr_t filename );
	bool				SaveTree( cstr_t filename, streamlod_t =STREAMLOD_DEFAULT);
	/////////////////////////////////////////////////////////////////////////////
	// Inherited methods:
	virtual void		UpdateRoot();	// Called by SetParent and itself (propag.)
	// Inherited: Updates the worldspace of an entire tree (not to the root, but to the leafs)
	virtual void		UpdateTreeWorldSpace ();
	// Inherited: Process children according to 'processflags'
	virtual void		Process( ProcessInfo_t& );
	// Inherited: Check each child
	virtual bool		CheckWithRay( DTreePicker&, const Line3& );
	// Inherited: Copy this group
	virtual CTEntity*	Copy() const;
	// Creates the most efficient bounding volume
	virtual CTShape*	UpdateBoundingVolume( kind_t kind );
	// Make sure that the bounding volume of the entity fits in our BV
	void				UpdateBoundingVolume( CTEntity*, cfloat__t margin =0.0f );
	// Find a child by pointer
	virtual CTEntity*	FindChild( CTEntity * const );
	// Find a child by name (SLOW)
	virtual CTEntity*	FindChildByName( cstr_t name );
	virtual CTEntity*	FindChildByNameIC( cstr_t name );
	
	// Inherited: Search all the parents for a given group
	virtual CTGroup*	FindParent( CTGroup* const );
	// Inherited: Search all the parents for a given group-name
	virtual CTGroup*	FindParentByName( cstr_t name );
	// Inherited. Add size of children list
	virtual size_t		GetSizeEstimate();
	// For networking, loading & saving
	virtual void		WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool		ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	//! Process children according to 'processflags'
	void				_ProcessChildren( ProcessInfo_t& );
	//! Get the childs AABB in our local space (last param forces BV creation)
	bool				_GetLocalAABB( CTEntity*, kind_t, Vector&, Vector&, bool force );
	virtual ~CTGroup();
private:
	ArrayPtr<CTEntity>	ChildrenList;		// StrongArray
	//! Counts the number of children for each KIND
	int					KindCount[CTProcess::KINDCOUNT];
	//! Make sure that the bounding volume of 'entity' fits in our BV
	bool		_UpdateBoundingVolume( CTEntity*, kind_t kind, cfloat__t margin );
};
/////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTGroup> PGroup;
/////////////////////////////////////////////////////////////////////////////
} // namespace citk
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITK_GROUP_H_INCLUDED
///////////////////////////////// [citk_Group.h] END
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC (CTBillBoardGroup);
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citk {
/////////////////////////////////////////////////////////////////////////////
class CITK_API CTBillBoardGroup : public CTGroup
{
	DECLARE_ALL( CTBillBoardGroup, CTGroup );
public:
    // Bill board mode selection
    enum billboard_t
    {
		FIXED,
        ALWAYS_FACE_CAMERA,
        ROTATE_ABOUT_UP,
        RIGID_FACE_CAMERA,
		LOOK_AT_CAMERA
    };
	// Constructor (3 in 1)
	CTBillBoardGroup( cstr_t name =NULL, CTGroup* parent =NULL );
	// Copy constructor
	CTBillBoardGroup( const CTBillBoardGroup* );
	// Bill-boarding:
	void				SetBillBoardType( billboard_t Type );
	billboard_t			GetBillBoardType() const { return BillBoard; }
	// Inherited: updates transformation
	virtual void		Process( ProcessInfo_t& );
	// Make a copy of this drawable
	virtual CTEntity*	Copy() const;
	// Creates a BV; sphere when bill boarding
	virtual CTShape*	UpdateBoundingVolume( kind_t kind =CTProcess::DRAW );
	// For networking, loading & saving
	virtual void		WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool		ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	billboard_t			BillBoard;
	DTransform			BBTransform;
	void				UpdateBillBoard( RenderInfo_t& );
	virtual void		DoAddProperties();
};
/////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTBillBoardGroup> PBillBoardGroup;
/////////////////////////////////////////////////////////////////////////////
} // namespace citk
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITK_BILLBOARDGROUP_H_INCLUDED
///////////////////////////////// [citk_BillBoardGroup.h] END
///////////////////////////////// [citk_Box.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef _BOX_H_INCLUDED
#define _BOX_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTBox );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTBox : public CTShape
{
	DECLARE_ALL( CTBox, CTShape );
public:
	// Constructors:
	CTBox( cfloat__t size = 1 METER );		// size ( 3x same)
	CTBox( cvec_t dim );					// dimensions
 	CTBox( const CTSphere* );				// conversion
	// Copy constructors:
	CTBox( const CTBox* );					// copy-ctor
	// Destructor (deletes world_box)
	~CTBox() { delete world_box; }
	// Box specific methods
	void				SetDimensions( cfloat__t );
	void				SetDimensions( cvec_t );
	const Vector&		GetDimensions( ) const { return dimensions; }
	const Vector&		GetHalfDimensions( ) const { return halfdim; }
	void				SetHollow( bool h =true );
	inline bool			IsHollow() const { return _Flags.TestBit(HOLLOW); }
	void				FromVectors( const Vector*, int count );
	// General:
	virtual double		CalcVolume();
	virtual double		CalcArea();
	virtual	CTShape*	Copy() const;
	// Collision detection helpers:
	virtual Normal		GetNormal( cvec_t );
	virtual Vector		GetSupport( cvec_t );
	virtual double		GetMaxY( cvec_t );
	virtual Vector		GetClosestPoint( cvec_t );
	virtual bool		IsConvex() const { return true; }
	virtual CTSphere*	GetBoundingSphere();
	virtual CTBox*		GetBoundingBox();
	virtual CTShape*	GetBoundingVolume();
	// Rendering:
	virtual void		Render( const RenderInfo_t & );
	// Dinges
	virtual intersect_t	CheckWithPoint( cvec_t, const DTransform* =NULL );
	virtual intersect_t	CheckWithHalfspace( const Plane3&, const DTransform* =NULL );
	virtual intersect_t	CheckWithLine( const Line3&, const DTransform* =NULL );
	virtual intersect_t	CheckWithRay( const Line3&, float__t &current_t, const DTransform* =NULL );
	// Transforms the corners of the box instead of the frustum
	virtual intersect_t	CheckAgainstFrustum( const DFrustum &, const DTransform* =NULL, flags_t* clipplanes=NULL);
	// For networking, loading & saving
	virtual void		WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool		ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	enum {
		HOLLOW = inherited::MAX_POS,
		MAX_POS
	};
	Vector			dimensions, halfdim;
	PVertexData		_VertexData;
	// World-space cache
	timeid_t		transform_id;
	Vector3			*world_box;
	void			_UpdateVectors();
	void			_UpdateVertexData();
	// Inherited:
	virtual void	UpdateCWMatrix();
	virtual void	DoAddProperties();
	virtual void	OnPropertyChanged( DProperty& );
};
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTBox> PBox;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_BOX_H_INCLUDED
///////////////////////////////// [citk_Box.h] END
///////////////////////////////// [citk_Camera.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_CAMERA_H_INCLUDED
#define CITK_CAMERA_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC (CTCamera);
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTCamera : public CTEntity
{
	DECLARE_ALL (CTCamera, CTEntity);
public:
	// Constructor (3 in 1)
	CTCamera( cstr_t name =NULL, CTGroup* parent =NULL );
	// Copy constructor
	CTCamera( const CTCamera* original );
	
	// Inherited
	virtual CTEntity*	Copy() const;
	
	// Field of view methods
	void		SetFOV( cfloat__t fov_in_degrees_or_units );
	double		GetFOV() const { return Fov; }
	void		ZoomBy( cfloat__t );
	void		SetPerspective( bool =true );
	bool		IsPerspective() const;
	//////////////////////////////////////
	// Advanced optics
	// Focus Depth ( depth of field ) in world units ( def=10 m )
	float__t	FocusZ;
	// Film Width in mm, used for Lens F (mm) calculations ( def = 35 mm )
	float__t	FilmWidth;
	// Aperture: Lens opening size, in units ( def is 0: pinhole camera, everything sharp as a tack )
	float__t	Aperture; 
	// Filmspeed (for motion blur)  1.0 is fastest (no blur), 0.0 is infinite slow (no reaction to light)
	float__t	FilmSpeed; 
	// Set FOV with lens F in units (force perspective projection) uses FilmWidth
	void		SetLens( cfloat__t lensF );	
	// Get lens F (in units) uses FilmWidth
	float__t	GetLensF() const;	
	// Calculate the size of the spot in 100% of the total filmwidth
	// 0.0 = sharp, 1.0 is object "projected on complete view"
	//  uses FilmWidth, Aperture, Fov
	float__t	CalcSharpness( float__t objectZ ) const;
	// calcs the X  in F/x = Aperture => x = F/Aperture , uses FilmWidth, Fov
	// exception: pinhole camera returns 0.0;
	float__t	CalcApertureFstops() const;
	// calcs the Aperture (lens opening size) for standard Fstops number. uses FilmWidth, Fov
	// pinhole camera: use 0.0
	void		SetApertureFstops( cfloat__t Fstops );
	//! Create a frustum for this camera (in camera space)
	void		CalcFrustum( DFrustum&, const DRect<float> camrect );
	//////////////////////////////////////
	// Near clipping plane
	double		GetNearDist() const { return NearClip; }
	void		SetNearDist( cfloat__t );
	void		UseNearClip( bool =true);
	bool		HasNearClip() const;
	// Far clipping plane
	double		GetFarDist() const { return FarClip; }
	void		SetFarDist( cfloat__t );
	void		UseFarClip( bool =true);
	bool		HasFarClip() const;
	// For networking, loading & saving
	virtual void	WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool	ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	virtual void	DoAddProperties();
private:
	float__t		Fov;				// Field Of View
	DFlags		CameraHints;			// FIXME could use entity hints
	float__t		NearClip, FarClip;
};
/////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTCamera> PCamera;
/////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITK_CAMERA_H_INCLUDED
///////////////////////////////// [citk_Camera.h] END
///////////////////////////////// [citk_Cylinder.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_CYLINDER_H_INCLUDED
#define CITK_CYLINDER_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTCylinder );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTCylinder : public CTShape
{
	DECLARE_ALL( CTCylinder, CTShape );
public:
	enum {
		DEF_RENDERQUALITY = 8
	};
	// Constructor:
	CTCylinder( cfloat__t rad =0.5f METER, cfloat__t h = 1 METER);
	// Copy constructor:
	CTCylinder( const CTCylinder* const );
	// Cylinder specific methods
	void				SetRadius( cfloat__t r );
	void				SetHeight( cfloat__t h );
	void				SetDimensions( cfloat__t r, cfloat__t h ) { SetRadius(r); SetHeight(h); }
	float__t			GetRadius() const { return radius; }
	float__t			GetHeight() const { return height; }
	void				SetRenderQuality( int );
	void				SetRenderCaps( bool upper, bool lower );
	void				SetHollow( bool h =true );
	bool				IsHollow() const { return _Flags.TestBit(HOLLOW); }
	// General:
	virtual double		CalcVolume();
	virtual double		CalcArea();
	virtual	CTShape*	Copy() const;
	// Collision detection helpers:
	virtual Normal		GetNormal( const Vector& );
	virtual Vector		GetSupport( const Vector& );
	virtual double		GetMaxY( const Vector& );
	virtual bool		IsConvex() const { return true; }
	virtual CTSphere*	GetBoundingSphere();
	virtual CTBox*		GetBoundingBox();
	// Rendering:
	virtual void		Render( const RenderInfo_t& );
	// Dinges
	virtual intersect_t	CheckWithPoint( const Vector&, const DTransform* =NULL );
	virtual intersect_t	CheckWithHalfspace( const Plane3&, const DTransform* =NULL );
	virtual intersect_t	CheckWithLine( const Line3&, const DTransform* =NULL );
	// For networking, loading & saving
	virtual void		WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool		ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	enum {
		HOLLOW = inherited::MAX_POS,
		NO_TOP,
		NO_BOTTOM,
		MAX_POS
	};
	float__t		radius, height;
	float__t		radius2, halfHeight;		// cached
	int				quality;
	PVertexData		_VertexData;
	void			_UpdateVectors();
	void			_UpdateVertexData();
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTCylinder> PCylinder;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_CYLINDER_H_INCLUDED
///////////////////////////////// [citk_Cylinder.h] END
///////////////////////////////// [citk_Environment.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_ENVIRONMENT_H_INCLUDED
#define CITK_ENVIRONMENT_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_Light.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_LIGHT_H_INCLUDED
#define CITK_LIGHT_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTLight );
/////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
namespace citk {
/////////////////////////////////////////////////////////////////////////////
class CTVertexData;
// Old-style light types enum. Will be removed soon.
enum LightType_t { ltNone, ltDirectional, ltOmniPoint, ltSpot, ltAmbient };
/////////////////////////////////////////////////////////////////////////////
class CITK_API CTLight : public CTEntity
{
	DECLARE_ALL( CTLight, CTEntity );
public:
	enum lighttype_t
	{ 
		OFF,
		DIRECTIONAL,
		POINT,
		SPOT,
		AMBIENT
	};
	DColor			Color;
	DColor			SpecularColor;
	float__t			A0, A1, A2;				// attenuation
	float__t			Size;					// size of specular highlight
	// Constructor (3 in 1)
	CTLight( cstr_t =NULL, CTGroup* =NULL );
	// Copy constructor
	CTLight( const CTLight* copy_this_one );
	// LightingProperty wrappers:
	void			IncludeObject( CTEntity* );
	void			ExcludeObject( CTEntity* );
	void			DetachObject( CTEntity* );	// restores default lighting
	// Various:
	lighttype_t		GetType() const { return Type; }
	double			GetRange() const { return Range; }
	void			GetCone( float__t &i, float__t&o ) { i=Inner; o=Outer; }
	void			SetColor( const DColor &col ) { SpecularColor = Color = col; }
	void			SetAttenuation( cfloat__t con, cfloat__t lin, cfloat__t quad );
	void			SetCone( cfloat__t t, cfloat__t p );
	// These change the bounding volume:
	void			SetType( lighttype_t lt );
	void			SetRange( cfloat__t range );
	// Use these to make the light fade out at the max range (attenuation)
	void			SetRangeInv( cfloat__t range );
	void			SetRangeInvSquare( cfloat__t range );
	//! Calculate attenuation for a given distance (always >=0; may be >1)
	float__t		CalcAttenuation( cfloat__t d ) { return 1.0f/(A0 + d*(A1 + A2*d)); }
	//! Illuminate a single point in world-space
	float__t		Illuminate( const Vector &point, const Normal &normal );
	//! Illuminate a single point for given light position and direction
	float__t		_Illuminate( const Vector &point, const Normal &normal, const Vector &light, const Normal &dir );
	//! Lighting calculation (for preprocessing); optional object transform
	bool			IlluminateVertexData( CTMaterialProperty*, CTVertexData*, const DTransform *T =NULL );
	// LightID methods:
	id__t			GetID() const { return LightID; }
	id__t			RequestID();
	//! Inherited: make a copy of this light
	virtual CTEntity*	Copy() const;
	//! Inherited: adds light to context light list
	virtual void		Process( ProcessInfo_t& );
	//! Creates a bounding volume (depends on Type and Range)
	virtual CTShape*	UpdateBoundingVolume( kind_t kind =CTProcess::LIGHT );
	// Streaming:
	virtual void	WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool	ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	lighttype_t		Type;
	float__t			Range;				// Bounding sphere
	float__t			Inner, Outer;		// Spot light cone (inner / outer angle)
	virtual			~CTLight();
	virtual void	DoAddProperties();
private:
	id__t			LightID;
};
/////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTLight> PLight;
/////////////////////////////////////////////////////////////////////////////
} // namespace citk
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITK_LIGHT_H_INCLUDED
///////////////////////////////// [citk_Light.h] END
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC (CTEnvironment);
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
namespace citk {
//////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
enum fogtype_t {
	fogNone, fogLinear, fogExp, fogExp2
};
///////////////////////////////////////////////////////////////////////////////////////
class CITK_API CTEnvironment : public CTEntity
{
	DECLARE_ALL(CTEnvironment, CTEntity);
public:
	// Constructor (3 in 1)
	CTEnvironment( cstr_t name =NULL, CTGroup* parent =NULL );
	virtual float__t		GetFogRange( const Vector *worldpos =NULL ) =0;
	virtual float__t		GetFogDensity( const Vector *worldpos =NULL ) =0;
	virtual Color32		GetFogColor( const Vector *worldpos =NULL ) =0;
	virtual fogtype_t	GetFogType() =0;
	virtual float__t		GetDensity( const Vector *worldpos =NULL ) =0;
	virtual float__t		GetViscosity( const Vector *worldpos =NULL ) =0;
	virtual Vector		GetGravity( const Vector *worldpos =NULL ) =0;
	virtual bool		HasGravity() =0;
	virtual Vector		GetWind( const Vector *worldpos =NULL ) =0;
	virtual bool		HasWind() =0;
	virtual DColor		GetAmbientLight( const Vector *worldpos =NULL ) =0;
	// Use this method to associate a bounding volume with this environment:
	void				SetVolume( CTShape* sh ) { UseBoundingVolume(sh,CTProcess::LIGHT); }
	CTShape*			GetVolume() { return GetBoundingVolume(CTProcess::LIGHT); }
protected:
	virtual bool	DoRegisterWithService();
	virtual bool	DoUnregisterWithService();
};
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTEnvironment> PEnvironment;
///////////////////////////////////////////////////////////////////////////////////////
} // namespace citk
//////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
#endif // !CITK_ENVIRONMENT_H_INCLUDED
///////////////////////////////// [citk_Environment.h] END
///////////////////////////////// [citk_FrustumPicker.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_FRUSTUMPICKER_H_INCLUDED
#define CITK_FRUSTUMPICKER_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class DTransform;		// forward
class DFrustum;			// forward
class CTEntity;			// forward
class CTVertexData;		// forward
class CTGeometry;		// forward
class CTCamera;			// forward
///////////////////////////////////////////////////////////////////////////////
class CITK_API DFrustumPicker
{
public:
	bool		Hidden;						// also check hidden entities (false)
	bool		FullyInside; 				// only objects entirely inside the frustum (false)
	bool		CheckOnlyBB;				// checks only bboxes; faster, but not precise (false)
	bool		AllLOD;						// test all LODs or only active (false)
	bool		UpdateWorldSpace;			// update world positions (false)
	//! Constructor, sets default options
	DFrustumPicker();
	//! Test all objects in the provided group (creates a temporary frustum)
	int			Pick( CTCamera*, float x1, float y1, float x2, float y2, CTEntity* world);
	//! Test all objects in the provided group against the frustum
	int			Pick( const DFrustum&, CTEntity* world);
	//! Test all objects in the provided group against the frustum
	int				GetObjectCount() const		{ return PickedObjects.Count(); }
	CTGeometry*		GetObjectNo(int i) const	{ return PickedObjects.GetNo(i); }
	// some static functions // for general use
	static intersect_t	CheckVertexDataAgainstFrustum(const CTVertexData*, const DTransform&, const DFrustum&, bool onlyinside = false);
	static intersect_t	CheckGeometryAgainstFrustum(const CTGeometry*, const DFrustum&, bool onlyinside = false);
private:
	ArrayPtr<CTGeometry>	PickedObjects;
	// frustum testing functions
	void		_SearchTree(const DFrustum&,CTEntity* root);
};
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_FRUSTUMPICKER_H_INCLUDED
///////////////////////////////// [citk_FrustumPicker.h] END
///////////////////////////////// [citk_Instance.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_INSTANCE_H_INCLUDED
#define CITK_INSTANCE_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC (CTInstance);
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citk {
/////////////////////////////////////////////////////////////////////////////
class CITK_API CTInstance : public CTEntity
{
	DECLARE_ALL( CTInstance, CTEntity );
public:
	// Constructor (3 in 1)
	CTInstance( cstr_t name =NULL, CTGroup* parent=NULL );
	// Copy constructor
	CTInstance( const CTInstance* );
	// Inherited
	virtual void		Process( ProcessInfo_t& );
	// For networking, loading & saving
	virtual void		WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool		ProcessChunk( CTStream* stream, chunkid_t chid );
	virtual void		OnMessage( msgid_t, msgdata_t );
	CTEntity*			GetTarget() const { return Target; }
	void				SetTarget( CTEntity* );
protected:
	virtual void		DoAddProperties();
	PEntity				Target;
};
/////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTInstance> PInstance;
/////////////////////////////////////////////////////////////////////////////
} // namespace citk
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITK_INSTANCE_H_INCLUDED
///////////////////////////////// [citk_Instance.h] END
///////////////////////////////// [citk_GeometryShape.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_GEOMETRYSHAPE_H_INCLUDED
#define CITK_GEOMETRYSHAPE_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTGeometryShape );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTGeometryShape : public CTShape
{
	DECLARE_ALL( CTGeometryShape, CTShape );
public:
	PGeometry		Shape;
	// Constructors
	CTGeometryShape( CTGeometry* =NULL );
	CTGeometryShape( const CTGeometryShape* cop );
	// Various shit
	virtual CTShape*	Copy() const;
	virtual void		Render( const RenderInfo_t& );
	virtual void		Clear() { Shape = NULL; }
	virtual bool		ApplyTransform( const DTransform& );
	// Collision detection helpers
	virtual bool		IsConvex() const { return false; }
	virtual Vector		GetNormal( const Vector& );
	virtual Vector		GetSupport( const Vector& );
	virtual double		GetMaxY( const Vector& );
	virtual CTSphere*	GetBoundingSphere();
	virtual CTBox*		GetBoundingBox();
	virtual intersect_t	CheckWithPoint( const Vector&, const DTransform* =NULL );
	virtual intersect_t	CheckWithHalfspace( const Plane3&, const DTransform* =NULL );
	virtual intersect_t	CheckWithLine( const Line3&, const DTransform* =NULL );
	virtual intersect_t CheckWithRay( const Line3&, float__t &current_t, const DTransform *T =NULL );
	// For networking, loading & saving
	virtual void	WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool	ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	// Inherited from CTInterface:
	virtual void	DoAddProperties();
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTGeometryShape> PGeometryShape;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_GEOMETRYSHAPE_H_INCLUDED
///////////////////////////////// [citk_GeometryShape.h] END
///////////////////////////////// [citk_Grid2D.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_GRID2D_H_INCLUDED
#define CITK_GRID2D_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTGrid2D );
/////////////////////////////////////////////////////////////////////////////
namespace citk {
	
/////////////////////////////////////////////////////////////////////////////
class CITK_API CTGrid2D : public CTEntity
{
	DECLARE_ALL( CTGrid2D, CTEntity );
public:
	int			LineCount;				//!< defaults to 10
	float__t	Spacing;				//!< defaults to 1 METER
	// Constructor (3 in 1)
	CTGrid2D( cstr_t name =NULL, CTGroup* =NULL );
	// Copy-constructor
	CTGrid2D( const CTGrid2D * const );
	//! Set/get the line spacing of this grid (defaults to 1 METER)
	void		SetSpacing( cfloat__t );
	float__t	GetSpacing() const				{ return Spacing; }
	//! Set/get the number of lines to draw in each direction (defaults to 10)
	void		SetLineCount( int );
	int			GetLineCount() const			{ return LineCount; }
	
	//! Set/get the extent of the grid (LineCount)
	void		SetExtent( cfloat__t e )		{ SetLineCount( __ftoi(e/Spacing) ); }
	float__t	GetExtent() const				{ return Spacing*LineCount; }
	//! Philippe-style single setup function
	void		Setup( cfloat__t spacing, int linecount );
	//! Helper method that creates a render-state for this grid.
	void		SetState( cfloat__t linewidth, const DColorA&, bool zbias );
	//! Recreates the grid's vertex-data
	void		UpdateGrid();
	//! Snaps the given vector to the current grid spacing (ignores LineCount)
	Vector		SnapToGrid( cvec_t localvec );
	//! Snaps the given position and moves the grid to it (using MoveBy)
	void		SnappedMoveTo( cvec_t worldpos );
	//! Static method that generates a symmetric grid (in XZ plane)
	static void		GenerateGridXZ( CTVertexData*, cfloat__t, int );
	// Inherited from CTEntity:
	virtual CTEntity*	Copy() const;
	virtual CTShape*	UpdateBoundingVolume( kind_t kind =CTProcess::DRAW );
	virtual bool		CheckWithRay( DTreePicker&, const Line3& );
	virtual void		Process( ProcessInfo_t& );
	// Inherited from CTStreamed:
	virtual void		WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool		ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	PVertexData			grid;
	// Inherited from CTInterface:
	virtual	void		OnPropertyChanged( DProperty& );
	virtual void		DoAddProperties();
};
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTGrid2D> PGrid2D;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_GRID2D_H_INCLUDED
///////////////////////////////// [citk_Grid2D.h] END
///////////////////////////////// [citk_TreeProcessor.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_TREEPROCESSOR_H_INCLUDED
#define CITK_TREEPROCESSOR_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTTreeProcessor);
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citk {
/////////////////////////////////////////////////////////////////////////////
class CTEntity;
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class CITK_API CTTreeProcessor : public CTProcess
{
	DECLARE_ALL(CTTreeProcessor,CTProcess);
public:
	virtual void		AddProcessPoint( CTEntity* ) = 0;
	virtual void		RemoveProcessPoint( CTEntity* ) = 0;
	void				SetTree( CTEntity* root );
	inline CTEntity*	GetTree() const { return _Tree; }
	virtual void		OnNewSubtree( CTEntity* ent ) = 0;
private:
	SafePtr<CTEntity>	_Tree;
};
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTTreeProcessor> PTreeProcessor;
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
CITK_API CTTreeProcessor* citk_GetTreeProcessor( CTEntity* );
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
} // namespace citk
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !_TREEPROCESSOR_H_INCLUDED
///////////////////////////////// [citk_TreeProcessor.h] END
///////////////////////////////// [citk_VisibilityChecker.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_VISIBILITYCHECKER_H_INCLUDED
#define CITK_VISIBILITYCHECKER_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC (CTVisibilityChecker);
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citk {
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class CTEntity;
struct RenderInfo_t;
/////////////////////////////////////////////////////////////////////////////
class CITK_API CTVisibilityChecker : public CTExtraData
{
	DECLARE_ALL( CTVisibilityChecker, CTExtraData );
public:
	virtual bool CheckVisibility( CTEntity*, RenderInfo_t& ) = 0;
};
/////////////////////////////////////////////////////////////////////////////
} // namespace citk
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITK_VISIBILITYCHECKER_H_INCLUDED
///////////////////////////////// [citk_VisibilityChecker.h] END
///////////////////////////////// [citk_LODGroup.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_LODGROUP_H_INCLUDED
#define CITK_LODGROUP_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTLODGroup );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CTCamera;
//! This flag specified that the LOD distance should be calculated using BV.
#define EH_LOD_CLOSESTPOINT		0x00020000
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTLODGroup : public CTGroup
{
	DECLARE_ALL( CTLODGroup, CTGroup );
public:
	//! Alpha fade time, in ms (higher = lower). Zero disables fading.
	ctime_t		FadeTime;
	// Constructor (3 in 1)
	CTLODGroup( cstr_t name =NULL, CTGroup* parent =NULL );
	// Copy constructor
	CTLODGroup( const CTGroup* copy_this_one );
	CTLODGroup( const CTLODGroup* copy_this_one );
	//! Get the index of the last processed LOD (-1 = unknown)
	int				GetLastProcessed() const { return LastLOD; }
	//! Get the index of the LOD at a specific distance (-1 = none)
	inline int		GetLOD( cfloat__t distance ) const { return GetSqrLOD(_sqr(distance)); }
	int				GetSqrLOD( cfloat__t sqr_distance ) const;
	//! Set the maximum distance for a child entity
	bool			SetMaxDistance( CTEntity*, cfloat__t max_dist_in_units );
	float__t		GetMaxDistance( CTEntity* ) const;
	bool			HasChildDistance( int i ) const { return LODs.ContainsNo(i); }
	float__t		GetChildDistance( int ) const;
	//! Calculate the LOD distance to the closest point on the bounding volume.
	void			UseClosestPoint( bool v =true ) { Hints.Set(EH_LOD_CLOSESTPOINT,v); }
	/////////////////////////////////////////////////////////////////////////////
	// Inherited methods:
	// Process children according to 'processflags'
	virtual void		Process( ProcessInfo_t& );
	// Only check last processed child
	virtual bool		CheckWithRay( DTreePicker&, const Line3& );
	// Copy this LOD group
	virtual CTEntity*	Copy() const;
	// For networking, loading & saving
	virtual void		WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool		ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	int					LastLOD;			// for picking et al.
	flags_t				LODMask;			// not used
	ArrayVal<float__t>	LODs;
	struct alpha_t {
		CTCamera*	camera;					// only for comparison
		int			child_in;
		float		alpha_in;
		int			child_out;
		float		alpha_out;
		frameid_t	frameid;				// for comparison
		ctime_t		lasttime;
	};
	ArrayVal<alpha_t>	Alphas;				// currently visible LODs
	void			_ProcessFadeChild( CTEntity*, ProcessInfo_t&, float alpha, bool bias );
	alpha_t*		_FindAlpha( CTCamera *cam );
	// Inherited:
	virtual void	DoAddProperties();
};
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTLODGroup> PLODGroup;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_LODGROUP_H_INCLUDED
///////////////////////////////// [citk_LODGroup.h] END
///////////////////////////////// [citk_OnDemand.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_ONDEMAND_H_INCLUDED
#define CITK_ONDEMAND_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTOnDemand );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#define MSG_ONDEMANDLOAD_LOADED		0xC3748AD8
#define MSG_ONDEMANDLOAD_UNLOADED	0x78455E47
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTOnDemand : public CTEntity
{
	DECLARE_ALL( CTOnDemand, CTEntity );
public:
	//! Time To Live. By default negative, will never 'Unload'.
	ctime_t				TTL;
	// Constructor (3 in 1)
	CTOnDemand( cstr_t name =NULL, CTGroup* parent =NULL );
	// Copy constructor
	CTOnDemand( const CTOnDemand* copy_this_one );
//	CTOnDemand( const CTEntity* copy_this_one );
	/////////////////////////////////////////////////////////////////////////////
	// New methods
	// Methods to configure the preset child (dummy child when not loaded)
	void				PresetKind( flags_t kind );
	void				PresetBoundingVolume( CTShape*, CTProcess::kind_t );
	void				PresetBoundingVolume( CTEntity* );
	//! Specifies whether this object was loaded.
	CTGroup*			GetLoadedScene() const		{ return LoadedScene; }
	//! This method is called when the entity is about to be processed.
	bool				Load();
	//! This method is called after not being processed for the specified TTL.
	void				Unload();
	/////////////////////////////////////////////////////////////////////////////
	// Inherited methods:
	// Inherited: Process children according to 'processflags'
	virtual void		Process( ProcessInfo_t& );
	// Inherited: update the bounding volume from the loaded group
	virtual CTShape*	UpdateBoundingVolume( kind_t kind );
	// Inherited: Check each child
	virtual bool		CheckWithRay( DTreePicker&, const Line3& );
	// Find a child by pointer
	virtual CTEntity*	FindChild( CTEntity * const );
	// Find a child by name (SLOW)
	virtual CTEntity*	FindChildByName( cstr_t name );
	virtual CTEntity*	FindChildByNameIC( cstr_t name );
	
	// For networking, loading & saving
	virtual void		WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool		ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	//! The loaded scene, will be released in UnLoad.
	PGroup				LoadedScene;
	//! This method is called when the entity is about to be processed.
	virtual bool		OnLoad() =0;
	//! This method is called after not being processed for the specified TTL.
	virtual void		OnUnload() { }
	// Inherited:
	virtual void		DoAddProperties();
private:
	ctime_t				IdleTime;
	//! Use this update function to update/check the idle time.
	UPDATEFUNC			CheckTimeOut( ctime_t );
};
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTOnDemand> POnDemand;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_ONDEMAND_H_INCLUDED
///////////////////////////////// [citk_OnDemand.h] END
///////////////////////////////// [citk_OnDemandCopy.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_ONDEMANDCOPY_H_INCLUDED
#define CITK_ONDEMANDCOPY_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_OnDemandGroup.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_ONDEMANDGROUP_H_INCLUDED
#define CITK_ONDEMANDGROUP_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTOnDemandGroup );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#define MSG_ONDEMANDLOAD_LOADED		0xC3748AD8
#define MSG_ONDEMANDLOAD_UNLOADED	0x78455E47
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTOnDemandGroup : public CTGroup
{
	DECLARE_ALL( CTOnDemandGroup, CTGroup );
public:
	//! Time To Live; 0 will never 'Unload'; 1 will unload ASAP
	ctime_t				TTL;
	// Constructor (3 in 1)
	CTOnDemandGroup( cstr_t name =NULL, CTGroup* parent =NULL );
	// Copy constructor
	CTOnDemandGroup( const CTOnDemandGroup* copy_this_one );
//	CTOnDemandGroup( const CTEntity* copy_this_one );
	/////////////////////////////////////////////////////////////////////////////
	// New methods
	// Methods to configure the preset child (dummy child when not loaded)
	void				PresetKind( flags_t kind );
	void				PresetBoundingVolume( CTShape*, CTProcess::kind_t );
	void				PresetBoundingVolume( CTEntity* );
	//! Returns whether the scene was loaded/created.
	bool				IsLoaded() const { return Loaded; }
	//! This method is called when the entity is about to be processed.
	bool				Load();
	//! This method is called after not being processed for the specified TTL.
	void				Unload();
	/////////////////////////////////////////////////////////////////////////////
	// Inherited methods:
	// Inherited: Process children according to 'processflags'
	virtual void		Process( ProcessInfo_t& );
	// For networking, loading & saving
	virtual void		WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool		ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	bool				Loaded;
	PEntity				Preset;
	//! This method is called when the entity is about to be processed.
	virtual bool		OnLoad() =0;
	//! This method is called after not being processed for the specified TTL.
	virtual void		OnUnload();				// removes group's children
	// Inherited:
	virtual void		DoAddProperties();
protected:
	ctime_t				IdleTime;
	//! Use this update function to update/check the idle time.
	UPDATEFUNC			CheckTimeOut( ctime_t );
};
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTOnDemandGroup> POnDemandGroup;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_ONDEMANDGROUP_H_INCLUDED
	
///////////////////////////////// [citk_OnDemandGroup.h] END
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTOnDemandCopy );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTOnDemandCopy : public CTOnDemandGroup
{
	DECLARE_ALL( CTOnDemandCopy, CTOnDemandGroup );
public:
	//! Pointer to the group to be instanced when drawn
	PEntity	Source;
	// Constructor (3 in 1)
	CTOnDemandCopy( cstr_t name =NULL, CTGroup *parent =NULL );
	// Copy constructor
	CTOnDemandCopy( const CTOnDemandCopy* copy_this_one );
	/////////////////////////////////////////////////////////////////////////////
	// Inherited methods:
	// Copy this OnDemandLoad ondemand
	virtual CTEntity*	Copy() const;
	// For networking, loading & saving
	virtual void		WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool		ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	// Inherited:
	virtual void		DoAddProperties();
	// Load the scene
	virtual bool		OnLoad();
};
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTOnDemandCopy> POnDemandCopy;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_ONDEMANDCOPY_H_INCLUDED
///////////////////////////////// [citk_OnDemandCopy.h] END
///////////////////////////////// [citk_OnDemandLoad.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_ONDEMANDLOAD_H_INCLUDED
#define CITK_ONDEMANDLOAD_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTOnDemandLoad );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTOnDemandLoad : public CTOnDemandGroup
{
	DECLARE_ALL( CTOnDemandLoad, CTOnDemandGroup );
public:
	//! Filename of scene file to load
	DynString			Filename;
	//! Flag whether the scene cache should be used (default = false)
	bool				UseCache;
	// Constructor (3 in 1)
	CTOnDemandLoad( cstr_t name =NULL, CTGroup *parent =NULL );
	// Copy constructor
	CTOnDemandLoad( const CTOnDemandLoad* copy_this_one );
	/////////////////////////////////////////////////////////////////////////////
	// Inherited methods:
	// Copy this OnDemandLoad ondemand
	virtual CTEntity*	Copy() const;
	// For networking, loading & saving
	virtual void		WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool		ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	// Inherited:
	virtual void		DoAddProperties();
	// Load the scene
	virtual bool		OnLoad();
};
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTOnDemandLoad> POnDemandLoad;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_ONDEMANDLOAD_H_INCLUDED
///////////////////////////////// [citk_OnDemandLoad.h] END
///////////////////////////////// [citk_Mic.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_MICROPHONE_H_INCLUDED
#define CITK_MICROPHONE_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC (CTMicrophone);
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citk {
/////////////////////////////////////////////////////////////////////////////
class CITK_API CTMicrophone : public CTEntity
{
	DECLARE_ALL( CTMicrophone, CTEntity );
public:
	// Constructor (3 in 1)
	CTMicrophone( cstr_t name =NULL, CTGroup* parent =NULL );
	// Copy constructor
	CTMicrophone( const CTMicrophone * copy_this_one );
	// Range
	void			SetRange( cfloat__t );
	cfloat__t		GetRange() const { return Range; }
	// Inherited
	virtual CTEntity*	Copy() const;
	virtual CTShape*	UpdateBoundingVolume( kind_t kind );
	
	// For networking, loading & saving
	virtual void	WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool	ProcessChunk( CTStream* stream, chunkid_t chid );
private:
	float__t		Range;
};
/////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTMicrophone> PMicrophone;
/////////////////////////////////////////////////////////////////////////////
} // namespace citk
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITK_MICROPHONE_H_INCLUDED
///////////////////////////////// [citk_Mic.h] END
///////////////////////////////// [citk_RenderContext.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_RENDERCONTEXT_H_INCLUDED
#define CITK_RENDERCONTEXT_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_RenderTarget.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_RENDERTARGET_H_INCLUDED
#define CITK_RENDERTARGET_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_Device.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_DEVICE_H_INCLUDED
#define CITK_DEVICE_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_Logged.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
//
//  Logged.h			Provides Error-logging
//
#ifndef CITK_LOGGED_H_INCLUDED
#define CITK_LOGGED_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTLogged);
//////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
//////////////////////////////////////////////////////////////////////////////
typedef long			errorcode_t;	// signed
#define EC_OK			((errorcode_t)0)
#define EC_SUCCESS		EC_OK
#define EC_UNKNOWN		((errorcode_t)1)
#define ET_INFO			0x10000000		// Error type
#define ET_WARNINGOK	0x20000000
#define ET_WARNING		0x90000000
#define ET_ERROR		0xA0000000
#define ET_FATAL		0xB0000000
#define ET_INTERNAL		0xC0000000
#define ET_MASK			0xF0000000		// Masks out the type
#define EVL_0			0x00000000		// Verbose level
#define EVL_1			0x01000000
#define EVL_2			0x02000000
#define EVL_3			0x03000000
#define EVL_4			0x04000000
#define EVL_5			0x05000000
#define EVL_6			0x06000000
#define EVL_7			0x07000000
#define EVL_8			0x08000000
#define EVL_9			0x09000000
#define EVL_10			0x0A000000
#define EVL_11			0x0B000000
#define EVL_12			0x0C000000
#define EVL_13			0x0D000000
#define EVL_14			0x0E000000
#define EVL_15			0x0F000000
#define EVL_MASK		0x0F000000		// Masks out the verbose level
#define EVL_SHIFT		24
/////////////////////////////////////////////////////////////////////////////
#define ERRORCODE(ec)	citk_ErrorCode((errorcode_t)ec,this),(((errorcode_t)ec)>=0)
#define ERRORMSG(s)		citk_ErrorCode(ET_ERROR|EC_UNKNOWN,this,s),false
#define WARNINGMSG(s)	citk_ErrorCode(ET_WARNINGOK|EC_UNKNOWN,this,s),true
#define INFOMSG(s)		citk_ErrorCode(ET_INFO|EC_UNKNOWN,this,s),true
/////////////////////////////////////////////////////////////////////////////
class CITK_API CTLogged : public CTNamed
{
	DECLARE_ALL( CTLogged, CTNamed );
public:
	CTLogged();
	bool			HasError() const;
	errorcode_t		LastErrorCode() const;
	cstr_t			LastErrorMsg() const;
	// Change verbose level by some amount;
	//  a negative value will result in less errors/messages shown
	// Returns the new verbose level
	int				ChangeVerbose( int relative_verbose );
	// Override this function for your custom error codes
	virtual String	TranslateErrorCode( errorcode_t );
protected:
	virtual void	DoAddProperties();
	// Return value depends on the highest bit of the error code
	// If set, function returns false
	bool			ErrorCode( errorcode_t, cstr_t param =NULL );
	bool			NoError();							// Always returns true
	// These will be removed soon!!!
	bool			ErrorMsg( cstr_t );					// Always returns false
	bool			WarningMsg( cstr_t, int =0 );		// Always returns true
	bool			InfoMsg( cstr_t, int =0 );			// Always returns true
private:
	DynString		_LastErrorMsg;
	errorcode_t		_LastErrorCode;
	int				_Verbose;
};
//////////////////////////////////////////////////////////////////////////////
} // namespace citk
/////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
#endif // !CITK_LOGGED_H_INCLUDED
///////////////////////////////// [citk_Logged.h] END
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTDevice);
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
namespace citk {
//////////////////////////////////////////////////////////////////////////////
#define MSG_DEV_STOPPING		0x21344567
#define MSG_DEV_STARTING		0x21344568
#define MSG_DEV_STOPPED			0x21344569
#define MSG_DEV_STARTED			0x2134456A
//////////////////////////////////////////////////////////////////////////////
typedef int devid_t;
#define DEVID_NONE	-1
#define DEVID_AUTO	-1
///////////////////////////////////////////////////////////////////////
class CITK_API CTDevice : public CTLogged
{
	DECLARE_ALL(CTDevice,CTLogged);
public:
	// Default constructor
	CTDevice();
	// Start using this device... returns 'true' if succesfull
	bool			Start();
	// Stop using this device and free as many system resources as possible.
	// Returns false if an error occured while stopping the device.
	bool			Stop();
	bool			Restart();
	bool			IsStarted() const { return Started; }
	virtual bool	IsShareable() const { return true; }
	virtual bool	StopOnRelease() const { return false; }
	bool			Enable();
	bool			Disable();
	bool			IsEnabled() const;
	// DeviceID indentifies the instance of a specific device (configuration)
	devid_t			GetDeviceID() const { return DeviceID; }
	void			SetDeviceID(devid_t id);
	///// Dependency methods:
	void			AddSubDevice( CTDevice* const );
	void			RemoveSubDevice( CTDevice* const );
//	CTDevice*		AddParent( CTDevice* const );
//	CTDevice*		GetParent( int =0 ) const;
	CTDevice*		SetParent( CTDevice* const );
	CTDevice*		GetParent() const;
	int				GetSubDeviceCount() const;
	CTDevice*		GetSubDeviceNo( const int ) const;
	///// Inherited:
	// Get the name of the actual configuration
	virtual String	GetConfigName();
	virtual void	OnDelete( CTAggregated* );
	virtual void	OnPropertyChanged( DProperty& );
	// Delete first calls Stop() to stop the device
	virtual void	Delete();
protected:
	virtual	bool	StartDevice() { return NoError(); }
	virtual bool	StopDevice() { return NoError(); }
	virtual void	DoAddProperties();
	virtual bool	DoRegisterWithService();
	virtual bool	DoUnregisterWithService();
	virtual ~CTDevice();
private:
	devid_t			DeviceID;
	CTDevice*		Parent;
	ArrayPtr<CTDevice>	SubDevices;
	bool			Enabled;
	bool			Started;
};
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
//////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_DevicePtr.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_DEVICEPTR_H_INCLUDED
#define CITK_DEVICEPTR_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////
class CTDevice;
///////////////////////////////////////////////////////////////////////
class CITK_API DevicePtrStuff
{
protected:
	static void			_Release( CTDevice* old );
	static CTDevice*	_ObtainDeviceByName( CTDevice* old, cstr_t, devid_t, bool );
	static CTDevice*	_ObtainDevice( CTDevice* old, cdid_t, devid_t, bool );
	static CTDevice*	_ShareDevice( CTDevice* old, CTDevice* );
	static CTDevice*	_SafetyCheck( CTDevice* old, cdid_t );
};
///////////////////////////////////////////////////////////////////////////////
template <class CType, bool share=false>
class DevicePtr : public StrongPtr<CType>, protected DevicePtrStuff
{
public:
	//! Default constructor
	DevicePtr() {}
	//! Copy constructor (share a device)
	DevicePtr( CType* p ) { PointTo(p); }
	//! Destructor
	~DevicePtr() { Release(); }
	//! Tries to aquire an instance. Returns 'true' if ready for use
	bool	Acquire() { if (!ptr) return ObtainDevice(); if (!ptr->IsStarted()) return ptr->Start(); return true; }
	//! Check whether we point to a valid (started) device
	bool	IsValid() const { return ptr && ptr->IsStarted(); }
	//! Release the current device
	void	Release() { if (ptr) { _Release(ptr); ptr = NULL; } }
	//! Share a device pointer
	void	PointTo( CType* p ) { ptr = (CType*)_ShareDevice( ptr, p ); }
	// Methods for obtaining a new device instance:
	bool	ObtainDevice( bool sh =share )								{ ptr = (CType*)_ObtainDevice(ptr,CType::_CD()->GetID(),DEVID_NONE,sh); return ptr!=NULL; }
	bool	ObtainDevice( cdid_t id, devid_t did, bool sh=share )		{ ptr = (CType*)_SafetyCheck( _ObtainDevice(ptr,id,did,sh), CType::_CD()->GetID() ); return ptr!=NULL; }
	bool	ObtainDeviceByName( cstr_t cn, devid_t did, bool sh=share )	{ ptr = (CType*)_SafetyCheck( _ObtainDeviceByName(ptr,cn,did,sh), CType::_CD()->GetID() ); return ptr!=NULL; }
	bool	ObtainDevice( cdid_t id, bool sh=share )					{ return ObtainDevice(id, DEVID_NONE, sh); }
	bool	ObtainDeviceByName( cstr_t cn, bool sh=share )				{ return ObtainDeviceByName(cn, DEVID_NONE, sh); }
	//! Assignment operators: (Share a device)
	DevicePtr& operator = ( CType* p ) { PointTo(p); return *this; }
	DevicePtr& operator = ( const DevicePtr& sp ) { PointTo(sp); return *this; }
};
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_DEVICEPTR_H_INCLUDED
///////////////////////////////// [citk_DevicePtr.h] END
namespace citk {
typedef DevicePtr<CTDevice> PDevice;
} // namespace citk
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
#endif // !CITK_DEVICE_H_INCLUDED
///////////////////////////////// [citk_Device.h] END
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTRenderTarget );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
struct DRenderContext;
class CTVertexData;
class CTRenderState;
class CTSkinData;
struct boneinfo_t;
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTRenderTarget : public CTDevice
{
	DECLARE_ALL( CTRenderTarget, CTDevice );
public:
	// Default methods:
	DBitmap*		GrabBitmapFull();
	bool			ShowBitmapFull( DBitmap* );
	// Virtual (abstract) calls:
	virtual bool	Show() = 0;
	virtual bool	Hide() = 0;
	virtual bool	IsVisible() = 0;
	virtual	DBitmap*	GrabBitmap( int x, int y, int w, int h ) = 0;
	virtual bool		ShowBitmap( DBitmap*, int x, int y ) = 0;
	// RenderContext methods
	virtual	bool	BeginScene( DRenderContext* ) = 0;
	virtual bool	Render( CTVertexData*, const RenderInfo_t& , CTRenderState* ) = 0;
	virtual bool	RenderSkin( CTSkinData*, boneinfo_t** bones, const RenderInfo_t& , CTRenderState* ) = 0;
	virtual	bool	FlushScene( DRenderContext* ) = 0;
	virtual	bool	EndScene( DRenderContext* ) = 0;
	// FlipBuffer will show the backbuffer
	virtual void	FlipBuffer() = 0;
	// Preload a texture into video memory
	virtual bool	Preload( CTTexture* ) = 0;
	// Preload a mesh into video memory. Returns cached components.
	virtual flags_t	Preload( CTVertexData*, flags_t what =~0 ) = 0;
	// Obtain information about the current view
	virtual bool	GetResolution( int &x, int &y ) = 0;
	virtual double	GetAspectRatio();		// returns 4:3 by default
	// Invalidates the camera transformation (for portals)
	virtual void	InvalidateCamera( DRenderContext* ) = 0;
	//! Occlusion test; returns ID to be passed to EndOcclusionTest, -1 for error
	virtual int		StartOcclusionTest( cvec_t min, cvec_t max ) { return -1; }
	virtual int		EndOcclusionTest( int int_from_start ) { return -1; }
	//! Render to a specific resolution; returns false if not supported
	virtual bool	SetResolution( int x, int y ) { return false; }
};
///////////////////////////////////////////////////////////////////////////////
typedef DevicePtr<CTRenderTarget> PRenderTarget;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_RENDERTARGET_H_INCLUDED
///////////////////////////////// [citk_RenderTarget.h] END
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class DViewport;
class CTEntity;
class CTLight;
class CTGroup;
class CTCamera;
class CTLight;
class CTEnvironment;
class CTRenderTarget;
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
struct CITK_API DRenderContext
{
	// Default constructor
	DRenderContext();
	// Various
	CTProcess*			Root;
	DViewport*			Viewport;
	DFrustum			Frustum;
	CTCamera*			Camera;
	CTRenderTarget*		Renderer;
	// Performance counters
	int					tricull, tricount, tridrawn, matswitch;
	// Environment options (lighting/fog)
	CTEnvironment*		Environment;
	ArrayPtr<CTLight>	ActiveLights;
	DColor				AmbientIntensity;
};
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_RENDERCONTEXT_H_INCLUDED
///////////////////////////////// [citk_RenderContext.h] END
///////////////////////////////// [citk_SceneIO.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_SCENEIO_H_INCLUDED
#define CITK_SCENEIO_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_3DImport.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_3DIMPORT_INCLUDED
#define CITK_3DIMPORT_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_Import.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_IMPORT_INCLUDED
#define CITK_IMPORT_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_ImportExport.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_IMPORTEXPORT_INCLUDED
#define CITK_IMPORTEXPORT_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTImportExport);
/////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////
class CITK_API CTImportExport : public CTLogged
{
	DECLARE_ALL(CTImportExport,CTLogged);
public:
	CTImportExport();
	//! Check whether this IO object handles files with a specific extension
	virtual bool	HandlesExtension( cstr_t ) const;
	//! Check whether this IO object handles a specific protocol (default "file:")
	virtual bool	HandlesProtocol( cstr_t ) const;
	// Methods to enumerate all the extensions
	int				GetExtensionCount() const;
	cstr_t			GetExtensionNo( const int ) const;
	// Check the result of the last IO operation
	bool			GetSuccess() const;			
protected:
	bool			Success;
	// Add a specific extension
	void			AddExtension( cstr_t );
	// Clear all extension
	void			ClearExtensions();
	// Reset the default values for all properties
	virtual void	SetDefaults() { Success = false; }
private:
	ArrayVal<String>	Extensions;
};
/////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITK_IMPORTEXPORT_INCLUDED
///////////////////////////////// [citk_ImportExport.h] END
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTImport);
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citk {
//////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class CITK_API CTImport : public CTImportExport
{
	DECLARE_ALL(CTImport,CTImportExport);
public:
	// Imports a file
	bool			Import( cstr_t );
	// Import a file from an already opened stream
	virtual bool	ImportFromStream( CTStream* ) { return false; }
protected:
	// Do the actual import
	virtual bool	DoImport( cstr_t ) = 0;
};
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
} // namespace citk
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITK_IMPORT_INCLUDED
///////////////////////////////// [citk_Import.h] END
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CT3DImport);
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citk {
/////////////////////////////////////////////////////////////////////////////
class CTGroup;
/////////////////////////////////////////////////////////////////////////////
#define IMF_MESHES			0x00000001
#define IMF_LIGHTS			0x00000002
#define IMF_CAMERAS			0x00000004	
#define IMF_HIERARCHY		0x00000008
#define IMF_TEXTURES		0x00000010
#define IMF_MATERIALS		0x00000020
#define IMF_KEYFRAMES		0x00000040
#define IMF_ALLDATA			0x000000FF
///////////////////////////////////////////////////////////////////////////////
class CITK_API CT3DImport : public CTImport
{
	DECLARE_ALL(CT3DImport,CTImport);
public:
	StrongArray<CTReferenced>	ImportedObjects;
	CT3DImport();
	void			SetImportMask( flags_t );
	void			SetScaling( const double & );
	void			SetRoot( CTGroup* );
	int				GetImportedObjectCount() const;
	CTReferenced*	GetImportedObjectNo( const int ) const;
protected:
	DFlags			ImportFlags;
	CTGroup*		GetRoot() const { return Root; }
	double			GetScaling() const { return Scaling; }
	// Call this to add an object to the ImportedObjects list
	void			AddImportedObject( CTReferenced* );
	// Override this one to reset the internal structures
	virtual void	SetDefaults();
private:
	double				Scaling;
	CTGroup*			Root;
};
/////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CT3DImport> P3DImport;
/////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITK_3DIMPORT_INCLUDED
///////////////////////////////// [citk_3DImport.h] END
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTSceneIO );
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citk {
/////////////////////////////////////////////////////////////////////////////
class CITK_API CTSceneIO : public CT3DImport
{
	DECLARE_ALL( CTSceneIO, CT3DImport );
public:
	CTSceneIO();
	void			RegisterClasses();
protected:
	virtual bool	DoImport( cstr_t );
private:
	StrongArray<CT3DImport>	Importers;
	bool			_Import( cstr_t );
};
/////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTSceneIO> PSceneIO;
/////////////////////////////////////////////////////////////////////////////
} // namespace citk
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITK_SCENEIO_H_INCLUDED
///////////////////////////////// [citk_SceneIO.h] END
///////////////////////////////// [citk_SkinData.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_SKINDATA_H_INCLUDED
#define CITK_SKINDATA_H_INCLUDED
 
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_VectorTrack.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
#ifndef CITK_VECTORTRACK_H_INCLUDED
#define CITK_VECTORTRACK_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTVectorTrack );
///////////////////////////////////////////////////////////////////////////////
namespace citk {
	
/////////////////////////////////////////////////////////////////////////////
class CITK_API CTVectorTrack : public CTTrack
{
	DECLARE_ALL( CTVectorTrack, CTTrack );
public:
	struct vectorkey_t : CTTrack::keyframe_t 
	{
		Vector		value;
	};
	// Track methods:
	Vector		GetValue( ctime_t t ) const;
	Vector		GetValueFast( ctime_t t, int &cache ) const;
	void		SetValue( ctime_t, const Vector& );
	// Key methods:
	Vector*			GetKeyValue( int ) const;
	virtual Vector	_Interpolate( int key, cfloat__t ) const;
	virtual Vector	_InterpolateD1( int key, cfloat__t ) const;
	virtual Vector	_InterpolateD2( int key, cfloat__t ) const;
	// Inherited from CTTrack
	virtual bool	Compare( const CTTrack* tr ) const;
	// For streaming / networking:
	virtual void	WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool	ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	virtual keyframe_t*	NewKey( keyframe_t* );
};
/////////////////////////////////////////////////////////////////////////////
inline Vector CTVectorTrack::GetValueFast( ctime_t t, int &cache ) const 
{ 
	float__t ft;
	if (FindKeyTime(t,cache,ft))
		return _Interpolate( cache, ft ); 
	else
		return *GetKeyValue( cache );
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTVectorTrack> PVectorTrack;
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_VECTORTRACK_H_INCLUDED
///////////////////////////////// [citk_VectorTrack.h] END
///////////////////////////////// [citk_QuatTrack.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_QUATTRACK_H_INCLUDED
#define CITK_QUATTRACK_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTQuatTrack );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
	
/////////////////////////////////////////////////////////////////////////////
class CITK_API CTQuatTrack : public CTTrack
{
	DECLARE_ALL( CTQuatTrack, CTTrack );
public:
	struct quatkey_t : CTTrack::keyframe_t
	{
		Quaternion		value;
	};
	// Track methods:
	Quaternion		GetValue( ctime_t t ) const { return _Interpolate(t,FindKey(t)); }
	Quaternion		GetValueFast( ctime_t t, int &cache ) const;
	void			SetValue( ctime_t, const Quaternion& );
	// Inherited from CTTrack
	virtual void	Precalc();
	virtual bool	Compare( const CTTrack* ) const;		// CONST!
	// Key methods:
	Quaternion*		GetKeyValue( int ) const;
	// For streaming / networking:
	virtual void	WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool	ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	virtual Quaternion	_Interpolate( ctime_t, int key ) const;
	virtual keyframe_t*	NewKey( keyframe_t* );
};
///////////////////////////////////////////////////////////////////////////////
inline Quaternion CTQuatTrack::GetValueFast( ctime_t t, int &cache ) const 
{ 
	return _Interpolate( t, cache = FindKeyFast(t,cache) ); 
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTQuatTrack> PQuatTrack;
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
	
/////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_QUATTRACK_H_INCLUDED
///////////////////////////////// [citk_QuatTrack.h] END
///////////////////////////////// [citk_FloatTrack.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_FLOATTRACK_H_INCLUDED
#define CITK_FLOATTRACK_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTFloatTrack );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
	
/////////////////////////////////////////////////////////////////////////////
class CITK_API CTFloatTrack : public CTTrack
{
	DECLARE_ALL( CTFloatTrack, CTTrack );
public:
	struct floatkey_t : CTTrack::keyframe_t
	{
		float__t		value;
	};
	// Track methods:
	float__t		GetValue( ctime_t ) const;
	float__t		GetValueFast( ctime_t, int &cache ) const;
	void			SetValue( ctime_t, cfloat__t );
	// Key methods:
	float__t*		GetKeyValue( int ) const;
	virtual float__t	_Interpolate( int key, cfloat__t ) const;
	virtual float__t	_InterpolateD1( int key, cfloat__t ) const;
	virtual float__t	_InterpolateD2( int key, cfloat__t ) const;
	// Inherited from CTTrack
	virtual bool		Compare( const CTTrack* tr ) const;
	// For streaming / networking:
	virtual void	WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool	ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	virtual keyframe_t*	NewKey( keyframe_t* );
};
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTFloatTrack> PFloatTrack;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
	
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_FLOATTRACK_H_INCLUDED
///////////////////////////////// [citk_FloatTrack.h] END
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTSkinData);
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTSkinData : public CTNamed
{
	DECLARE_ALL( CTSkinData, CTNamed );
public:
	struct skinvtx_t
	{
		float		weight;
		vtxid_t		vtx;
	};
	struct bonedata_t
	{
		DynString		name;
		DTransform		initial;
		int				parent;				// -1 = no parent
		bounds_t		bounds;
		// These override BLENDS/BONEID in the vertex-data
		int				vertexcount;
		skinvtx_t		*vertices;
//		PAnimation		animation;
		PVectorTrack	position;
		PQuatTrack		rotation;
		bonedata_t() : vertices(NULL) {}
		~bonedata_t() { delete [] vertices; }
	};
	CTSkinData();
	CTSkinData( const CTSkinData* );
	// Unique skin ID (for hardware caching)
	id__t		GetID() const { if (skin_id==ID_NONE) skin_id=skindata_ids.RequestID(); return skin_id; }
	// Associated vertex data (optional)
	void			SetVertexData( CTVertexData* );
	CTVertexData*	GetVertexData() const		{ return vertexdata; }
	// Iteration through all bones
	int				GetBoneCount() const		{ return bones.Count(); }
	bonedata_t*		GetBoneNo( int i ) const	{ return bones.GetNo(i); }
	// Adding new bones programmatically
	void			AddBones( bonedata_t**, int count );
	int				AddBone( int count, vtxid_t*, float* );
	// Removing bones programmatically
	void			RemoveBones()				{ bones.DeleteAll(); }
	void			RemoveBone( int i )			{ bones.DeleteNo(i); }
	// For networking, loading & saving (inherited)
	virtual void	WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool	ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	// Destructor (delete bone data; free ID)
	virtual ~CTSkinData();
	PVertexData				vertexdata;
//	DTransform				root;
	ArrayPtr<bonedata_t>	bones;
	mutable id__t	skin_id;
	static IDBroker	skindata_ids;
};
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTSkinData> PSkinData;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_SKINDATA_H_INCLUDED
///////////////////////////////// [citk_SkinData.h] END
///////////////////////////////// [citk_SkinnedGeometry.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_SKINNEDGEOMETRY_H_INCLUDED
#define CITK_SKINNEDGEOMETRY_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTSkinnedGeometry );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
// Structure containing the state of a bone (for now, only a transform)
struct boneinfo_t 
{
	DTransform			transform;
	SafePtr<CTEntity>	dummy;
};
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTSkinnedGeometry : public CTMultiMtlGeometry
{
	DECLARE_ALL( CTSkinnedGeometry, CTMultiMtlGeometry );
public:
	//! Current skinned vertex datas
	StrongArray<CTVertexData>	CurrentDatas;
	// Constructor (3 in 1)
	CTSkinnedGeometry( cstr_t name =NULL, CTGroup* parent=NULL );
	// Copy constructor
	CTSkinnedGeometry( const CTSkinnedGeometry* );
	// Conversion constructor
//	CTSkinnedGeometry( const CTGeometry*, const CTSkinData* );
	// SkinData access
	void			SetSkinData( CTSkinData* );
	CTSkinData*		GetSkinData() const { return skin; }
	// Bone access
	int				GetBoneCount() const { return bones.Count(); }
	boneinfo_t*		GetBoneNo( int i ) const { return bones.GetNo(i); }
	// Current time
	void			SetTime(ctime_t t);
	ctime_t			GetTime() const { return time; };
	void			Start();
	void			Stop();
	bool			IsRunning() const { return running; }
	bool			IsInvalid() const { return invalid; }
	void			UpdateBones();
	void			UpdateCurrentDatas();
	// Inherited:
	virtual CTEntity*	Copy() const;
	virtual CTShape*	UpdateBoundingVolume( kind_t kind =DRAW );
	virtual void		Process( ProcessInfo_t& );
	virtual bool		CheckWithRay( DTreePicker&, const Line3& );
	// For networking, loading & saving
	virtual void		WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool		ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	UPDATEFUNC			_Update( ctime_t );
	bool				_UpdateBone( int i );
	PSkinData				skin;
	ArrayPtr<boneinfo_t>	bones;
	ctime_t					time;
	bool					running;
	bool					invalid;
	int						poscache, rotcache, scalecache;
	virtual void	DoAddProperties();
	// Destructor (delete bones)
	virtual ~CTSkinnedGeometry();
};
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTSkinnedGeometry> PSkinnedGeometry;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_SKINNEDGEOMETRY_H_INCLUDED
///////////////////////////////// [citk_SkinnedGeometry.h] END
///////////////////////////////// [citk_ShaderProgram.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
#ifndef CITK_SHADERPROGRAM_H_INCLUDED
#define CITK_SHADERPROGRAM_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTShaderProgram);
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTShaderProgram : public CTStreamed
{
	DECLARE_ALL(CTShaderProgram, CTStreamed);
public:	
	enum scripttype_t
	{
		VertexProgram,
		PixelProgram,
		CGraphics,
		AutoDetect,
		Custom = 128				// custom script types start here
	};
	CTShaderProgram() : _ID(ID_NONE) {}
	id__t			GetID() const				{ return _ID; }
	id__t			RequestID() const;
	scripttype_t	GetType() const				{ return Type; }
	cstr_t			GetData() const				{ return Data; }
	bool			Load(  cstr_t fn );
	bool			SetData( cstr_t, scripttype_t = AutoDetect );
	virtual bool	_Compare( const CTShaderProgram* ) const;
	virtual size_t	GetSizeEstimate();
	
	// Inherited from CTStreamed
	virtual void	WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool	ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	scripttype_t	Type;
	DynString		Data;
	DynString		FileName;
	// Called by CTCached::Cache if the data is needed (and not yet available)
//	virtual	bool	DoCache();
	// Called by CTCached::Flush if the data should be remove from memory
//	virtual	void	DoFlush();
	mutable id__t	_ID;
	static IDBroker shader_ids;
	// Destructor (releases the ID)
	virtual ~CTShaderProgram();
};
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTShaderProgram>	PShaderProgram;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk {
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_SHADERPROGRAM_H_INCLUDED
///////////////////////////////// [citk_ShaderProgram.h] END
///////////////////////////////// [citk_ShaderProperty.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
#ifndef CITK_SHADERPROPERTY_H_INCLUDED
#define CITK_SHADERPROPERTY_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTShaderProperty);
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTShaderProperty : public CTRenderProperty
{
	DECLARE_ALL(CTShaderProperty, CTRenderProperty);
public:
	CTShaderProperty();
	CTShaderProperty( const CTShaderProperty* );
	struct param_t
	{
		float x, y, z, w;
		param_t() {}
		param_t( float a, float b, float c ) : x(a), y(b), z(c) {}
		param_t( float a, float b, float c, float d ) : x(a), y(b), z(c), w(d) {}
		explicit param_t( cvec_t v ) : x(v.x), y(v.y), z(v.z) {}
		explicit param_t( float f[4] ) : x(f[0]), y(f[1]), z(f[2]), w(f[3]) {}
		explicit param_t( const DColor& c ) : x(c.r), y(c.g), z(c.b) {}
		explicit param_t( const DColorA& c ) : x(c.r), y(c.g), z(c.b), w(c.a) {}
	};
	// Shader parameter access
	int				GetParameterCount() const		{ return _Params.Count(); }
	param_t			GetParameterNo( int i ) const	{ return _Params.GetNo(i); }
	void			SetParameterCount( int c )		{ _Params.SetCount(c); }
	param_t&		AddParameter( const param_t& );				// invalidates
	param_t&		SetParameter( int, const param_t& );		// invalidates
	param_t&		GetParameterRef( int );						// invalidates
	// Shader program access
	CTShaderProgram*	GetShaderProgram() const	{ return _Program; }
	void				SetShaderProgram( CTShaderProgram* );	// invalidates
		
	// Inherited from CTRenderProperty
	virtual CTRenderProperty* Clone() const;
	virtual bool	_Combine( const CTRenderProperty* );
	virtual bool	_Compare( const CTRenderProperty* ) const;
	// Inherited from CTStreamed
	virtual void	WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool	ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	Array<param_t,1>	_Params;		// safe to use malloc/free (faster)
	PShaderProgram		_Program;
};
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTShaderProperty> PShaderProperty;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk {
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_SHADERPROPERTY_H_INCLUDED
///////////////////////////////// [citk_ShaderProperty.h] END
///////////////////////////////// [citk_ShapeDrawer.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_SHAPEDRAWER_H_INCLUDED
#define CITK_SHAPEDRAWER_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC (CTShapeDrawer);
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citk {
//////////////////////////////////////////////////////////////////////
class CITK_API CTShapeDrawer : public CTEntity
{
	DECLARE_ALL( CTShapeDrawer, CTEntity );
public:
	// Shape to be rendered
	PShape			RenderShape;
	
	// Constructor (3 in 1)
	CTShapeDrawer( cstr_t name =NULL, CTGroup* parent=NULL );
	// Copy constructor
	CTShapeDrawer( const CTShapeDrawer* );
	// Functions to get/set the shape to be rendered
	void				SetShape( CTShape* );
	CTShape*			GetShape() const { return RenderShape; }
	/////////////////////////////////////////////////////////////////////////////
	// Inherited: 
	virtual bool		CheckWithRay( DTreePicker&, const Line3& );
	// Creates the most efficient bounding volume
	virtual CTShape*	UpdateBoundingVolume( kind_t kind =CTProcess::DRAW );
	// Calls the shape's Render method
	virtual void		Process( ProcessInfo_t &processinfo );
	// Make a copy of this drawable
	virtual CTEntity*	Copy() const;
	// For networking, loading & saving
	virtual void		WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool		ProcessChunk( CTStream* stream, chunkid_t chid );
	/////////////////////////////////////////////////////////////////////////////
protected:
	virtual void	DoAddProperties();
};
/////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTShapeDrawer> PShapeDrawer;
/////////////////////////////////////////////////////////////////////////////
} // namespace citk
//////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITK_SHAPEDRAWER_H_INCLUDED
///////////////////////////////// [citk_ShapeDrawer.h] END
///////////////////////////////// [citk_Sphere.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_SPHERE_H_INCLUDED
#define CITK_SPHERE_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTSphere );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTSphere : public CTShape
{
	DECLARE_ALL( CTSphere, CTShape );
public:
	enum {
		DEF_RENDERQUALITY = 2
	};
	// Constructor
	CTSphere( cfloat__t = 0.5f METER );
	// Copy constructor
	CTSphere( const CTSphere* );
	CTSphere( const CTBox* );			// conversion
	virtual CTShape*	Copy() const;
	
	// Sphere specific methods
	inline float__t		GetRadius() const { return radius; }
	void				SetRadius( cfloat__t );
	void				SetRenderQuality( int );
	void				FromVectors( const Vector*, int count );
	// Inherited methods
	virtual double		CalcVolume();
	virtual double		CalcArea();
	virtual bool		IsConvex() const { return true; }
	virtual void		Render( const RenderInfo_t& );
	// Collision detection helpers
	virtual Normal		GetNormal( cvec_t );
	virtual Vector		GetSupport( cvec_t );
	virtual double		GetMaxY( cvec_t );
	virtual Vector		GetClosestPoint( cvec_t );
	virtual intersect_t	CheckWithHalfspace( const Plane3&, const DTransform* =NULL );
	virtual intersect_t	CheckWithPoint( cvec_t, const DTransform* =NULL );
	virtual intersect_t	CheckWithLine( const Line3&, const DTransform* =NULL );
	virtual intersect_t	CheckWithRay( const Line3&, float__t &current_t, const DTransform* =NULL );
	virtual intersect_t	CheckAgainstFrustum( const DFrustum &, const DTransform* =NULL, flags_t* clipplanes=NULL);
	virtual CTSphere*	GetBoundingSphere();
	virtual CTBox*		GetBoundingBox();
	virtual CTShape*	GetBoundingVolume();
	// For networking, loading & saving
	virtual void		WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool		ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	PVertexData		_VertexData;
	int				quality;
	float__t		radius, radius2;
	void			_UpdateVectors();
	void			_UpdateVertexData();
	// Inherited:
	virtual void	UpdateCWMatrix();
	virtual void	DoAddProperties();
	virtual void	OnPropertyChanged( DProperty& );
};
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTSphere> PSphere;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_SPHERE_H_INCLUDED
///////////////////////////////// [citk_Sphere.h] END
///////////////////////////////// [citk_SoundSource.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_SOUNDSOURCE_H_INCLUDED
#define CITK_SOUNDSOURCE_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_SoundBuffer.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_SOUNDBUFFER_H_INCLUDED
#define CITK_SOUNDBUFFER_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_SoundWave.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_SOUNDWAVE_H_INCLUDED
#define CITK_SOUNDWAVE_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTSoundWave );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
	
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTSoundWave : public CTCached
{
	DECLARE_ALL( CTSoundWave, CTCached );
public:
	virtual bool	SetSource( cstr_t ) { return false; }	// For files: Open / Close with filename / NULL
	virtual int		GetNumChannels() = 0;					// Number of channels (1 or 2)
	virtual int		GetSampleRate() = 0;					// Sampled frequency
	virtual int		GetSampleResolution() = 0;				// Bits per sample
	virtual ctime_t	GetTimeEstimate() = 0;
	virtual int		GetBytesPerSample() = 0;
	virtual int		GetBytesPerSecond() = 0;
	// Raw PCM interface: May return NULL and 0 if not applicable
	virtual void*	GetPCMData() { return NULL; }
	virtual long	GetPCMDataSize() { return 0; }
	// Streaming interfaces
	virtual bool	StreamedIsAvailable() { return false; }
	virtual size_t	StreamedCopyBuffer( void* buffer, size_t buffersize, int& index ) { return 0; }
	virtual bool	StreamedSeekTo ( ctime_t AbsoluteTime, int& index ) { return false; }
	virtual bool	StreamedSeekBy ( ctime_t RelativeTime, int& index ) { return false; }
	virtual ctime_t	StreamedGetPosition ( int& index ) { return 0; }
	// (Un)Register with the SoundManager
	virtual bool DoRegisterWithService();
	virtual bool DoUnregisterWithService();
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTSoundWave> PSoundWave;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
	
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_SOUNDWAVE_H_INCLUDED
///////////////////////////////// [citk_SoundWave.h] END
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
#define SBF_UPD_POSITION	0x00000001
#define SBF_UPD_WAVE		0x00000002
#define SBF_UPD_MINDIST		0x00000004
#define SBF_UPD_MAXDIST		0x00000008
#define SBF_UPD_DOPPLER		0x00000020
#define SBF_UPD_LOOPED		0x00000040
#define SBF_UPD_ENTITY		0x00000100
//////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CTEntity;
///////////////////////////////////////////////////////////////////////////////
class CITK_API DSoundBuffer
{
public:
	ctime_t			GetPosition() const { return Position; }		// Current position in wave
	void			SetPosition( ctime_t );	// Set current position in wave
	void			IncreasePosition( ctime_t ); // Increase current position in wave: NO INVALIDATE, no clipping
	PSoundWave		Wave;					// Source of wave data
	bool			Looped, Priority;
	SafePtr<CTEntity> Entity;				// World position/direction/speed e.d.
	PRenderState	RenderState;			// For additional fx (pitch, speed, vol, EAX...
	// Default constructor
	DSoundBuffer();
			  
	// Deconstructor
	~DSoundBuffer();
	// Associate this soundbuffer with a wave
	bool			SetWave( CTSoundWave* );
	// SoundID methods
	id__t			GetID() const { return SoundID; }
	id__t			RequestID();
	bool			HasChangedSince( frameid_t tijd ) const { return ((long)(tijd-FrameID_Changed))<0; }
	bool			HasPositionChangedSince( frameid_t tijd ) const { return ((long)(tijd-FrameID_PosChanged))<0; }
	void			Invalidate();
private:
	id__t			SoundID;
	frameid_t		FrameID_Changed;				// Last changed
	frameid_t		FrameID_PosChanged;				// Last pos changed
	ctime_t			Position;						// Current position in wave
};
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_SOUNDBUFFER_H_INCLUDED
///////////////////////////////// [citk_SoundBuffer.h] END
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTSoundSource );
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
namespace citk {
//////////////////////////////////////////////////////////////////////
class CTBasicSoundProperty;
class CT3DSoundProperty;
//////////////////////////////////////////////////////////////////////
/*! \class CTSoundSource
*	\brief A sound source entity
*	\author Crystal InterTechnology
*	lionello.lunescu@crystalinter.com
*   \n Company URL: http://www.crystalinter.com
*	\version 1.0
*	\date    2002
*/
class CITK_API CTSoundSource : public CTEntity
{
	DECLARE_ALL( CTSoundSource, CTEntity );
public:
	
	CTSoundSource( cstr_t =NULL, CTGroup* =NULL );	//!<Constructor (3 in 1)
	
	CTSoundSource( const CTSoundSource* );			//!< Copy constructor
	/*! \name Sound setup: */
	//@{
	bool		Load( cstr_t filename );
	bool		SetWave( CTSoundWave* );
	void		Play( bool cont =false );
	void		Stop();
	//@}
	/*! \name SoundBuffer setup:*/
	//@{
	void		SetDopplerFactor( float__t factor );
	void		EnableLooping( bool loop_it =true );
	void		SetMinDist( cfloat__t dist_in_units );
	void		SetMaxDist( cfloat__t dist_in_units );
	void		SetPitch( cfloat__t freq_multiplier );
	void		SetSpeed( cfloat__t speed_multiplier );
	void		SetVolume( cfloat__t neg_att_in_dB );
	void		SetPosition( ctime_t pos );			//!< Set the wave position (miliseconds)
	//@}
	
	void		Set3D( bool _3d=true );
	
	CTBasicSoundProperty*	GetBasicSoundProperty();//!<Utility: Get/create BasicSoundPropery
	CT3DSoundProperty*		Get3DSoundProperty();	//!<Utility: Get/create 3DSoundPropery
	
	/*! \name  Inherited:*/
	//@{
	virtual CTShape*	UpdateBoundingVolume( kind_t kind =CTProcess::SOUND );
	virtual void		Process( ProcessInfo_t& );
	//@}
	/*! \name For networking, loading & saving */
	//@{
	virtual void		WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool		ProcessChunk( CTStream* stream, chunkid_t chid );
	//@}
private:
	String			FileName;					//!< Current filename (for streaming)
	DSoundBuffer	SoundBuffer;				//!< This buffer contain the wave data
	bool			Playing;					//!< Current state of the sound source (Stop/Play)
	UPDATEFUNC		DoPlaying( ctime_t );
};
//////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTSoundSource> PSoundSource;
//////////////////////////////////////////////////////////////////////
} // namespace citk
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
#endif // !CITK_SOUNDSOURCE_H_INCLUDED
///////////////////////////////// [citk_SoundSource.h] END
///////////////////////////////// [citk_StaticEnvironment.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_STATICENVIRONMENT_H_INCLUDED
#define CITK_STATICENVIRONMENT_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC (CTStaticEnvironment);
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
namespace citk {
//////////////////////////////////////////////////////////////////////
#define DEF_TEMPERATURE		293.0
#define DEF_PRESSURE		1.01
///////////////////////////////////////////////////////////////////////////////////////
class CITK_API CTStaticEnvironment : public CTEnvironment
{
	DECLARE_ALL(CTStaticEnvironment, CTEnvironment);
public:
	// Constructor (3 in 1)
	CTStaticEnvironment( cstr_t name =NULL, CTGroup* parent =NULL );
	// Properties
	float__t		FogDensity, FogRange;
	Color32		FogColor;
	fogtype_t	FogType;
	float__t		Density;
	float__t		Viscosity;
	Vector		Gravity;
	bool		Has_Gravity;
	Vector		Wind;
	bool		Has_Wind;
	DColor		AmbientLight;
	// Methods
	void		SetFogType( fogtype_t );
	void		SetFogRange( cfloat__t );
	void		SetFogDensity( cfloat__t );
	void		SetFogColor( const Color32& );
	void		SetViscosity( cfloat__t );
	void		SetDensityAsGas( cfloat__t mol_mass_of_gas, cfloat__t pressure_in_bar=DEF_PRESSURE, cfloat__t temp_in_k =DEF_TEMPERATURE);
	void		SetWind( cvec_t );
	void		SetGravity( cvec_t );
	void		SetAmbientLight( const DColor& );
	// Inherited from CTEnvironment
	fogtype_t	GetFogType() { return FogType; }
	float__t		GetFogRange( const Vector *worldpos =NULL ) { return FogRange; }
	float__t		GetFogDensity( const Vector *worldpos =NULL ) { return FogDensity; }
	Color32		GetFogColor( const Vector *worldpos =NULL ) { return FogColor; }
	float__t		GetDensity( const Vector *worldpos =NULL ) { return Density; }
	float__t		GetViscosity( const Vector *worldpos =NULL ) { return Viscosity; }
	Vector		GetGravity( const Vector *worldpos =NULL ) { return Gravity; }
	bool		HasGravity() { return Has_Gravity; }
	Vector		GetWind( const Vector *worldpos =NULL ) { return Wind; }
	bool		HasWind() { return Has_Wind; }
	DColor		GetAmbientLight( const Vector *worldpos =NULL ) { return AmbientLight; }
	// For networking, loading & saving (inherited)
	virtual void	WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool	ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	virtual void	DoAddProperties();
};
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTStaticEnvironment> PStaticEnvironment;
///////////////////////////////////////////////////////////////////////////////////////
} // namespace citk
//////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
#endif // !CITK_ENVIRONMENT_H_INCLUDED
///////////////////////////////// [citk_StaticEnvironment.h] END
///////////////////////////////// [citk_TreeClassIterator.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef TREECLASSITERATOR_H_INCLUDED
#define TREECLASSITERATOR_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
class CTEntity;
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
template <class EntType>
class DTreeClassIterator
{
public:
	ArrayPtr<EntType>	Found;
	// Constructors
	DTreeClassIterator()					{ }
	DTreeClassIterator( CTEntity* r )		{ Iterate(r); }
	// Resets the list. Use this to start new search.
	void		Reset()						{ Found.Empty(); }
	// Won't Automatically reset: Just adds to list.
	// Won't check for duplicates, but these can only be there if the USER calls Iterate more than once.
	int			Iterate( CTEntity* Root );
	int			GetFoundCount()	const		{ return Found.Count(); }
	EntType*	GetFoundNo( int i )	const	{ return Found(i); }
	// Remove all found entities from the tree
	// NOTE: this is not safe when removing CTGroup's (see below)
	void		RemoveFromWorld();
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// Won't Automatically reset: Just adds to list.
// Won't check for duplicates, but these can only be there if the USER calls Iterate more than once.
template <class EntType>
int DTreeClassIterator<EntType>::Iterate( CTEntity* Root )
{
	int c = 0;
	EntType* et = citk_cast<EntType>(Root);
	if (et)
	{
		Found.Add(et);
		c++;
	}
	CTGroup* g = citk_cast<CTGroup>(Root);
	if (g)
		for (int q=0;q<g->GetChildCount();q++)
			c+=Iterate(g->GetChildNo(q));
	return c;
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
template <class EntType>
void DTreeClassIterator<EntType>::RemoveFromWorld()
{
	// NOTE: this is not safe when removing CTGroup's, since
	// they might get released when remove from world, in which
	// case they will take their children down with them.
	for (int t=0;t<Found.Count();t++)
		if (Found[t])
			Found[t]->RemoveFromWorld();
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !TREECLASSITERATOR_INCLUDED
///////////////////////////////// [citk_TreeClassIterator.h] END
///////////////////////////////// [citk_TreeNameCache.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_TREENAMECACHE_H_INCLUDED
#define CITK_TREENAMECACHE_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_SafeArray.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef	CITK_SAFEARRAY_H_INCLUDED
#define	CITK_SAFEARRAY_H_INCLUDED
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////
template <class T>
class SafeArray : public CTBasic, public ArrayPtr<T>
{
public:
	typedef T*		PT;								// pointer to pointer typedef
	
	// Constructors:
	SafeArray() { }
	SafeArray( const PT *data, size_t data_size ) { AddFrom(data,data_size); }
	SafeArray( const ArrayPtr<T> &ar ) { AddFrom(ar); }
	SafeArray( const SafeArray<T> &ar ) { AddFrom(ar); }
	// Destructor:
	~SafeArray() { if (Data) RemoveAll(); }
	// Methods:
	size_t		FindAndReplaceFrom( PT const, PT const, size_t );
	size_t		FindAndReplace( PT const d, PT const r ) { return FindAndReplaceFrom(d,r,0); }
	size_t		Push( PT const a ) { return Add(a); }
	PT			Pop() { PT p=NULL; assert(NumItems); if (NumItems) p=Data[--NumItems]; if (p) p->RemoveSubscriber(this); return p; }
	size_t		Add( PT const );
//	PT			AddNew();						// NO: would have no reference
	bool		AddUnique( PT const );
	PT			Remove( PT const );				// these can change the order
	PT			RemoveNo( size_t );			// these can change the order
	void		RemoveAll();
	void		RemoveEvery( PT const );		// removes every occurence of ...
	PT			SetNo( size_t, PT const );	// checks the input + grows
	size_t		SetCount( size_t n );
	void		Empty();
	const PT*	Lock() { return ArrayPtr<T>::Lock(); }
	const PT*	GetData() const { return ArrayPtr<T>::GetData(); }
	void		AddFrom( const PT *data, size_t count );
	void		CopyFrom( const PT *data, size_t count ) { Empty(); AddFrom(data,count); }
	void		AddFrom( const ArrayPtr<T> &ar )	{ AddFrom(ar.GetData(),ar.Count()); }
	void		CopyFrom( const ArrayPtr<T> &ar )	{ Empty(); AddFrom(ar); }
	bool		AddUniqueID( PT, int& );
	bool		RemoveUniqueID( PT, int& );
	// Overloaded operators:
	void		operator = ( const SafeArray<T> &av )	{ CopyFrom(av); }
				operator const PT* () const				{ return Data; }
	// OnDelete is called before an object is deleted
	virtual void	OnDelete( CTAggregated *a );
private:
	// The following methods are hidden; we use reference counting
				operator PT* () const;			// not implemented
	bool		Delete( PT const );
	bool		DeleteNo( size_t );
	void		DeleteAll();
};
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T>
size_t SafeArray<T>::Add( T* const d )
{
	if (NumItems >= MaxItems)
		_Larger();
	Data[NumItems] = d;
	if (d) d->AddSubscriber(this);						// add a reference
	return NumItems++;
}
///////////////////////////////////////////////////////////////////////
template <class T>
bool SafeArray<T>::AddUnique( T* const d )
{
	int i = Find(d);
	return i==INVALID_ITEM?(Add(d),true):false;
}
///////////////////////////////////////////////////////////////////////
/*
template <class T>
T* SafeArray<T>::AddNew()
{
	// Create a new instance; use ClassDesc if trustworthy, 'new' otherwise
	PT p = sizeof(T)!=T::_CD()->GetSize()?new T:(T*)T::_CD()->Create();
	Add( p );
	return p;
}
*/
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T>
size_t SafeArray<T>::SetCount( size_t nn )
{ 
	if (nn>MaxItems) Reserve(nn); 
	size_t t;
	// Set new items to NULL
	for (t=NumItems; t<nn; ++t)
		Data[t] = NULL;
	// Remove references
	for (t=nn; t<NumItems; ++t)
		if (Data[t])
			Data[t]->RemoveSubscriber(this);
	return NumItems = nn; 
}
///////////////////////////////////////////////////////////////////////
template <class T>
void SafeArray<T>::Empty()
{ 
	// Use this way so that DURING emptying, when this array is accessed only the items still referenced are accessible.
	while (NumItems>0)
	{
		NumItems--;
		if (Data[NumItems])
			Data[NumItems]->RemoveSubscriber(this);
	}
	// This way may cause problems when objects removed somehow during deletion access this array and encounter deleted objects
/*	// Remove all references
	for (int t=0;t<NumItems;t++)
		if (Data[t]) 
			Data[t]->RemoveSubscriber(this);
	NumItems = 0;*/
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T>
T* SafeArray<T>::Remove( T* const d )
{
	for (size_t t=0; t<NumItems; t++)
		if (Data[t] == d)
			return RemoveNo(t);
	return NULL;
}
///////////////////////////////////////////////////////////////////////
template <class T>
void SafeArray<T>::RemoveEvery( T* const d )
{
	size_t last=0;
	for (size_t t=0;t<NumItems;t++)	// Remove obsolete entries
	{
		if (Data[t]!=d)
		{
			if (last!=t)
				Data[last] = Data[t];
			last++;
		}
		else
		if (d)
			d->RemoveSubscriber(this);			// Remove reference
	}
	NumItems = last;
}
///////////////////////////////////////////////////////////////////////
template <class T>
T* SafeArray<T>::RemoveNo( size_t i )
{
	if (!ContainsNo(i))
		return NULL;
	PT d = Data[i];
	NumItems--;
	if (NumItems != i)
		Data[i] = Data[NumItems];
#ifdef ARRAY_AUTO_SMALLER
	if (MaxItems > NumItems+Delta)		// >=
		_Smaller();
#endif // ARRAY_AUTO_SMALLER
	d->RemoveSubscriber(this);
	return d;
}
///////////////////////////////////////////////////////////////////////
template <class T>
void SafeArray<T>::RemoveAll()
{
	// Removes references
	Empty();							
	// Remove array
	_delete( Data );
	Data = NULL;
	MaxItems = 0;
}
///////////////////////////////////////////////////////////////////////
template <class T>
T* SafeArray<T>::SetNo( size_t i, PT const d )
{
	if (i<0)
		return NULL;
	if (i>=MaxItems)
		Reserve(i+Delta);				// i+1
	for (;NumItems<=i;NumItems++)		// Fill the array up with NULL's
		Data[NumItems] = NULL;
	if (Data[i]!=d)
	{
		if (Data[i])
			Data[i]->RemoveSubscriber(this);		// Remove reference
		Data[i] = d;
		if (d) d->AddSubscriber(this);				// Add reference
	}
	return d;
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T>
size_t SafeArray<T>::FindAndReplaceFrom( PT const p1, PT const p2, size_t f )
{
	if (p1==p2)
		return 0;
	size_t c=0;
	int i=f;
	while (1)
	{
		i = FindFrom(p1,i);
		if (i==INVALID_ITEM)
			break;
		c++;
		if (Data[i]) Data[i]->RemoveSubscriber(this);	// Remove old reference
		Data[i++] = p2;
		if (p2) p2->AddSubscriber(this);				// ... and add new reference
	}
	return c;
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T>
void SafeArray<T>::AddFrom( const PT *data, size_t count )
{
	size_t ni = NumItems;
	SetCount( NumItems + count );
	// Copy data
	memcpy( (void*)&Data[ni], (void*)data, sizeof(PT)*count );
	// Add references
	for (size_t t=0;t<count;t++)
		if (data[t]) data[t]->AddSubscriber(this);
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
template <class T>
bool SafeArray<T>::AddUniqueID( PT obj, int &ID )
{
	if (ID!=INVALID_ITEM)
	{
		THIS_ASSERT(GetNo(ID)==obj," Invalid ID");
		return false;
	}
	size_t iter = 0;
	// Search for first empty ID
	for (;iter<NumItems;iter++)
		if (!Data[iter])
			break;
	// Add to list
	SetNo(iter,obj);
	// Set ID
	ID = iter;
	return true;
}
///////////////////////////////////////////////////////////////////////////////
template <class T>
bool SafeArray<T>::RemoveUniqueID( PT obj, int &ID )
{
	if (ID==INVALID_ITEM)
		return false;
	// Cross check with list
	if (GetNo(ID)!=obj)
	{
		THIS_ASSERT(0," Invalid ID");
		return false;
	}
	// Remove from list
	SetNo( ID, NULL );
	// Remove ID
	ID = INVALID_ITEM;
	return true;
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T>
void SafeArray<T>::OnDelete( CTAggregated *a ) 
{ 
	// We could do this, but we don't have to unsubscribe (faster)
	bool found = false;
	for (size_t t=0; t<NumItems; t++)
		if (Data[t] == static_cast<T*>(a))
		{
			Data[t] = Data[--NumItems];
			found = true;
			// No need to unsubscribe
			// NO BREAK: OnDelete is only called once for each subscriber
			t--;	// redo [t]
		}
	assert(found);		// must have been in the array
	// We should call inherited, but we know it's a no-op
//	inherited::OnDelete(a);
}
///////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
#endif // !CITK_SAFEARRAY_H_INCLUDED
///////////////////////////////// [citk_SafeArray.h] END
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
class CTEntity;
///////////////////////////////////////////////////////////////////////////////
struct CITK_API DTreeNameCache
{
	// Named entities (aliases) (accessed by CRC32)
	struct entities_t 
	{
		long				tag;				// whatever you want it to be
		SafeArray<CTEntity>	entities;
		entities_t() : tag(0) {}
	};
	DHashTable<entities_t> table;
	//! Destructor; frees all memory
	~DTreeNameCache();
	//! Find a cache entry; returns NULL if not found
	entities_t*		Find( cstr_t name );
	//! Find a cache entry or recurse through the tree
	entities_t*		FindOrRecurse( cstr_t name, CTEntity* );
	//! Add an entity and its alias
	entities_t*		AddAlias( cstr_t, CTEntity* );
	//! Remove all occurences of the entity from the cache
	void			Remove( CTEntity* );			
	//! Remove entity and children from the cache
	void			RemoveTree( CTEntity* );			
	//! Remove an cache entry by its name
	void			Flush( cstr_t );			
	//! Flush the cache
	void			FlushAll();
	//! Recurse from an entity through the tree and adds all matches
	static int		Recurse( cstr_t name, CTEntity*, ArrayPtr<CTEntity>& );
};
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_TREENAMECACHE_H_INCLUDED
///////////////////////////////// [citk_TreeNameCache.h] END
///////////////////////////////// [citk_TreePicker.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_TREEPICKER_H_INCLUDED
#define CITK_TREEPICKER_H_INCLUDED
 
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
// Forward:
class CTDrawable;
	
///////////////////////////////////////////////////////////////////////////////
class CITK_API DTreePicker
{
public:
	bool		Hidden;						// also check hidden entities (false)
	bool		CheckBVs;					// check bounding volumes first (true)
	bool		FirstHit;					// stop on first hit (false)
	bool		UpdateWorldSpace;			// update world positions (true)
	bool		AllLOD;						// test all LODs (false: only active LOD)
	SafePtr<CTVertexData>	PickedVD;		// picked vertex data
	SafePtr<CTRenderState>	PickedRS;		// picked render state
	int						PickedFace[3];	// picked face (vector indices)
	static bool	Culling;					// FIXME
	// Constructor
	DTreePicker();
	//! Test the objects in a scene against a (world) line.
	CTEntity*		Pick( const Line3&, CTEntity *scene, float__t *distance =NULL );
	//! Called by entities when they intersect the current line.
	bool			SetPick( CTEntity*, cfloat__t dist );
	//! Static method to test a line against a vertex data (optional transform)
	static intersect_t CheckWithRay( const CTVertexData *vd,
		const Line3& L, float__t &current_t, const DTransform *T =NULL, int* face =NULL );
protected:
	CTEntity*		Object;
	float__t		Distance;
	void			_Pick( const Line3&, CTGroup* );		// not used
};
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_TREEPICKER_H_INCLUDED
///////////////////////////////// [citk_TreePicker.h] END
///////////////////////////////// [citk_VDFiller.h]
//  Copyright (C) 1998-2003 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_DVERTEXDATAFILLER_H_INCLUDED
#define CITK_DVERTEXDATAFILLER_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
class CITK_API DVertexDataFiller
{
public:
	DVertexDataFiller();
	PVertexData	vd; // Do not change between Start and End
	void		Initialize(); // if ! vd, it will create one
	void		ReserveVertices( int n );
	void		ReserveIndices( int n );
	// Shared Vertex mode
	int			AllocVector( int n ); // Make room for n extra vertices, return index to first (= old numVert), increases numVer
	int			AddVertex( cvec_t v ); // returns vertex no so manually color, texcoors can be set
	int			AddVertex( cvec_t v, const DColorA& col ); // returns vertex no so manually texcoors can be set
	int			AllocIndex( int n ); // returns idx to first
	// Finalizes
	void		Finalize();
	// Render (will finalize())
	bool		CanRender();
	bool		Render( const RenderInfo_t& );
protected: // but should not touch
	bool		finalized;
	int			numIndex;
	int			numVector;
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
class CITK_API DTriFiller : public DVertexDataFiller
{
public:
	void		AddTri( int i1, int i2, int i3 );
	// return first added vertex_index
	int			AddTri( cvec_t i1, cvec_t i2, cvec_t i3 );
	int			AddTri( cvec_t i1, cvec_t i2, cvec_t i3, const DColorA& col );
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
class CITK_API DQuadFiller : public DVertexDataFiller
{
public:
	void		AddQuad( int i1, int i2, int i3, int i4 );
	// return first added vertex_index
	int			AddQuad( cvec_t i1, cvec_t i2, cvec_t i3, cvec_t i4 );
	int			AddQuad( cvec_t i1, cvec_t i2, cvec_t i3, cvec_t i4, const DColorA& col );
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
class CITK_API DLinesFiller : public DVertexDataFiller // separate line pieces
{
public:
	void		AddLine( int i1, int i2 );
	int			AddLine( cvec_t p1, cvec_t p2 );
	int			AddLine( cvec_t p1, cvec_t p2, const DColorA& col );
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
class CITK_API DLineFiller : public DVertexDataFiller // one long line
{
public:
	int			AddPoint( int i );
	int			AddPoint( cvec_t p ); // first is startpoint
	int			AddPoint( cvec_t p, const DColorA& col ); // first is startpoint
	int			CloseCircle(); // adds first vec OR index (latter preferred if it has indices)
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
class CITK_API DPointFiller : public DVertexDataFiller
{
public:
	int			AddVertex( cvec_t v ); // just calls inherited and sets geomtype!
	int			AddVertex( cvec_t v, const DColorA& col ); // returns vertex no so manually texcoors can be set
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITK_DVertexDataFiller_H_INCLUDED
///////////////////////////////// [citk_VDFiller.h] END
///////////////////////////////// [citk_KeyFrameController.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_KEYFRAMECONTROLLER_H_INCLUDED
#define CITK_KEYFRAMECONTROLLER_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTKeyFrameController );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTKeyFrameController : public CTTimedEntityController
{
	DECLARE_ALL( CTKeyFrameController, CTTimedEntityController );
public:
	CTKeyFrameController();
	CTKeyFrameController( const CTKeyFrameController* );
	CTVectorTrack*	GetPositionTrack() const { return Position; }
	CTQuatTrack*	GetRotationTrack() const { return Rotation; }
	CTFloatTrack*	GetScalingTrack() const { return Scaling; }
	void			SetPositionTrack( CTVectorTrack* );
	void			SetRotationTrack( CTQuatTrack* );
	void			SetScalingTrack( CTFloatTrack* );
	// Inherited from CTEntityController:
	virtual CTEntityController*	Copy() const;
	// Reset the controller to its initial state
	virtual void	Reset();
	// For streaming / networking:
	virtual void	WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool	ProcessChunk( CTStream* stream, chunkid_t chid );
private:
	// The tracks
	PVectorTrack	Position;
	PQuatTrack		Rotation;
	PFloatTrack		Scaling;
	// Key caches for faster look-up
	int				poscache, rotcache, scalecache;
	virtual bool	DoEnable();
	virtual void	DoDisable();
	virtual void	DoAddProperties();
	//! Inherited from CTTimedEntityController, updates entity's transform
	virtual	void	_UpdateEntity( ctime_t );
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTKeyFrameController> PKeyFrameController ;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_KEYFRAMECONTROLLER_H_INCLUDED
///////////////////////////////// [citk_KeyFrameController.h] END
///////////////////////////////// [citk_LookAtController.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_LOOKATCONTROLLER_H_INCLUDED
#define CITK_LOOKATCONTROLLER_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTLookAtController );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTLookAtController : public CTEntityController
{
	DECLARE_ALL( CTLookAtController, CTEntityController );
public:
	CTLookAtController();
	CTLookAtController( const CTLookAtController* );
	void		SetLookAt( CTEntity* );
	CTEntity*	GetLookAt() const { return LookAt; }
	// Inherited from CTEntityController:
	virtual CTEntityController*	Copy() const;
	// For streaming / networking:
	virtual void	WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool	ProcessChunk( CTStream* stream, chunkid_t chid );
private:
	SafePtr<CTEntity>	LookAt;
	UPDATEFUNC	MyUpdate( ctime_t );
	virtual bool	DoEnable();
	virtual void	DoDisable();
};
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTLookAtController> PLookAtController;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_LOOKATCONTROLLER_H_INCLUDED
///////////////////////////////// [citk_LookAtController.h] END
///////////////////////////////// [citk_MotionController.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_MOTIONCONTROLLER_H_INCLUDED
#define CITK_MOTIONCONTROLLER_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTMotionController );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTMotionController : public CTEntityController
{
	DECLARE_ALL( CTMotionController, CTEntityController );
public:
	MotionInfo_t	MotionInfo;
	CTMotionController();
	CTMotionController( const CTMotionController* );
	// Inherited from CTEntityController:
	virtual CTEntityController*	Copy() const;
	virtual MotionInfo_t*	GetMotionInfoSource();
	// For streaming / networking:
	virtual void	WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool	ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	virtual void	DoAddProperties();
	virtual bool	DoEnable();
	virtual void	DoDisable();
private:
	UPDATEFUNC		MotionUpdate( ctime_t );
};
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTMotionController> PMotionController;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_MOTIONCONTROLLER_H_INCLUDED
///////////////////////////////// [citk_MotionController.h] END
///////////////////////////////// [citk_PathController.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_PATHCONTROLLER_H_INCLUDED
#define CITK_PATHCONTROLLER_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTPathController );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTPathController : public CTTimedEntityController
{
	DECLARE_ALL( CTPathController, CTTimedEntityController );
public:
	enum axis_t {
		X, Y, Z
	};
	//! Follow-mode of the path controller (defaults to PZ)
	CTPathController();
	CTPathController( const CTPathController* );
	CTVectorTrack*	GetPath() const { return Path; }
	CTFloatTrack*	GetWaypoints() const { return Waypoints; }
	CTFloatTrack*	GetScalingTrack() const { return Scaling; }
	
	void			SetPath( CTVectorTrack* );
	void			SetWaypoints( CTFloatTrack* );
	void			SetScalingTrack( CTFloatTrack* );
	void			SetFollow( bool =true );
	bool			GetFollow() const { return follow; }
	bool			SetBankAmount( cfloat__t );
	float__t		GetBankAmount() const { return banking; }
	void			SetFollowAxis( axis_t );
	axis_t			GetFollowAxis() const { return followaxis; }
	void			SetFollowFlip( bool =true );
	bool			GetFollowFlip() const { return followflip; }
	//! Inherited from CTEntityController:
	virtual CTEntityController*	Copy() const;
	//! Reset the controller to its initial state
	virtual void	Reset();
	// For streaming / networking:
	virtual void	WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool	ProcessChunk( CTStream* stream, chunkid_t chid );
private:
	// The tracks
	PVectorTrack	Path;
	PFloatTrack		Waypoints;
	PFloatTrack		Scaling;
	bool			follow, followflip;
	axis_t			followaxis;					// default to Z
	float__t		banking;
	//! Key caches for faster look-up
	int				pathcache, waycache, scalecache;
	virtual bool	DoEnable();
	virtual void	DoDisable();
	virtual void	DoAddProperties();
	//! Inherited from CTTimedEntityController, updates entity's transform
	virtual	void	_UpdateEntity( ctime_t );
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTPathController> PPathController ;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_PATHCONTROLLER_H_INCLUDED
///////////////////////////////// [citk_PathController.h] END
///////////////////////////////// [citk_WireFrameProperty.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_WIREFRAMEPROPERTY_H_INCLUDED
#define CITK_WIREFRAMEPROPERTY_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTWireFrameProperty);
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTWireFrameProperty : public CTRenderProperty
{
	DECLARE_ALL( CTWireFrameProperty, CTRenderProperty );
public:
	CTWireFrameProperty();
	CTWireFrameProperty( const CTWireFrameProperty* );
	DColorA		Color;
	float__t	Width;
	void		SetColor( const DColor &c ) { Color = c; Invalidate(); }
	void		SetColor( const DColorA &ca ) { Color = ca; Invalidate(); }
	const DColorA&	GetColor() const { return Color; }
	void		SetAlpha( cfloat__t a ) { Color.a = a; Invalidate(); }
	cfloat__t	GetAlpha() const { return Color.a; }
	void		SetWidth( cfloat__t w ) { Width = w; Invalidate(); }
	cfloat__t	GetWidth() const { return Width; }
	// Inherited from CTRenderProperty:
	virtual CTRenderProperty* Clone() const;
	virtual bool	_Combine( const CTRenderProperty* );
	virtual bool	_Compare( const CTRenderProperty* ) const;
	// For networking, loading & saving (inherited from CTStreamed)
	virtual void	WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool	ProcessChunk( CTStream* stream, chunkid_t chid );
};
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTWireFrameProperty> PWireFrameProperty;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_WIREFRAMEPROPERTY_H_INCLUDED
///////////////////////////////// [citk_WireFrameProperty.h] END
///////////////////////////////// [citk_LightingProperty.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_LIGHTINGPROPERTY_H_INCLUDED
#define CITK_LIGHTINGPROPERTY_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTLightingProperty);
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
// forward declarations:
class CTLight;
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTLightingProperty : public CTRenderProperty
{
	DECLARE_ALL( CTLightingProperty, CTRenderProperty );
public:
	CTLightingProperty();
	CTLightingProperty( const CTLightingProperty* );
	
	bool		AttachLight( CTLight* );
	bool		DetachLight( CTLight* );
	void		DetachAllLights();
	// Switch to exclude list (defaults to include list)
	void		SetExcludeList( bool excl =true );
	bool		IsExcludeList() const { return exclude; }
	// Light iteration
	int			GetLightCount() const { return Lights.Count(); }
	CTLight*	GetLightNo( int i ) const { return Lights.GetNo(i); }
	// Inherited:
	virtual CTRenderProperty* Clone() const;	// CONST!
	// Method for combining two properties (no class check!)
	virtual bool	_Combine( const CTRenderProperty* );
	virtual bool	_Compare( const CTRenderProperty* ) const;
	// For networking, loading & saving (inherited)
	virtual void	WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool	ProcessChunk( CTStream* stream, chunkid_t chid );
	// Notification for deleted lights:
	virtual	void	OnDelete( CTAggregated* );
protected:
	bool				exclude;
	ArrayPtr<CTLight>	Lights;
	// Destructor (empties light list)
	virtual ~CTLightingProperty();
};
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTLightingProperty> PLightingProperty;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_LIGHTINGPROPERTY_H_INCLUDED
///////////////////////////////// [citk_LightingProperty.h] END
///////////////////////////////// [citk_AlphaProperty.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_ALPHAPROPERTY_H_INCLUDED
#define CITK_ALPHAPROPERTY_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTAlphaProperty);
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citk {
/////////////////////////////////////////////////////////////////////////////
class CITK_API CTAlphaProperty : public CTRenderProperty
{
	DECLARE_ALL( CTAlphaProperty, CTRenderProperty );
public:
	enum alphafactor_t
	{
        Zero = 0,
        One  = 1,
        SrcColor		= 0x0300,	// these are actual GL/XBox constants
        InvSrcColor		= 0x0301,
        SrcAlpha		= 0x0302,
		InvSrcAlpha		= 0x0303,
        DestColor		= 0x0306,
        InvDestColor	= 0x0307,
        DestAlpha		= 0x0304,
        InvDestAlpha	= 0x0305,
		SrcAlphaSaturate= 0x0308
	};
	CTAlphaProperty();
	CTAlphaProperty(const CTAlphaProperty*);
	// Source and destination alpha blending factors
	void			SetFactors( const alphafactor_t s, const alphafactor_t d ) { src=s; dest=d; Invalidate(); }
	void			SetSrcFactor(const alphafactor_t f)  { src = f; Invalidate(); }
	void			SetDestFactor(const alphafactor_t f) { dest = f; Invalidate(); }
	alphafactor_t	GetSrcFactor()  const { return src; }
	alphafactor_t	GetDestFactor() const { return dest; }
	//! We're blending if the destination color is affecting the final color
	bool			IsBlending() const { return dest!=Zero; }
	//! Alpha value (only used if no material property is present)
	void			SetAlpha(const float a) { alpha = a; Invalidate(); }
	float			GetAlpha() const {return alpha;}
	// Predefined blending operations
	void			Set_Opaque()   { src=One; dest=Zero; Invalidate(); }
	void			Set_Standard() { src=SrcAlpha; dest=InvSrcAlpha; Invalidate(); }
	void			Set_Additive() { src=dest=One; Invalidate(); }
	void			Set_Multiply() { src=Zero; dest=SrcColor; Invalidate(); }
	// Inherited from CTRenderProperty:
	virtual CTRenderProperty* Clone() const;
	virtual bool	_Compare( const CTRenderProperty* ) const;
	// For networking, loading & saving (inherited)
	virtual void	WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool	ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	alphafactor_t	src, dest;
	float			alpha;
};
/////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTAlphaProperty> PAlphaProperty;
/////////////////////////////////////////////////////////////////////////////
} // namespace citk
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITK_ALPHAPROPERTY_H_INCLUDED
///////////////////////////////// [citk_AlphaProperty.h] END
///////////////////////////////// [citk_BasicSoundProperty.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_BASICSOUNDPROPERTY_H_INCLUDED
#define CITK_BASICSOUNDPROPERTY_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTBasicSoundProperty );
//////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CTEntity;
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTBasicSoundProperty: public CTRenderProperty
{
	DECLARE_ALL( CTBasicSoundProperty, CTRenderProperty );
public:
	float			Pitch, Speed;			// If not supported separately, use Pitch
	float			Volume;					// -Attenuation (in dB, 0 is no change, -100 is 'mute')
	CTBasicSoundProperty();
	CTBasicSoundProperty( const CTBasicSoundProperty* );
	virtual bool		_Combine( const CTRenderProperty* );
	virtual bool		_Compare( const CTRenderProperty* ) const;
	CTRenderProperty*	Clone() const;
	void				WriteToStream( CTStream*, streamlod_t );
	bool				ProcessChunk( CTStream*, chunkid_t );
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTBasicSoundProperty> PBasicSoundProperty;
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_BASICSOUNDPROPERTY_H_INCLUDED
///////////////////////////////// [citk_BasicSoundProperty.h] END
///////////////////////////////// [citk_3DSoundProperty.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_3DSOUNDPROPERTY_H_INCLUDED
#define CITK_3DSOUNDPROPERTY_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CT3DSoundProperty );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CTEntity;
///////////////////////////////////////////////////////////////////////////////
class CITK_API CT3DSoundProperty: public CTRenderProperty
{
	DECLARE_ALL( CT3DSoundProperty, CTRenderProperty );
public:
	float__t		DopplerFactor;			// 0 
	float__t		OutsideVolume;			// -Attenuation relativy to main volume (in dB, 0 is no change, -100 is 'mute')
	float__t		ConeInsideAngle;		// degrees (default >360, means: not conical)
	float__t		ConeOutsideAngle;		// degrees, must be > coneinsideangle for IsCone to be true; (default 0)
	float__t		MinDistance;			// Maximum Distance where the sound sounds at its maximum attenuation. This one defines the "sound volume"2"distance" relation!
	float__t		MaxDistance;			// Maximum Distance at which sound is rendered. Does not affect sound volume, just turns if off far away from the source
	bool			IsCone() const;
	void			SetCone( cfloat__t Inside_Angle_In_Deg, cfloat__t Outside_Angle_In_Deg, cfloat__t MinDist, cfloat__t MaxDist=-1 ); // Out>In, or will be spherical
	void			SetSphere( cfloat__t MinDist, cfloat__t MaxDist=-1 ); // Max>Min. default Max: 64 * min, is about -100 dB!?!
	CT3DSoundProperty();
	CT3DSoundProperty( const CT3DSoundProperty* );
	virtual bool		_Combine( const CTRenderProperty* );
	virtual bool		_Compare( const CTRenderProperty* ) const;
	CTRenderProperty*	Clone() const;
	void				WriteToStream( CTStream*, streamlod_t );
	bool				ProcessChunk( CTStream*, chunkid_t );
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CT3DSoundProperty> P3DSoundProperty;
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_3DSOUNDPROPERTY_H_INCLUDED
///////////////////////////////// [citk_3DSoundProperty.h] END
///////////////////////////////// [citk_CTEAXSoundProperty.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef _CITK_CTEAXSOUNDPROPERTY_H_INCLUDED
#define _CITK_CTEAXSOUNDPROPERTY_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTEAXSoundProperty);
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
/*! \class CTEAXSoundProperty
* \brief EAX Sound Property 
* \author Stan Adrian . Crystal Interactive Systems
* adrian.stan@crystalinter.com 
* \image html AS.jpg align=left
* \image latex As.eps "My application" width=10cm
* \version 1.0
* \date    2002
*/
class CITK_API CTEAXSoundProperty :  public CTRenderProperty   
{
	DECLARE_ALL(CTEAXSoundProperty, CTRenderProperty);
public:
	enum EAXSoundPropertyFlags_t 
	{
		eaxSPDirectHFAuto=0x00000001,
		/*!< VALUE 0x01.\n
		* - If this flag is TRUE (its default value), this sound source's direct-path sound is automatically filtered
		* according to the orientation of the source relative to the listener and the setting of the sound-source
		* property Outside Volume HF. If Outside Volume HF is set to 0, the source is not more directive at
		* high frequencies and this flag has no effect. Otherwise, the direct path will be brighter in front of the
		* source than on the side or in the rear. \n
		* - If this flag is FALSE, this sound source's direct-path sound is not filtered at all according to
		* orientation. (Note that this is not the same as setting Outside Volume HF to 0, because this flag
		* doesn't affect high-frequency attenuation of each source's reflected sound according to its
		* directivity - that is controlled by Room HF Auto).
		*/
		
		eaxSPRoomAuto=0x00000002,    
		/*!< VALUE 0x02.\n
		* - If this flag is TRUE (its default value), the intensity of this sound source's reflected sound is
		*automatically attenuated according to source-listener distance and source directivity. 
		* - If it is FALSE,the reflected sound is not attenuated according to distance and directivity.
		*/
		
		eaxSPRoomHFAuto=0x00000004,
		/*!< VALUE 0x04.\n
		* - When this flag is TRUE (its default value), the high frequency content of the reflected sound will be
		* automatically reduced according to the Outside Volume HF property and cone angle settings.
		* When Outside Volume HF is set to a value other than 0, it is in effect taking high frequencies out of
		* the over all sound radiated by the source into the room. The more directive a sound is, and the
		* higher the Outside Volume HF value is, the more high frequencies will be taken out.
		* - If this flag is FALSE, the sound source's reflected sound is not filtered at all according to the
		* source's directivity. Note that this is not the same as setting Outside Volume to 0, because this flag
		* does not affect high-frequency attenuation of each source's direct-path sound according to its
		* directivity - that is controlled by the Direct HF Auto flag. 
		*/
		
		
		eaxSPDefault=0x00000007		
		/*!< VAlUE 0x07. \n
		* - eaxSPDirectHFAuto | eaxSPRoomAuto | eaxSPRoomHFAuto
		*/ };
		
		
public:
	
	/*! The Constructor */
	CTEAXSoundProperty();
	/*! The Constructor */
	CTEAXSoundProperty( const CTEAXSoundProperty *sop );
	/*! The Destructor */
//	virtual ~CTEAXSoundProperty();
	
	/*! \name Get Methods */
	//@{
	/*!
	* \return float__t flDirectPath
	* \sa flDirectPath
	*/
	cfloat__t GetDirectPath		    () const {return flDirectPath;}; 
	
	
	/*!
	* \return float__t flDirectHFPath
	* \sa flDirectHFPath
	*/
	cfloat__t GetDirectHFPath	    () const {return flDirectHFPath;};
	
	
	/*!
	* \return float__t flRoomEffectLevel
	* \sa flRoomEffectLevel
	*/
	cfloat__t GetRoomEffectLevel	() const {return flRoomEffectLevel;};
	
	/*!
	* \return float__t flRoomHFEffectLevel
	* \sa flRoomHFEffectLevel
	*/
	cfloat__t GetRoomHFEffectLevel  () const {return flRoomHFEffectLevel;};
	
	
	/*!
	* \return float__t flOutside Volume HF
	* \sa flOutsideVolumeHF
	*/
	cfloat__t GetOutsideVolumeHF	() const {return flOutsideVolumeHF;};
	
	/*!
	* \return float__t flRollOffFactor
	* \sa flRolloffFactor
	*/
	cfloat__t GetRolloffFactor	    () const {return flRolloffFactor;};
	
	
	/*! 
	* \return float__t flRoomRollOffFactor
	* \sa flRoomRolloffFactor
	*/
	cfloat__t GetRoomRolloffFactor  () const {return flRoomRolloffFactor;};
	
	/*!
	* \return float__t flAirAbsorptionFactor
	* \sa flAirAbsorptionFactor
	*/
	
	cfloat__t GetAirAbsorptionFactor() const {return flAirAbsorptionFactor;};
	
	/*!
	* \return DFlags ulFlags
	* \sa EAXSoundPropertyFlags_t
	*/
	const DFlags& GetFlags			() const {return ulFlags;};
	//@}
	
	/*! \name Set Methods */
	//@{
	void SetDirectPath			(cfloat__t dB);
	void SetDirectHFPath		(cfloat__t dB);
	void SetRoomEffectLevel		(cfloat__t dB);
	void SetRoomHFEffectLevel	(cfloat__t dB);
	void SetOutsideVolumeHF		(cfloat__t lOutsideVolumeHF);
	
	void SetRolloffFactor		(cfloat__t flRolloffFactor);
	void SetRoomRolloffFactor	(cfloat__t flRoomRolloffFactor);
	void SetAirAbsorptionFactor	(cfloat__t flAirAbsorptionFactor);
	void SetFlags				(DFlags ulFflags);
	//@}
	
	/*! \name Other Methods */
	//@{
	/** \brief Combine 2 Obstruction Properties
	*/
	
	
	bool				Interpolate(const CTEAXSoundProperty*);
	/*! \name Other Methods */
	//@{
	
	/*! \brief Combine 2 EAX Sound Properties */
	virtual bool		_Combine( const CTRenderProperty* );
	/*! \brief Compare 2 EAX Sound Properties */
	virtual bool		_Compare( const CTRenderProperty* ) const;
	
	/*! \brief Clone an EAX Sound Property */
	CTRenderProperty*	Clone() const;
	/*! \brief Write into the stream EAX Sound Property */
	void				WriteToStream( CTStream*, streamlod_t );
	/*! \brief Read from a stream an EAX Sound Property */
	bool				ProcessChunk( CTStream*, chunkid_t );
	
	/*! \brief Set value of the EAX Sound Source Property with rhs value */
	CTEAXSoundProperty& Set( const CTEAXSoundProperty* rhs );
	/*! \brief Compare value of two EAX Sound  Properties */
//	bool operator == ( const CTEAXSoundProperty*  rhs ) const; 
	/*! \brief Compare value of two EAX Sound  Properties */
//	bool operator != ( const CTEAXSoundProperty*  rhs ) const; 
	
	//@}
	
	
private :
	
/*! 
* - Direct allows you to make manual adjustments to an
* individual sound source's direct-path volume after all other forms of attenuation are applied
* (attenuation from distance, orientation etc.). You can use this to make additional corrections to
* sound source levels if they are not what you want them to be after all other attenuation effects are
* applied.
* - In some cases, you may find that a sound source is too quite due to all the attenuating
* circumstances. You can use Direct to add volume to the direct path of a sound to make up for lost
* level. Be aware that you cannot make a sound source louder than its buffer volume with this
* property . \n\n
*		- Value type     :  float__t
*		- Typical values :  -100.0 to 0.0		
*		- Default value  :  0.0					
*		- Value units    :	dB					
* \sa 
* float__t flDirectHFPath \n
* float__t flRoomEffectLevel \n
* float__t flRoomHFEffectLevel \n
* cfloat__t GetDirectPath	() \n
* void SetDirectPath		(cfloat__t	dB ) \n
	*/
    float__t	 flDirectPath;    
	
	/*!
	* - The Direct HF property works the same as the Direct property except that it provides an additional
	* attenuation at high frequencies only (measured at HF Reference from the EnvironmentProperty). \n\n
	*		- Value type     : float__t				
	*		- Typical values :-100.0 to 10.0
	*		- Default value  : 0.0	
	*		- Value units    :dB	
	* \sa 
	* float__t flDirectPath \n
	* float__t flRoomEffectLevel \n
    * float__t flRoomHFEffectLevel \n
	* cfloat__t GetDirectHFPath	() \n
	* void SetDirectHFPath		(cfloat__t	dB ) \n
	*/
    float__t	 flDirectHFPath;    
    
    /*!
	* - Source Room and Room HF are used to adjust the effects of the Listener Room and Room HF
	* settings. These properties are here so that you can make additional changes to the level of the
	* reflected sound and to its high-frequency attenuation on a source-by-source basis.
	* - You can use the Room sound source property to correct the intensity of reflected (and
	* reverberated) sound at minimum distance as defined by the Room listener property. This can be
	* useful especially if different sound sources have different minimum distances. Note that just like in
	* the case of Direct, you can never amplify the reflected sound past the 2D buffer volume of the
	* original sound source. \n\n
	*		- Value type     : float__t				
	*		- Typical values : -100.0 to 0.0		
	*		- Default value  : 0.0		
	*		- Value units    : dB			
	* \sa 
	* float__t flDirectPath \n
	* float__t flDirectHFPath \n
    * float__t flRoomHFEffectLevel \n
	* cfloat__t GetRoomEffectLevel	() \n
	* void SetRoomEffectLevel		(cfloat__t	dB ) \n
	*/
    float__t	 flRoomEffectLevel;    
    
	/*!
	* - Source Room HF are used to adjust the effects of the Listener Room HF
	* settings at the high-frequency. \n\n
	*		- Value type     : float__t			
	*		- Typical values : -100.0 to 0.0	
	*		- Default value  :  0.0				
	*		- Value units    :  dB					
	* \sa 
	* float__t flDirectPath \n
	* float__t flDirectHFPath \n
    * float__t flRoomEffectLevel \n
	* cfloat__t GetRoomHFEffectLevel	() \n
	* void SetRoomHFEffectLevel		(cfloat__t	dB ) \n
	*/
    float__t	 flRoomHFEffectLevel;
	
	/*!
	* - The Outside Volume HF property enhances the directivity effect provided by the positional audio
	* API for individual sound sources. Using standard directivity properties, a source can be made to
	* sound at full volume when the listener is directly in front of the source and will be attenuated as the
	* listener circles the source away from the front.
	* - The Outside Volume HF property allows the developer to enhance the directivity effect by
	* attenuating the high frequencies more than the low frequencies. At the minimum (and default)
	* setting of 0, there is no additional high-frequency attenuation, so the directivity effect is unaltered. A
	* setting of -10 dB means that high frequencies are attenuated by an additional 10 dB on the
	* direct-path sound when the listener is located in the back of the source (anywhere outside of the
	* 'Outside Cone'). The EAX reflections and reverberation will also be attenuated somewhat at high
	* frequencies (because the source will not radiate as much energy into the room at high
	* frequencies).
	* - You can turn off the effect of Outside Volume HF on the direct-path sound using the Direct HF Auto
	* flag, or you can turn off its effect on reflected sound using the Room HF Auto flag.
	* Note that if you use Outside Volume HF systematically on all sources and have Room HF Auto
	* turned on, it may sound more natural to set the listener property Room HF to 0 (or raise it closer to
	* 0) on all environment presets. If you have listener Room HF set far below zero, then you apply a
	* low-pass filter to sound sources already affected by Outside Volume HF's low pass filtering effect. \n\n
	*		- Value type     : float__t				
	*		- Typical values : -100.0 to 0.0		
	*		- Default value  : 0.0					
	*		- Value units    : dB					
	* \sa 
	* cfloat__t GetOutsideVolumeHF	()  \n
	* void SetOutsideVolumeHF	   (cfloat__t lOutsideVolumeHF) \n
	*/
	float__t	 flOutsideVolumeHF;     
	
	
	/*!
	* - Like DS3D doppler factor but per sound source. \n\n
	*		- Value type     : float__t				
	*		- Typical values : 0.0 to 10.0		
	*		- Default value  : 0.0					
	*		- Value units    : A linear multiplier value	
	* \sa 
	* cfloat__t GetDopplerFactor      () \n
	* void SetDopplerFactor	   (cfloat__t flDopplerFactor) \n
	*/
	//    float__t flDopplerFactor;      
	
	
	
	/*!
	* - DirectSound  provide a Rolloff Factor property. DirectSound's is a global property
	* The EAX Property Rolloff Factor is a per-source property . If the Rolloff Factor 
	* already provided by the positional audio API is non-zero, then the EAX Rolloff Factor
	* will be added to it to determine the rolloff applied to the sound source. \n\n
	*		- Value type     : float__t				
	*		- Typical values : 0.0 to 10.0
	*		- Default value  : 0.0				
	*		- Value units    :  A linear multiplier value
	* \sa 
	* cfloat__t GetRolloffFactor	 ()
	* void SetRolloffFactor	   (cfloat__t flRolloffFactor)
	*/
    float__t flRolloffFactor;      
	
	
	/*!
	* - This is the per-source equivalent of the EAX listener property of the same name. This property only
	* affectrs one specific sound source. If the EAX listener property Room Rolloff Factor is non-zero,
	* then the value for these two properties will be added together to determine the rolloff applied to the
	* sound source. \n\n
	*		- Value type     : float__t				
	*		- Typical values : 0.0 to 10.0			
	*		- Default value  : 0.0					
	*		- Value units    : A linear multiplier value	
	* \sa 
	* cfloat__t GetRoomRolloffFactor	 () \n
	* void SetRoomRolloffFactor      (cfloat__t flRoomRollOffFactor) \n
	*/
    float__t flRoomRolloffFactor;  
	
	
	/*!
	* - The Air Absorption Factor property is a multiplier value for the air absorption value set by the
	* listener property Air Absorption HF. The resultant air absorption value applies only to this sound
	* source.
	* - The Air Absorption Factor default value of 1.0 specifies no change to the air absorption factor set by
	* the listener Air Absorption HF property. The minimum value of 0.0 turns off air absorption for this
	* source, and a maximum value of 10.0 multiplies absorption by 10 for this source.
	* - You can use the Air Absorption Factor to simulate a source located in different atmospheric
	* conditions than the rest of the room. You can increase air absorption, for example, for a sound
	* source that comes from the middle of a cloud of smoke. Alternatively, you can decrease air
	* absorption for a sound source coming from a suddenly visible object in moving clouds. \n\n
	*		- Value type      : float__t				
	*		- Typical values  : 0.0 to 10.0			
	*		- Default value   : 1.0					
	*		- Value units     : A linear multiplier value
	* \sa 
	* cfloat__t GetAirAbsorptionFactor() \n
	* void SetAirAbsorptionFactor      (cfloat__t flAirAbsorptionFactor) \n
	*/
    
	float__t flAirAbsorptionFactor;
    
	DFlags ulFlags;
};
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTEAXSoundProperty> PEAXSoundProperty;
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
} // namespace
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif 
///////////////////////////////// [citk_CTEAXSoundProperty.h] END
///////////////////////////////// [citk_CTSoundEnvironmentProperty.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef _CITK_SOUNDENVIRONMENTPOPERTY_H_INCLUDED
#define _CITK_SOUNDENVIRONMENTPOPERTY_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTSoundEnvironmentProperty);
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
/*! \class CTSoundEnvironmentProperty
*	\brief Sound Environment Property 
*	\author Stan Adrian . Crystal Interactive Systems
*	adrian.stan@crystalinter.com 
*	\image html AS.jpg align=left
*	\image latex As.eps "My application" width=10cm
*   \version 1.0
*   \date    2002
*/
class CITK_API CTSoundEnvironmentProperty : public CTRenderProperty  
{
	
	DECLARE_ALL(CTSoundEnvironmentProperty, CTRenderProperty);
		/*! Flags for the Environment Property */
public:
	enum EAXEnvPropertyFlags_t
	{
		eaxEnvDecayTimes =0x00000001,
		/*!< VALUE 0x01.
		*If this flag is TRUE, a change in Environment Size will scale Decay Time. If it is false, changes to
		*Environment Size do not affect it.\n
		*/
		
		eaxEnvReflections =0x00000002,    
		/*!< VALUE 0x02.
		*If both this flag and the Reflections Delay Scale flag are TRUE, an increase in Environment Size
		*value causes an attenuation of the Reflections level. If one of the two flags is FALSE, a change in
		*Environment Size has no effect on Reflections.\n
		*/
		
		eaxEnvReflectionsDelay =0x00000004,
		/*!< VALUE 0x04.
		*If this flag is TRUE, a change in Environment Size will scale Reflections Delay. (In effect, as the
		*room gets larger the nearest walls get more distant, so reflections take longer to reach the listener)
		*If it is set to false, changes to Environment Size do not affect Reflections Delay.\n
		*/
		eaxEnvReverb =0x00000008,    
		/*!< VALUE 0x08.
		*If this flag is TRUE, an increase in Environment Size value causes an attenuation of the Reverb
		*level. If it is FALSE, a change in Environment Size has no effect on Reverb.
		*/
		
		eaxEnvReverbDelay =0x00000010,
		/*!< VALUE 0x10.
		*If this flag is TRUE, a change in Environment Size causes a proportional change to the Reverb
		*Delay. If it is false, changes to Environment Size do not affect Reverb Delay.
		*/
		eaxEnvEchoTime=0x00000040,    
		/*!< VALUE 0x40.
		*If this flag is TRUE, a change in Environment Size value causes a proportional change of the
		*property Echo Time. If it is FALSE (its default value), a change in Environment Size has no effect
		*on Echo Time.
		*/
		
		eaxEnvModulationTime=0x00000080,
		/*!< VALUE 0x80.
		*If this flag is TRUE, a change in Environment Size value causes a proportional change of the
		*property Modulation Time. If it is FALSE (its default value), a change in Environment Size has no
		*effect on Modulation Time.
		*/
		eaxEnvDecayHFLimit=0x00000020,
		/*!< VALUE 0x20.
		*This flag limits high-frequency decay time according to air absorption.
		*/
		
		
		eaxEnvDefault=(	eaxEnvDecayTimes |eaxEnvReflections|eaxEnvReflectionsDelay|\
								eaxEnvReverb|eaxEnvReverbDelay|	eaxEnvDecayHFLimit)
								/*!< 
								* eaxEnvDecayTimes | eaxEnvReflections | eaxEnvReflectionsDelay |
								* eaxEnvReverb | eaxEnvReverbDelay | eaxEnvDecayHFLimit
								*/ 
	};
								
	/*! All types of Scenario*/
	enum {
		esCastle=0,/*!<The effects in the castle scenario simulate rooms with bare stone walls. They are intended to give an impression of being in a cool, drafty environment. High frequencies are reflected, low frequencies less so.*/
		esFactory, /*!<The effects in the factory scenario simulate rooms with metallic walls. The density of room modes is fairly low. The environments support low frequency sounds - there is a 'boomy' feel.  */
		esIcepalace,/*!<The effects in the ice palace scenario simulate rooms with walls of damp ice. The environment is highly reflective of high frequencies, but are less reflective at low frequencies. */
					/* Prominent echoes give shimmering effects in some rooms. */
		esSpaceStation,/*!<The effects in the space station scenario simulate rooms with walls of solid metal. High and low frequencies are supported equally, and a low density of room modes makes for a 'ringing' quality. */
		esWoodGalleon,/*!<The effects in the wooden galleon scenario simulate rooms with wooden surfaces. This is characterised with short, prominent reflections supporting particularly upper-mid frequencies. */
		esSports,/*!<These effects are defined for a set of seven typical sporting venues.  */
		esPrefab,/*!<These effects simulate rooms in 'pre-fabricated' buildings. */
		esDomesnPipes,/*!<These effects simulate the acoustics of areas with curved surfaces, domed structures and pipes or tubes. */
		esOutDoors,/*!<These effects simulate the acoustics of open-air locations.  */
		esMood,/*!<Mood effects can add some spice to sound effects to emphasise a mood or emotion, in a situation where room acoustics might not be as effective or appropriate. */
		esDriving,/*!<The eight driving effects have been designed specifically for driving simulations. There are a variety of effects for different views including inside and outside the vehicle. */
		esCity,/*!<The city effects should be useful for creating a convincing atmosphere for a sprawling metropolis. */
		esMisc,/*!<These are some further acoustic environments, which cannot be classified in the groups above. */
		esOriginal/*!<These effects are the original 26 presets supplied in EAX 1.0 */
	};
								
								
		
	/*! All Location for the Standard Scenario (esCastle, esFactory, esIcepalace, esSpaceStation, esWoodGalleon)*/
	enum	{	epHall = 0,/*!<Hall */
		epLargeRoom,/*!<LargeRoom */
		epMediumRoom,/*!<MediumRoom */
		epSmallRoom,/*!<SmallRoom */
		epCupboard,/*!<Cupboard */
		epAlcove,/*!<Alcove */
		epLongPassage,/*!<longPassage */
		epShortPassage,/*!<ShortPassage */
		epCourtyard /*!<Courtyard */};
	
	/*!These effects are defined for a set of seven typical sporting venues.  */
	enum	{	epEmptyStadium=0,/*!<Simulate the acoustics of a large stadium with  an audience.  */
		epFullStadium,/*!< Simulate the acoustics of a large stadium without an audience. */
		epStadiumTannoy,/*!<Can be applied to a sound to simulate the effect of a public address system consisting of speakers dotted around a large area  */
		epSquashCourt,/*!<Simulate reflective, indoor arenas for squash */
		epSmallsWimmingPool,/*!<Simulate the acoustics of small rooms with surfaces of shifting water. */
		epLargesWimmingPool,/*!<Simulate the acoustics of large rooms with surfaces of shifting water.*/
		epGymnasium};/*!< Simulate reflective, indoor arenas for badminton, indoor tennis, basketball, ice hockey  */
	
	/*! These effects simulate rooms in 'pre-fabricated' buildings. */
	enum	{	epWorkShop=0, /*!<WorkShop */
		epSchoolRoom, /*!<School Room */
		epPractiseRoom,/*!<Practise Room */
		epOutHouse,/*!<Out House */
		epCaravan};/*!<Caravan */
	
	/*!These effects simulate the acoustics of areas with curved surfaces, domed structures and pipes or tubes. */
	enum	{	epTomb=0,/*!<Simulates a small stone room with a domed ceiling.  */
		epSaintPauls,/*!<Imitates the acoustics of a large domed place of worship such as St. Paul's Cathedral in London, with a long decay */
		epSmall,/*!<Small */
		epLongthin,/*!<Longthin */
		epLarge,/*!<Large */
		epResonant/*!<Resonant */};
	
	/*! The outdoors effects use quiet, delayed reflections to simulate the sound bouncing from distant parts of the landscape. Only a limited range of frequencies are supported out of doors. In some cases, short reverb tails with very low diffusion help to 
extend the effect.*/
	enum	{	epBackyard=0,/*!<Backyard */
		epRollingPlains,/*!<RollingPlains */
		epDeepCanyon,/*!<DeepCanyon */
		epCreek,/*!<Creek */
		epValley/*!<Valley */};
	
	/*! Mood effects can add some spice to sound effects to emphasise a mood or emotion, in a situation where room acoustics might not be as effective or appropriate.*/
	enum	{	epHeaven=0,/*!<Is a sweet sounding reverb with plenty of high frequencies and a smooth decay.*/
		epHell,/*!<Uses echo and pitch modulation to create a discordant effect. */
		epMemory/*!<Uses pitch modulation to create impression of an old, badly adjusted tape recorder, with a hint of reverb to give a dreamy air! */};
	
	/*!The eight driving effects have been designed specifically for driving simulations. There are a variety of effects for different views including inside and outside the vehicle. */
	enum	{	epCommentator=0,/*!<It is a variant on esSport_TannoySystem - an effect to specifically re-create the delayed sound of a public address system spread with speakers spread over a wide area. */
		epPitGarage,/*!<Simulates the acoustics of a bare, concrete garage.  */
		epIncarRacer,/*!<The in-car effects could be used when the camera is inside the vehicle. They rely on short, coloured early reflections to re-create the acoustics inside a vehivle cabin. Alternative variants exist for different car types - Incar_Racer i
s for a stripped-out, bare bones racing or rally car, */
		epIncarSports,/*!<It is intended for a spartan sports car */
		epIncarLuxury,/*!<Gives a less harsh, more damped sound. */
		epFullGrandstand,/*!<When the camera is within the grandstand area during a race  */
		epEmptyGrandstand,/*!<useful for the same location during practise / qualifying laps, when the crowd is sparser. */
		epTunnel/*!<When working on an F1 game. Designing the Monaco circuit..  */};
	
	/*!The city effects should be useful for creating a convincing atmosphere for a sprawling metropolis. */
	enum	{	epStreets=0,/*!<Streets */
		epSubway,/*!<Subway */
		epMuseum,/*!<Museum */
		epLibrary,/*!<Library */
		epUnderpass,/*!<Underpass */
		epAbandoned/*!<Abandoned */};
	
	/*!These are some further acoustic environments, which cannot be classified in the groups above. */
	enum	{	epDustyRoom=0,/*!<DustyRoom */
		epChapel,/*!<Chapel */
		epSmallWaterroom/*!<SmallWaterroom */};
	
	/*! */
	enum	{	epGeneric=0, /*!<A generic reverb with minimal coloration */
		epPaddedCell,/*!<No reflections or reverberation - an-echoic chamber */
		epRoom,/*!<Small room, low reflections and reverb */
		epBathroom,/*!<Small room, live sound */
		epLivingroom,/*!<Little reverberation, short reflections */
		epStoneRoom,/*!<Mid sized room, plenty of treble */
		epAuditorium,/*!<Large space, lots of reflections, diffuse sound */
		epConcertHall,/*!<Similar to Auditorium, 'live' feel, more high frequencies */
		epCave, /*!<Diffuse reverb, lots of high frequencies */
		epArena,/*!<Huge room */
		epHangar,/*!<Huge room, long decay, booming sound */
		epCarpettedHallway,/*!<Short, soft reverb */
		epHallway,/*!<As carpeted hallway, more reverb, small room dimensions*/
		epStoneCorridor,/*!<Medium decay, plenty of high frequencies */
		epAlley,/*!<Outdoors, low diffusion, quick echoes */
		epForest,/*!<Outdoors, long delay, prominent reflection, echo */
		epCity,/*!<Outdoors, soft reverb, high frequencies filtered, low diffusion */
		epMountains,/*!<Outdoors, long delay, single soft echo */
		epQuarry,/*!<Outdoors, medium delay, diffuse reverb with plenty of HF */
		epPlain,/*!<Outdoors, long delay, distant reflections */
		epParkingLot,/*!<Outdoors, short delay and soft, bright, diffuse reverb */
		epSewerpipe,/*!<Short delay, loud reverb, metallic sound */
		epUnderWater,/*!<Prominent reverb with HF cut, distinctive watery sound */
		epDrugged,/*!<Long echoes, plenty of HF, fast pitch modulation */
		epDizzy,/*!<Long, shimmering, soft dreamy reverb, slow pitch modulation */
		epPsychotic/*!<Long metallic reverb with pitch modulation */};
	
	
	
public:
	
	int GetScenarioID(cstr_t);
	int GetPresetID(cstr_t);
	CTSoundEnvironmentProperty();/*!< The constructor.*/
	CTSoundEnvironmentProperty( const CTSoundEnvironmentProperty *sep ); /*!< The constructor.*/
//	virtual ~CTSoundEnvironmentProperty(); /*!< The destructor. */
	
	
										   /*! \name  Set Methods
										   *  
	*/
	//@{
	/*! \brief Set the preset environments by scenario type and preset . 
	*/
	void SetEnvironment(unsigned int id);   //only for compatibility the old EAX version
	void SetFlags(DFlags flags);
	void SetEnvironmentSize(cfloat__t metters);
	
	void SetEnvironmentDiffusion(cfloat__t flEnvironmentDiffusion);
	
	void SetRoom(cfloat__t dB);
	void SetReflections(cfloat__t dB);
	void SetReverb(cfloat__t dB);
	
	void SetDecayTime(cfloat__t seconds);
	void SetReflectionsDelay(cfloat__t seconds);
	void SetReverbDelay(cfloat__t seconds);
	
	
	void SetEchoTime(cfloat__t flEchoTime);
	void SetEchoDepth(cfloat__t flEchoDepth);
	
	void SetModulationTime(cfloat__t flModulationTime);
	void SetModulationDepth(cfloat__t flModulationDepth);
	
	void SetAirAbsorptionHF(cfloat__t flAirAbsorptionHF);
	void SetRoomRolloffFactor(cfloat__t flRoomRolloffFactor);
	
	void SetLFReference(cfloat__t hertz);
	void SetHFReference(cfloat__t hertz);
	void SetRoomHF(cfloat__t dB);
	void SetRoomLF(cfloat__t dB);
	void SetDecayHFRatio(cfloat__t flDecayHFRatio);
	void SetDecayLFRatio(cfloat__t flDecayLFRatio);
	
	void SetReflectionsPan(cvec_t vReflectionsPan);
	void SetReverbPan(cvec_t vReflectionsPan);
	
	
	
	//@}
	
	/*! \name  Get Methods */
	//@{
	unsigned long GetEnvironment() const {return ulEnvironment;};
	
	/*! \return Environment size in meters
	* \sa flEnvironmentSize
	*/
	cfloat__t	GetEnvironmentSize() const {return flEnvironmentSize;}; 
    
	/*! \return Environment diffusion
	* \sa flEnvironmentDiffusion 
	*/
	cfloat__t	GetEnvironmentDiffusion() const {return this->flEnvironmentDiffusion;};
    
	/*! \return Room effect level (at mid frequencies) in dB 
	* \sa flRoom
	*/
	cfloat__t	GetRoom() const {return flRoom;};
    
	/*! \return Relative room effect level at high frequencies in dB 
	* \sa flRoomHF
	*/
	cfloat__t	GetRoomHF() const {return flRoomHF;};					
    
	/*! \return Relative room effect level at low frequencies in dB 
	* \sa flRoomLF
	*/
	cfloat__t	GetRoomLF() const {return flRoomLF;};			
	
	/*! \return Reverberation decay time at mid frequencies  
	* \sa flDecayTime
	*/
    cfloat__t	GetDecayTime() const {return flDecayTime;};          
	
	/*! \return High-frequency to mid-frequency decay time ratio 
	* \sa flDecayHFRatio
	*/
    cfloat__t	GetDecayHFRatio() const {return flDecayHFRatio;};   
	
	/*! \return Low-frequency to mid-frequency decay time ratio    
	* \sa flDecayLFRatio
	*/
    cfloat__t	GetDecayLFRatio() const {return flDecayLFRatio;};    
    
	/*! \return  Early reflections level relative to room effect 
	* \sa flReflections
	*/
	cfloat__t	GetReflections() const {return flReflections;};		
	
	/*! \return  Initial reflection delay time 
	* \sa flReflectionsDelay
	*/
    cfloat__t	GetReflectionsDelay() const {return flReflectionsDelay;};
	
	/*! \return  Early reflections panning vector 
	* \sa vReflectionsPan
	*/
    cvec_t		GetReflectionsPan() const {	return vReflectionsPan;};
	
	/*! \return Late reverberation level relative to room effect 
	* \sa flReverb
	*/
	cfloat__t GetReverb() const {return flReverb;};		
	
	/*! \return  Late reverberation delay time relative to initial reflection 
	* \sa flReverbDelay
	*/
    cfloat__t GetReverbDelay() const {return flReverbDelay;};           
	
	/*! \return Late reverberation panning vector 
	* \sa vReverbPan
	*/
    cvec_t	  GetReverbPan() const {return  vReverbPan;};
	
    /*! \return Echo time  
	* \sa flEchoTime
	*/
	cfloat__t GetEchoTime() const {return flEchoTime;};              
	
    /*! \return Echo depth 
	* \sa flEchoDepth
	*/
	cfloat__t GetEchoDepth() const {return flEchoDepth;};            
	
	/*! \return Modulation time 
	* \sa flModulationTime
	*/
	cfloat__t GetModulationTime() const {return flModulationTime;};  
	
	/*! \return  Modulation depth 
	* \sa flModulationDepth
	*/
    cfloat__t GetModulationDepth() const {return flModulationDepth;};
    
	/*! \return  Air Absorption HF \n Change in level per meter at high frequencies 
	* \sa flAirAbsorptionHF
	*/
	cfloat__t GetAirAbsorptionHF()  const {return flAirAbsorptionHF;};       
    
	/*! \return  reference high frequency 
	* \sa flHFReference
	*/
	cfloat__t GetHFReference() const {return flHFReference;};
	
	/*! \return  reference low frequency 
	* \sa flLFReference
	*/
    cfloat__t GetLFReference() const {return flLFReference;};
	
    /*! \return flRolloffFactor . \n Like DS3D flRolloffFactor but for room effect
	* \sa flRoomRolloffFactor
	*/
	cfloat__t GetRoomRolloffFactor() const {return this->flRoomRolloffFactor;};     
	
	/*! \return  flags
	* \sa EAXEnvPropertyFlags_t
	*/
	const DFlags& GetFlags() const {return ulFlags;};
	//@}
	
	bool SetEnvironment(int sc ,int pres);
	/*! \name Other Methods */
	//@{
	
	/*! \brief Combine 2 Environmnet Properties */
	virtual bool		_Combine( const CTRenderProperty* );
	/*! \brief Compare 2 Environmnet Properties */
	virtual bool		_Compare( const CTRenderProperty* ) const;
	/*! \brief Clone an Environmnet Property */
	CTRenderProperty*	Clone() const;
	/*! \brief Write into the stream an Environment Property */
	void				WriteToStream( CTStream*, streamlod_t );
	/*! \brief Read from a stream an Environment Property */
	bool				ProcessChunk( CTStream*, chunkid_t );
	
	
	/*! \brief Compare value of two Sound Environment Properties */
//	bool operator == ( CTSoundEnvironmentProperty*  rhs ) const ;
	/*! \brief Compare value of two Sound Environment Properties */
//	bool operator != ( CTSoundEnvironmentProperty*  rhs ) const ;
	/*! \brief Set value of the Sound Environment Property with rhs value */
	CTSoundEnvironmentProperty& Set( const CTSoundEnvironmentProperty* rhs ) ;
	//@}
	
protected :
	unsigned long ulEnvironment;    // sets all listener properties	
									/*!
									* - Environment Size can be used to make coarse changes to the current environment. Changing this
									* parameter alters other properties to simulate the acoustics of a room of different size but otherwise
									* similar properties (wall geometry and materials).
									* By default, this property will automatically adjust a collection of lower level properties, namely
									* Reflections, Reflections Delay, Reverb, Reverb Delay, and Decay Time (properties described in
									* more detail in the following sections). It can also adjust two additional properties: Echo Time and
									* - Modulation Time. Changing the value for Environment Size will scale the values of the related
									*lower level properties. You can decide whether or not any of these seven related lower level
									*properties will be affected by Environment Size by setting the related property scale flag (see
									*Property scaling flags) \n\n
									*		- Value type   :  float__t					
									*		- Typical values :  0.0 to 100.0				
									*		- Default value:  7.5
									*		- Value units  :  Meters
									* \sa 
									* cfloat__t GetEnvironmentSize() \n
									* void SetEnvironmentSize(cfloat__t meters) \n
	**/
	float__t flEnvironmentSize;     // environment size in meters
	
	DFlags ulFlags;					// modifies the behavior of properties
	
	/*! \name  Parameters affecting reverberation granularit*/
	//@{
	/*!
	* - Environment Diffusion controls how the individual reflections in the reverb are distributed. If the
	* value for this property is high, then there is a richer pattern of reflected waves in the room and
	* therefore a greater number of reflections will reach the listener. This results in a smooth sounding
	* reverberation. This type of room (environment) is said to be "diffuse." Rooms that have small
	* dimensions or very uneven, coarse surfaces or contain many reflective obstacles exhibit this type of
	* effect.
	* - Rooms or environments that have large dimensions, smooth surfaces, or open environments with
	* sparse reflectors produce sparser reflections patterns than diffuse environments, and therefore
	* require a lower value for Environment Diffusion. (Smoother surfaces do not "break the reverb up,"
	* and therefore, there are fewer echoes.) \n\n
	*		- Value type   :  float__t					
	*		- Typical values  : 0.0 to 1.0				
	*		- Default value:  1.0						
	*		- Value units  :  A linear multiplier value 
	* \sa 
	* cfloat__t GetEnvironmentDiffusion() \n
	* void SetEnvironmentDiffusion(cfloat__t flEnvironmentDiffusion) \n
	*/
	float__t flEnvironmentDiffusion;// environment diffusion
	
	
									/*!
									* - Echo Time controls the rate at which the cyclic echo repeats itself along the reverberation decay.
									* For example, the default setting for Echo Time is 250 ms. causing the echo to occur 4 times per
									* second. Therefore, if you clap your hands in this type of environment, you will hear four repetitions
									* of clap per second. \n\n
									*		- Value type   : float__t					
									*		- Typical values  :  0.075 to 0.25				
									*		- Default value:  0.25			
									*		- Value units  :  Seconds		
									* \sa 
									*  cfloat__t GetEchoTime() \n
									*  void SetEchoTime(cfloat__t seconds) \n
	*/
	float__t flEchoTime;            // echo time
	
	
									/*!
									* - Echo Depth introduces a cyclic echo in the reverberation decay, which will be noticeable with
									* transient or percussive sounds. A larger value of Echo Depth will make this effect more salient. \n\n
									*	- Value type  : float__t		
									*	- Typical values :  0.0 to 1.0	
									*	- Default value:  0.0			
									*	- Value units  :  A linear multiplier value
									* \sa 
									*  cfloat__t GetEchoDepth() \n
									*  void SetEchoDepth(cfloat__t flEchoDepth) \n
	*/
	float__t flEchoDepth;           // echo depth
	//@}
	
	/*! \name Parameters affecting intensity levels*/
	//@{
	/*!
	* - Room controls the amount of reflected sound in an environment. Changes made to Room adjust
	* the  level  of both the early reflections and the reverberation at the same time. Setting this parameter
	* to -100 negates all reflections and reverberant sound in an environment. \n\n
	*		- Value type   : <td> float__t				
	*		- Typical values  :  -100.0 to 0.0			
	*		- Default value:  -10.0						
	*		- Value units  :  dB						
	* \sa 
	* cfloat__t flRoom \n
	* cfloat__t GetRoom()  \n
	* void SetRoom(cfloat__t dB) \n
	*/
	float__t flRoom;                // room effect level (at mid frequencies)
	
	
									/*!
									* - Reflections sets the level of the early reflections in an environment. We use early reflections as a
									* cue for determining the size of the environment we are in. The louder (and less delayed) the
									* reflections are the nearer a wall will sound. \n \n
									*		- Value type   :  float__t				
									*		- Typical values : -100.0 to 10.0	
									*		- Default value:  -26.02				
									*		- Value units  : dB					
									* \sa 
									* cfloat__t GetReflections() \n
									* void SetReflections(cfloat__t dB) \n
	*/
	float__t flReflections;         // early reflections level relative to room effect
	
									/*!
									* -  Reverb controls the level of the reverberant sound in an environment. \n\n
									*		- Value type   :  float__t				
									*		- Typical values  :  -100.0 to 20.0	
									*		- Default value:  2.0					
									*		- Value units  :  dB					
									* \sa 
									* cfloat__t flRoom \n
									* cfloat__t GetReverb()  \n
									* void SetReverb(cfloat__t dB) \n
	*/
	float__t flReverb;			    // late reverberation level relative to room effect
	
	
									/*!
									* - The intensity of a sound source's reverberation becomes attenuated with distance, in a similar way
									* to its Direct Path . By default, the EAX engine calculates the
									* rolloff on the Room path (reflected sound, including reflections and reverb), taking into account
									* such properties as Decay Time .
									* - To define your own room rolloff calculation, change Room Rolloff Factor from its default of 0.0 (and,
									* optionally, set the Room Auto flag to FALSE). Setting a value of 1.0 for Room Rolloff Factor will
									* mean that a sound source's reflected sound is attenuated by distance at the same rate as its
									* Direct-path sound. Setting Room Rolloff Factor to 0.5 instead would imply that the reflected sound
									* is attenuated with increasing distance, although not as strongly as the direct path. \n \n
									*		- Value type   : float__t					
									*		- Typical values  : 0.0 to 10.0				
									*		- Default value: 0.0						
									*		- Value units  :A linear multiplier value	
									* \sa 
									*  cfloat__t GetRoomRolloffFactor() \n
									*  void SetRoomRolloffFactor(cfloat__t flRoomRolloffFactor) \n
	*/
	float__t flRoomRolloffFactor;   // like DS3D flRolloffFactor but for room effect
	//@}
	
	/*! \name Parameters affecting time*/
	//@{
	
	
	/*!
	* - Reflections Delay controls the amount of time it takes for the first reflected wave front to reach the
	* listener. Along with Reflections, if used properly it can affect the perceived size of an environment.
	* The smaller the value the less time it takes the early reflections to reach the listener. This means
	* that the sound had to travel less of a distance to reach the listener. Overall, this will simulate a
	* smaller environment. \n\n
	*		- Value type   : float__t				
	*		- Typical values  :  0.0 to 0.3		
	*		- Default value:  0.007				
	*		- Value units  :  Seconds				
	* \sa 
	* cfloat__t GetReflectionsDelay()\n
	* void SetReflectionsDelay(cfloat__t seconds) \n
	*/
	float__t flReflectionsDelay;	// initial reflection delay time
	
	
									/*!
									* - Reverb Delay sets the amount of time it takes for the reverberated sound to reach the listener.
									* Higher values imply a larger room; lower values a smaller room. This value defines the time
									* between the start of the Reflections (i.e. Reflections Delay) and the start of the Reverb. During this
									* phase, reflections will be heard. \n \n
									*		- Value type   :  float__t			
									*		- Typical values  :  0.0 to 0.1	
									*		- Default value:  0.011		
									*		- Value units  :  Seconds		
									* \sa 
									* cfloat__t GetReverbDelay() \n
									* void SetReverbDelay(cfloat__t seconds) \n
	*/
	float__t flReverbDelay;         // late reverberation delay time relative to initial reflection
	
	
									/*!
									* - Decay Time controls the amount of time the reverberated sound takes to decay 60 dB. For
									* instance, 0.1 seconds will give you a simulation of a very dead room. Larger values make the
									* environment "live", simulating larger spaces and/or surfaces that are more reflective. \n\n
									*		- Value type   : float__t			
									*		- Typical values : 0.1 to 20.0	
									*		- Default value: 1.49			
									*		- Value units  : Seconds		
									* \sa 
									* cfloat__t GetDecayTime() \n
									* void SetDecayTime(cfloat__t seconds) \n
	*/
	float__t flDecayTime;           // reverberation decay time at mid frequencies
	//@}
	
	/*! \name Parameters affecting Tonal Coloration */
	//@{
	
	
	/*!
	* - The properties HF Reference and LF Reference determine respectively the frequencies at which
	* the high-frequency effects and the low-frequency effects created by EAX properties are measured.
	* Note that, for listener properties, it is necessary to maintain a factor of at least 10 between these
	* two reference frequencies so that low frequency and high frequency properties can be accurately
	* controlled and will produce independent effects. In other words, the LF Reference value should be
	* less than 1/10 of the HF Reference value.
	* - The HF Reference value also applies to the source properties for all sources. 
	* As a result, it is safe to adopt the same setting of HF Reference for all the environment
	* presets used in a given application. Otherwise, changing the Environment preset while the
	* application is running will affect certain properties that should remain characteristics of the sources,
	* such as their directivity at high frequencies . \n\n
	*		- Value type   :float__t			
	*		- Typical values  :  1000 to 20000.0
	*		- Default value:  5000				
	*		- Value units  :  Hertz			
	* \sa float__t flLFReference \n
	* cfloat__t GetHFReference() \n
	* cfloat__t SetHFReference(cfloat__t Hertz) \n
	*/
	float__t flHFReference;         // reference high frequency
	
	
									/*!
									*		- Value type   :  float__t				
									*		- Typical values : 20 to 1000.0			
									*		- Default value:  250					
									*		- Value units  :  Hertz					
									* \sa  float__t flHFReference \n
									*  cfloat__t GetLFReference() \n
									*  cfloat__t SetLFReference(cfloat__t Hertz) \n
	*/
	float__t flLFReference;         // reference low frequency 
	
	
									/*!
									* - Room HF is used to attenuate the high frequency content of all the reflected sound in an
									* environment. You can use this property to give a room spectral characteristics. If you want to
									* model a room that absorbs many high frequencies, simply bring down the value for Room HF until
									* you get the timbre you are looking for. HF Reference sets the frequency at which the value of this
									* property is measured. \n\n
									*		- Value type   :float__t		
									*		- Typical values :  -100 to 0.0
									*		- Default value: -1			
									*		- Value units  : dB			
									* \sa  float__t flRoomLF \n
									*  cfloat__t GetRoomHF() \n
									*  void SetRoomHF(cfloat__t dB) \n
	*/
	float__t flRoomHF;              // relative room effect level at high frequencies
	
	
									/*!
									* - Room LF is the low frequency counterpart to Room HF. Use this to reduce the low frequency
									* content in an environment. LF Reference sets the frequency at which the value of this property is
									* measured. \n\n
									*		- Value type   :  float__t				
									*		- Typical values  :  -100 to 0.0		
									*		- Default value :  0.0					
									*		- Value units  : dB			
									* \sa  float__t flRoomHF \n
									*  cfloat__t GetRoomLF() \n
									*  void SetRoomLF(cfloat__t dB) \n
	*/
	float__t flRoomLF;              // relative room effect level at low frequencies  
	
	
									/*!
									* - Decay HF Ratio scales the decay time of high frequencies relative to the value of the Decay Time
									* property. By changing this value, you are changing the amount of time it takes for the high
									* frequencies to decay compared to the mid frequencies of the reverb. A value of 1.0 means that the
									* HF content of the reverb will decay at the same rate as the mid frequencies. Setting this value to .5
									* will cause the high frequencies to decay twice as fast. Setting it to 2.0 means the HF content will
									* last twice as long as the mid frequencies. HF Reference sets the frequency at which the value of
									* this property is measured.
									* - In most cases, the HF content should decay faster than the rest of the reverb (high frequencies are
									* absorbed more easily by most materials and by the air). Increasing Decay Time will proportionally
									* increase the high frequency decay time of a reverb. Decay HF Limit flag can be set to cap the
									* high-frequency decay time at a certain level. \n\n
									*		- Value type   :  float__t
									*		- Typical values  : 0.1 to 2,0
									*		- Default value: 0.83	
									*		- Value units  : A linear multiplier value	
									* \sa  flDecayLFRatio \n
									* cfloat__t GetDecayHFRatio() \n
									* void SetDecayHFRatio(cfloat__t flDecayHFRatio) \n
	*/
	float__t flDecayHFRatio;        // high-frequency to mid-frequency decay time ratio
	
	
									/*!
									* - Decay LF Ratio scales the decay time of low frequencies in the reverberation in the same manner
									* that Decay HF Ratio handles high frequencies. LF Reference sets the frequency at which the
									* value of this property is measured. \n\n
									*		- Value type   :  float__t					
									*		- Typical values  :  0.1 to 2,0			
									*		- Default value :  1.0						
									*		- Value units  :  A linear multiplier value
									* \sa float__t flDecayHFRatio \n
									* cfloat__t GetDecayLFRatio() \n
									* void SetDecayLFRatio(cfloat__t flDecayLFRatio) \n
	*/
	float__t flDecayLFRatio;        // low-frequency to mid-frequency decay time ratio   
	
	
									/*!
									* - Air Absorption HF is used to simulate environments containing propagation mediums that have
									* different levels of sound absorption, particularly at high frequencies. In typical conditions of
									* atmospheric humidity and temperature, air attenuates high frequency sound at approximately 0.05
									* dB per meter. Moist or ashy air may slightly muffle sounds traveling through it - use a lower value.
									* Set a higher level for a less absorptive medium such as dry, desert air. The HF Reference setting
									* determines the frequency at which the value of this property is measured. \n\n
									*		- Value type     : float__t					
									*		- Typical values :  -100.0 to 0,0			
									*		- Default value  : -5.0						
									*		- Value units    : Hundredths of a dB per meter
	*/
	float__t flAirAbsorptionHF;     // change in level per meter at high frequencies
	//@}
	
	
	/*! \name Panning effects */
	//@{
	/*!
	* - The Reflections Pan property is a 3D vector that controls the spatial distribution of the cluster of
	* early reflections. The direction of this vector controls the global direction of the reflections, while its
	* magnitude controls how focused the reflections are towards this direction.
	* In using panning, it is important to note that the direction of the vector is interpreted in the
	* coordinate system of the user, without taking into account the orientation of the virtual listener. For
	* instance, under DirectSound and assuming a four-point loudspeaker playback system, setting
	* - Reflections Pan to (0., 0., 0.7) means that the reflections are panned to the front speaker pair,
	* whereas as setting of (0., 0., -0.7) pans the reflections towards the rear speakers. The Z-axis
	* values would be reversed for OpenAL, since the coordinate system of OpenAL is the reverse of
	* DirectSound's.
	* - If the magnitude of Reflections Pan is zero (the default setting), the early reflections come evenly
	* from all directions. As the magnitude increases, the reflections become more focused in the
	* direction pointed to by the vector. A magnitude of 1.0 would represent the extreme case, where all
	* reflections come from a single direction, and is therefore unusual. The EAX 3.0 reverberation
	* engine does not support magnitudes larger than 0.7. Although larger magnitudes are allowed (up
	* to 1.0), it is safer for the application to limit the magnitude to 0.7, because this limitation of the EAX
	* reverberation engine may be removed in future versions of EAX. \n\n
	*		- Value type   : Vector3					
	*		- Typical values  :  Vector of length 0 to 1	
	*		- Default value :  (0, 0 ,0)	
	*		- Value units :  N/A			
	* \sa 
	* Vector3 vReverbPan \n
	* cvec_t GetReflectionsPan() \n
	* void SetReflectionsPan(cvec_t vReflectionPan) \n
	*/
	Vector3 vReflectionsPan;		// early reflections panning vector
	
	
									/*!
									*- Value type   : Vector3				
									*		- Typical values :  Vector of length 0 to 1
									*		- Default value:  (0, 0 ,0)
									*		- Value units  :  N/A	
									* \sa Vector3 vReflectionsPan \n
									* cvec_t GetReverbPan() \n
									* void SetReverbPan(cvec_t vReverbPan) \n
	*/
	Vector3 vReverbPan;				// late reverberation panning vector
	//@}
	
	/*! \name Pitch Modulation effects */
	//@{
	/*!
	* - Using these two properties, you can create a pitch modulation in the reverberant sound (which will
	* be most noticeable with sounds having a tonal color or pitch). You can use this to make some
	* trippy effects. Modulation Time controls the speed of the vibrato (rate of periodic changes in pitch). \n\n
	*		- Value type :	float__t			
	*		- Typical values :	0.4f to 4.0f	
	*		- Default value:  0.25f				
	*		- Value units  : seconds
	* \sa  float__t flModulationDepth \n
	* cfloat__t GetModulationTime() \n
	* void SetModulationTime(cfloat__t flModulationTime) \n
	*/				
	float__t flModulationTime;      // modulation time
	
	
									/*!
									* - Modulation Depth controls the amount of pitch change. Low values of Environment Diffusion will
									* contribute to reinforcing the perceived effect by reducing the mixing of overlapping reflections in the
									* reverberation decay.  \n\n
									*		- Value type   :  float__t					
									*		- Typical values :  0.0 to 1.0				
									*		- Default value : 0.0						
									*		- Value units   : A linear multiplier value
									* \sa <br> float__t flModulationTime \n
									* cfloat__t GetModulationDepth() \n
									* void SetModulationDepth(cfloat__t flModulationDepth) \n
	*/
	float__t flModulationDepth;     // modulation depth
	//@}
	
	
	
	
};
typedef StrongPtr<CTSoundEnvironmentProperty> PSoundEnvironmentProperty;
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
} // namespace
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif 
///////////////////////////////// [citk_CTSoundEnvironmentProperty.h] END
///////////////////////////////// [citk_CTSoundObstructionProperty.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef _CITK_SOUNDOBSTRUCTIONPOPERTY_H_INCLUDED
#define _CITK_SOUNDOBSTRUCTIONPOPERTY_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTSoundObstructionProperty);
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
/*! \class CTSoundObstructionProperty
*	\brief Obstruction Sound Property 
*	\author Stan Adrian . Crystal Interactive Systems
*	adrian.stan@crystalinter.com
*
*	\image html AS.jpg align=left
*	\image latex As.eps "My application" width=10cm
*	\version 1.0
*	\date    2002
*/
class CITK_API CTSoundObstructionProperty : public CTRenderProperty  
{
	
	DECLARE_ALL(CTSoundObstructionProperty, CTRenderProperty);
		
public:
	
	CTSoundObstructionProperty(); /*!< The constructor.*/
	CTSoundObstructionProperty( const CTSoundObstructionProperty *sop ); /*!< The constructor.*/
//	virtual ~CTSoundObstructionProperty(); /*!< The destructor. */
	
	
	/*! \name Set Methds */
	//@{
	void SetOcclusion  (cfloat__t  dB  ,cfloat__t flOcclusionLFRatio,cfloat__t flOcclusionRoomRatio,cfloat__t flOcclusionDirectRatio);
	void SetOcclusion  (cfloat__t  dB );
	void SetOcclusionLFRatio(cfloat__t flOcclusionLFRatio);
	void SetOcclusionRoomRatio(cfloat__t flOcclusionRoomRatio);
	void SetOcclusionDirectRatio(cfloat__t flOcclusionDirectRatio);
	
	
	
	void SetObstruction(cfloat__t  dB,cfloat__t flObstructionLFRatio);
	void SetObstruction(cfloat__t dB);
	void SetObstructionLFRatio(cfloat__t flObstructionLFRatio);
	
	
	void SetExclusion  (cfloat__t  dB  ,cfloat__t flExclusionLFRatio);
	void SetExclusion  (cfloat__t  dB  );
	void SetExclusionLFRatio(cfloat__t flExclusionLFRatio);
	//@}
	
	/*! \name Get Methods */
	//@{
	/*! 
	* \return cfloat__t dB - Occlusion value in dB
	* \sa SetOcclusion   */
	cfloat__t GetOcclusion			() const {return flOcclusion;};            
	
	/*! 
	* \return cfloat__t flOcclusionLFRatio
	* \sa SetOcclusion   */
	cfloat__t GetOcclusionLFRatio	() const {return flOcclusionLFRatio;};     
	
	/*! 
	* \return cfloat__t flOcclusionRoomRatio
	* \sa SetOcclusion   */
	cfloat__t GetOcclusionRoomRatio	() const {return flOcclusionRoomRatio;};   
	
	/*! 
	* \return cfloat__t flOcclusionDirectRatio
	* \sa SetOcclusion   */
	cfloat__t GetOcclusionDirectRatio() const {return flOcclusionDirectRatio;};
	
	
	
	/*! 
	* \return cfloat__t dB - Obstruction value in dB
	* \sa SetObstruction   */
	cfloat__t GetObstruction			() const {return flObstruction;};
    
	
	/*! 
	* \return cfloat__t flObstructionLFRatio
	* \sa SetObstruction   */
	cfloat__t GetObstructionLFRatio	() const {return flObstructionLFRatio;};
	
	
	
	
	/*! 
	* \return cfloat__t dB - Oxclusion value in dB
	* \sa SetExcslusion   */
	cfloat__t GetExclusion			() const {return flExclusion;};             
    
	
	/*! 
	* \return cfloat__t flExclusionLFRatio
	* \sa SetExclusion   */
	cfloat__t GetExclusionLFRatio	() const {return flExclusionLFRatio;};     
	//@}
	
	
	/*! \name Other Methods */
	//@{
	/** \brief Combine 2 Obstruction Properties
	*/
	virtual bool		_Combine( const CTRenderProperty* );
	/*! \brief Compare 2 Obstruction Properties */
	virtual bool		_Compare( const CTRenderProperty* ) const;
	bool				Interpolate(const CTSoundObstructionProperty*);
	/*! \brief Clone an Obstruction Property */
	CTRenderProperty*	Clone() const;
	/*! \brief Write into the stream an Obstruction Property */
	void				WriteToStream( CTStream*, streamlod_t );
	/*! \brief Read from a stream an Obstruction Property */
	bool				ProcessChunk( CTStream*, chunkid_t );
	
	
	/*! \brief Set value of the Sound Obstruction Property with rhs value */
	CTSoundObstructionProperty& Set( const CTSoundObstructionProperty* rhs );
	/*! \brief Compare value of two Sound Obstruction Properties */
//	bool operator == ( CTSoundObstructionProperty*  rhs ) const; 
	/*! \brief Compare value of two Sound Obstruction Properties */
//	bool operator != ( CTSoundObstructionProperty*  rhs ) const; 
	
	
	//@}
	
	/*! \name Check methods */
	//@{
	/*! \return - true if this property has set the Occlusion property or \n - false in other case.*/
	bool HasOcclusion()	const	{return bOcclusion;};
	
	/*! \return true if this property has set the Obstruction property or false in other case.*/
	bool HasObstruction() const	{return bObstruction;};
	
	/*! \return true if this property has set the Exclusion property or false in other case.*/
	bool HasExclusion() const	{return bExclusion;};
	//@}
	
	
	
private :
/*!
* - Occlusion's maximum value 0, specifies no attenuation and hence no occlusion effect. The
* minimum value ,which is -100 dB indicates that the sound source is so occluded that it is
* barely audible. Any value between minimum and maximum indicates partial occlusion
*	- Value type   :  float__t					
*	- Typical values  :  -100.0 to 0.0 
*	- Default value:  0.0						
*	- Value units  :  dB				
* \sa float__t flOcclusionLFRatio \n
* float__t flOcclusionRoomRatio \n
* float__t flOcclusionDirectRatio; \n
* cfloat__t GetOcclusion			()\n
* cfloat__t GetOcclusionLFRatio	()\n
* cfloat__t GetOcclusionRoomRatio	()\n
* cfloat__t GetOcclusionDirectRatio()\n
* void SetOcclusion(cfloat__t  dB )\n
* void SetOcclusionLFRatio(cfloat__t flOcclusionLFRatio)\n
* void SetOcclusionRoomRatio(cfloat__t flOcclusionRoomRatio)\n
* void SetOcclusionDirectRatio(cfloat__t flOcclusionDirectRatio)\n
* void SetOcclusion  (cfloat__t  dB  ,cfloat__t flOcclusionLFRatio,cfloat__t flOcclusionRoomRatio,cfloat__t flOcclusionDirectRatio)\n
	*/
	float__t  flOcclusion;       
	
	
	
	/*!	- The Occlusion LF Ratio specifies the occlusion attenuation at low frequencies relative to the
	* attenuation at high frequencies. The minimum value of 0.0 specifies no attenuation at low
	* frequencies; the maximum value of 1.0 specifies the same low-frequency attenuation as highfrequency
	* attenuation. The default setting of 0.25 specifies that low frequencies be attenuated
	* much less than high frequencies. Note that adjusting Occlusion LF Ratio alone has no effect if
	* Occlusion is set to 0. \n\n
	*	- Value type   :  float__t					
	*	- Typical values :  0.0 to 1.0				
	*	- Default value:  0.25						
	*	- Value units  : A linear multiplier value	
	* \sa float__t flOcclusion \n
	* float__t flOcclusionRoomRatio \n
	* float__t flOcclusionDirectRatio \n
	* cfloat__t GetOcclusion			()\n
	* cfloat__t GetOcclusionLFRatio	()\n
	* cfloat__t GetOcclusionRoomRatio	()\n
	* cfloat__t GetOcclusionDirectRatio()\n
	* void SetOcclusion(cfloat__t  dB )\n
	* void SetOcclusionLFRatio(cfloat__t flOcclusionLFRatio)\n
	* void SetOcclusionRoomRatio(cfloat__t flOcclusionRoomRatio)\n
	* void SetOcclusionDirectRatio(cfloat__t flOcclusionDirectRatio)\n
	* void SetOcclusion  (cfloat__t  dB  ,cfloat__t flOcclusionLFRatio,cfloat__t flOcclusionRoomRatio,cfloat__t flOcclusionDirectRatio)\n
	*/
	float__t flOcclusionLFRatio;   
	
	
	/*! 
	* - The Occlusion Room Ratio and Occlusion Direct Ratio properties control the amount of attenuation
	* and filtering applied to the reflected sound and the direct path, respectively, for a given setting of the
	* Occlusion property. The attenuation obtained at the reference high frequency is determined by
	* multiplying the Occlusion property value by the Occlusion Room Ratio or the Occlusion Direct
	* Ratio.
	* - When both values are set to 0.0, the Occlusion property has no effect. If Occlusion Room Ratio is
	* set to 0.0 and Occlusion Direct Ratio to 1.0, Occlusion is equivalent to Obstruction. If Occlusion
	* Room Ratio is set to 1.0 and Occlusion Direct Ratio to 0.0, Occlusion is equivalent to Exclusion
	* - When the Ratio value is set between 0.0 and 1.0, the effect is equivalent, for low and high
	* frequencies, to scaling the setting of the Occlusion property by that value. If the value is larger than
	* 1.0, that is only true at high frequencies. At low frequencies, the attenuation is such that the filter
	* slope (difference between low frequencies and high frequencies) remains the same as for a setting
	* of 1.0. \n\n
	*	- Value type   :  float__t					 
	*	- Typical values  :  0.0 to 10.0	
	*	- Default value:  1.5		
	*	- Value units  : A linear multiplier value	
	* \sa float__t flOcclusion 
	* float__t flOcclusionLFRatio \n
	* float__t flOcclusionDirectRatio \n
	* cfloat__t GetOcclusion			() \n
	* cfloat__t GetOcclusionLFRatio	() \n
	* cfloat__t GetOcclusionRoomRatio	() \n
	* cfloat__t GetOcclusionDirectRatio() \n
	* void SetOcclusion(cfloat__t  dB ) \n
	* void SetOcclusionLFRatio(cfloat__t flOcclusionLFRatio) \n
	* void SetOcclusionRoomRatio(cfloat__t flOcclusionRoomRatio) \n
	* void SetOcclusionDirectRatio(cfloat__t flOcclusionDirectRatio)\n
	* void SetOcclusion  (cfloat__t  dB  ,cfloat__t flOcclusionLFRatio,cfloat__t flOcclusionRoomRatio,cfloat__t flOcclusionDirectRatio)
	*/
    float__t flOcclusionRoomRatio; 
	
	
	/*! 
	* - The default settings  1.0 for Occlusion Direct Ratio and 1.5 for Occlusion Room Ratio  specify
	* that, compared to the direct sound path, the reflected sound undergoes an additional frequencyindependent
	* attenuation that is equal to half the setting of Occlusion. This creates a natural
	* sensation of occlusion because, in the physical world, it is the occluding wall that acts as the actual
	* sound source in the listener's room. Since the wall radiates sound in only half the space that a
	* sound source in the middle of the room can, it generates significantly less reflected sound than the
	* original source would, if it were located in the room (if Occlusion Room Ratio is set to 1.0, the
	* perceived effect might be more like that of a sound source located in the same room as the listener,
	* but wrapped in a box or container). \n\n
	*	- Value type  : float__t
	*	- Typical values : 0.0 to 10.0		
	*	- Default value :  1.0		
	*	- Value units  :  A linear multiplier value	 
	* \sa float__t flOcclusion \n
	* float__t flOcclusionLFRatio \n
	* float__t flOcclusionRoomRatio \n
	* cfloat__t GetOcclusion()\n
	* cfloat__t GetOcclusionLFRatio	() \n
	* cfloat__t GetOcclusionRoomRatio	() \n
	* cfloat__t GetOcclusionDirectRatio() \n
	* void SetOcclusion(cfloat__t  dB ) \n
	* void SetOcclusionLFRatio(cfloat__t flOcclusionLFRatio) \n
	* void SetOcclusionRoomRatio(cfloat__t flOcclusionRoomRatio) \n
	* void SetOcclusionDirectRatio(cfloat__t flOcclusionDirectRatio) \n
	* void SetOcclusion  (cfloat__t  dB  ,cfloat__t flOcclusionLFRatio,cfloat__t flOcclusionRoomRatio,cfloat__t flOcclusionDirectRatio)
	*/
    float__t flOcclusionDirectRatio; 
	
	
	/*! 
	* - Obstruction's maximum value, 0, specifies no attenuation and hence no obstruction effect. The
	* minimum value which is -100 dB, indicates that the sound source is so obstructed that
	* the direct path from source to listener is negligible - so only the source's reflected sound is
	* audible. Any value between minimum and maximum indicates partial obstruction. \n\n
	*	- Value type   :  float__t	 
	*	- Typical values  :  -100 to 0.0
	*	- Default value :  0.0		 
	*	- Value units  :  dB		 
	* \sa float__t flObstructionLFRatio \n
	* float__t GetObstruction() \n
	* float__t GetObstructionLFRatio() \n
	* void SetObstruction(cfloat__t flObstruction) \n
	* void SetObstructionLFRatio(cfloat__t flObstructionLFRatio) \n
	* void SetObstruction(cfloat__t  flObstruction,cfloat__t flObstructionLFRatio) 
	*/
	float__t  flObstruction;           
	
	
	
	/*! 
	*- Obstruction LF Ratio specifies the obstruction attenuation at low frequencies relative to the
	* attenuation at high frequencies defined by the Obstruction property. The minimum value of 0.0 (the
	* default value) specifies no attenuation at low frequencies; the maximum value of 1.0 specifies the
	* same low-frequency attenuation as high-frequency attenuation. Note that adjusting Obstruction LF
	* Ratio alone has no effect if Obstruction is set to 0. \n\n
	*	- Value type   : float__t				
	*	- Typical values  :  0.0 to 1.0			
	*	- Default value : 0.0					
	*	- Value units  : A linear multiplier value
	* \sa float__t flObstruction  \n         
	* float__t GetObstruction() \n
	* float__t GetObstructionLFRatio() \n
	* void SetObstruction(cfloat__t dB) \n
	* void SetObstructionLFRatio (cfloat__t flObstructionLFRatio) \n
	* void SetObstruction(cfloat__t  dB,cfloat__t flObstructionLFRatio) \n
	*/
    float__t flObstructionLFRatio;   
	
	
	
	/*! 
	* - The Exclusion and Exclusion LF Ratio properties are defined exactly as the corresponding
	* Obstruction and Obstruction LF Ratio properties described above, except that they apply an
	* attenuation and filtering effect to the reflected sound instead of the direct path. This is used to
	* simulate sound in another room coming through an opening in the partition. The value set for the
	* Exclusion property determines the attenuation applied to the reflected sound at the reference high
	* frequency, while the direct path sound is left unaffected.
	* - Exclusion's maximum value, 0, specifies no attenuation of the reflected sound. The minimum
	* value which is -100 dB indicates that the reflected sound is barely audible. Any value
	* between minimum and maximum indicates partial exclusion. \n\n
	*	- Value type   :  float__t				
	*	- Typical values :  -100.0 to 0.0		
	*	- Default value :  0.0					
	*	- Value units  : dB					
	* \sa 
	* float__t flExclusionLFRatio \n
	* float__t GetExclusion() \n
	* float__t GetExclusionLFRatio() \n
	* void SetExclusion  (cfloat__t  dB  ,cfloat__t flExclusionLFRatio) \n
	* void SetExclusion  (cfloat__t  dB) \n
	* void SetExclusionLFRatio  (cfloat__t flExclusionLFRatio ) \n
	*/
	float__t  flExclusion;             
	
	
	
	/*!
	* - The Exclusion LF Ratio property specifies the attenuation at low frequencies relative to the
	* attenuation at high frequencies. The maximum value of 1.0 (the default value) specifies a
	* frequency-independent attenuation. The minimum value of 0.0 specifies no attenuation at low
	* frequencies. Note that adjusting Exclusion LF Ratio alone has no effect if Exclusion is set to 0. \n\n
	*	- Value type   :  float__t					
	*	- Typical values  : -0.0 to 1.0			
	*	- Default value : <td> 1.0						
	*	- Value units  :  A linear multiplier value	
	* \sa 
	* float__t flExclusion \n
	* float__t GetExclusion()  \n
	* float__t GetExclusionLFRatio() \n
	* void SetExclusion  (cfloat__t  dB  ,cfloat__t flExclusionLFRatio) \n
	* void SetExclusion  (cfloat__t  dB) \n
	* void SetExclusionLFRatio  (cfloat__t flExclusionLFRatio ) \n
	*/
    float__t flExclusionLFRatio;  
	
	
	bool bObstruction;
	bool bOcclusion;
	bool bExclusion;
	
};
typedef StrongPtr<CTSoundObstructionProperty> PSoundObstructionProperty;
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
} // namespace
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif 
///////////////////////////////// [citk_CTSoundObstructionProperty.h] END
///////////////////////////////// [citk_HardwareIO.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_HARDWAREIO_H_INCLUDED
#define CITK_HARDWAREIO_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTHardwareIO );
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
namespace citk {
//////////////////////////////////////////////////////////////////////////////
class CITK_API CTHardwareIO : public CTDevice
{
	DECLARE_ALL( CTHardwareIO, CTDevice );
public:
	virtual	int		GetDCount() const { return 0; }
	virtual	int		GetACount() const { return 0; }
	virtual cstr_t	GetADesc( int ) { return NULL; }
	virtual cstr_t	GetDDesc( int ) { return NULL; }
	virtual bool	GetD( int ) { return false; }
	virtual	int		GetARaw( int ) { return 0; }
	virtual	double	GetA( int ) { return 0.0; }
	virtual void	SetD( int, bool ) {}
	virtual	void	SetARaw( int, int ) {}
	virtual	void	SetA( int, const double& ) {}
	virtual bool	CanDRead( int ) { return false; }
	virtual bool	CanDWrite( int ) { return false; }
	virtual bool	CanARead( int ) { return false; }
	virtual bool	CanAWrite( int ) { return false; }
	virtual int		GetAMin( int ) { return 0; }
	virtual int		GetAMax( int ) { return 0; }
	virtual void	Refresh() {}
	// Methods to find IOs with specific description
	int				FindD( cstr_t );
	int				FindA( cstr_t );
};
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
typedef DevicePtr<CTHardwareIO,true> PHardwareIO;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
#endif // !CITK_HARDWAREIO_H_INCLUDED
///////////////////////////////// [citk_HardwareIO.h] END
///////////////////////////////// [citk_MotionBase.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_MOTIONBASE_H_INCLUDED
#define CITK_MOTIONBASE_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTMotionBase);
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////
class CITK_API CTMotionBase : public CTDevice
{
	DECLARE_ALL(CTMotionBase,CTDevice);
public:
	virtual bool		IsReadyForMotion() const = 0;	// Means: Is accepting motion commands "Update"
														// true after preparation completes
														// should turn false after endmotion is called
	virtual bool		IsIdle() const = 0;			// Means: Platform is not preparing or in motion
													// MAY be ready for motion, but motion isn't requested
													// Should turn 'false' after PrepareMotion is called succesfully
													// Should turn 'true' after EndMotion is called
													// Is preparation fails, should turn 'true' again
	virtual bool		PrepareMotion ()=0;			// Prepares platform for motion
	virtual void		EndMotion ()=0;				// Ends readyness for motion
	virtual void		Pause()=0;					// Pauses all motion
	virtual void		Continue()=0;				// Continues all motion
	// Update the motion-platform to match the MotionInfo
	virtual void		Update( const MotionInfo_t& ) = 0;
};
//////////////////////////////////////////////////////////////////////////////
// NOT sharable by default
typedef DevicePtr<CTMotionBase,false> PMotionBase;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
#endif // !CITK_MOTIONBASE_H_INCLUDED
///////////////////////////////// [citk_MotionBase.h] END
///////////////////////////////// [citk_MusicPlayer.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_MUSICPLAYER_H_INCLUDED
#define CITK_MUSICPLAYER_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTMusicPlayer);
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////
class CITK_API CTMusicPlayer : public CTDevice
{
	DECLARE_ALL(CTMusicPlayer,CTDevice);
public:
	// Inherited from CTDevice:
	virtual bool	IsShareable() const { return false; }
	virtual bool	StopOnRelease() const { return true; }
	// Load a specific music file
	virtual bool	Load( cstr_t ) =0;
	// Free the loaded music from memory
	virtual bool	Free() =0;
	// Playback control
	virtual bool	StartPlayback() =0;
	virtual bool	PausePlayback() =0;
	virtual bool	ContinuePlayback() =0;
	virtual bool	StopPlayback() =0;
};
///////////////////////////////////////////////////////////////////////////////
typedef DevicePtr<CTMusicPlayer> PMusicPlayer;		// no device sharing
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_MUSICPLAYER_H_INCLUDED
///////////////////////////////// [citk_MusicPlayer.h] END
///////////////////////////////// [citk_NetworkDevice.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_NETWORKDEVICE_H_INCLUDED
#define CITK_NETWORKDEVICE_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTNetworkDevice);
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////
typedef unsigned char netport_t;
///////////////////////////////////////////////////////////////////////
class CITK_API CTNetworkDevice : public CTDevice
{
	DECLARE_ALL(CTNetworkDevice,CTDevice);
public:
	enum packettype_t { 
		nmNone=0, nmData, nmNewClient, nmHost, nmSessionLost, nmClientLost
	};
	typedef long clientid_t;
	struct packet_t {
		packettype_t	type;
		void*			data;
		int				data_size;
		clientid_t		sender;
	};
	enum {
		CURRENT_SESSION = -1,
		// For GetClientID:
		CLIENTNO_HOST =-1,
		CLIENTNO_ME = 0,
		// Subscriber messages:
		MSG_SESSION		= 0x56C7F14C,		// msg_data=int latest session no.
		MSG_PACKET		= 0x56C7F14D,		// msg_data=pointer to packet_t
		MSG_ENDSEARCH	= 0x56C7F14E		// msg_data=total number of sessions
	};
	// Message priorities
	enum priority_t {
		prLow, prNormal, prHigh, prGuaranteed
	};
	virtual	int			SearchSessions( cdid_t connection_type, cstr_t params =NULL, bool async =false ) =0;
	virtual int			GetSessionCount() =0;
	virtual	String		GetSessionName( int session_no =CURRENT_SESSION ) =0;
	virtual	int			GetSessionNumClients( int session_no =CURRENT_SESSION ) =0;
	virtual	int			GetSessionMaxClients( int session_no =CURRENT_SESSION ) =0;
	virtual	bool		JoinSessionNo( int session_no ) =0;
	virtual	bool		JoinSessionByName( cstr_t session_name ) =0;
	virtual	bool		CreateSession( cdid_t connection_type, cstr_t session_name, int max_client =0, cstr_t params =NULL ) =0;
	virtual	bool		CloseSession() =0;
	virtual	bool		SendPacket( void* data, int data_size, priority_t =prNormal ) =0;
	virtual	bool		SendPacketTo( void* data, int data_size, clientid_t client_id, priority_t =prNormal ) =0;
	virtual int			GetClientCount() = 0;
	virtual clientid_t	GetClientID( int client_no =CLIENTNO_ME ) =0;
	virtual int			NumPacketsWaiting() = 0;
	// Receive the next packet. Returns NULL if no packets are waiting.
	// NOTE: The last packet's data will be deleted!
	virtual packet_t*	ReceivePacket() =0;
	virtual	bool		IsConnected() const =0;
	virtual	bool		IsHost() const =0;
	// Generic way to get client information (like IP, port, etc.)
	virtual String		GetClientInfo( clientid_t =CLIENTNO_ME ) =0;
	// Disconnect specified client from the current session
	virtual bool		DisconnectClient( clientid_t ) =0;
	// Temp maybe: port numbers
	virtual	bool		SendPacket( void* data, int data_size, priority_t, netport_t port ) = 0;
	virtual	bool		SendPacketTo( void* data, int data_size, clientid_t client_id, priority_t, netport_t port ) = 0;
	virtual packet_t*	ReceivePacket(netport_t) = 0;
	virtual int			NumPacketsWaiting(netport_t) =0;
	virtual bool		AddNetworkSubscriber(netport_t)=0;
	// Removes a queue of messages from the subscribersList, emptying the
	//  messages queue and all the stuff done in the structure destructor
	virtual bool		RemoveNetworkSubscriber(netport_t)=0;
	// Like the prev func but for all the "network subscribers"
	virtual void		RemoveAllNetworkSubscribers()=0;
	// Join a session directly without searching for one.
	// The default implementation uses Search/Join.
	// Inherit if you can connect directly.
	virtual bool		JoinSession( cdid_t connection_type, cstr_t params );
};
///////////////////////////////////////////////////////////////////////////////
typedef DevicePtr<CTNetworkDevice,false> PNetworkDevice;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_NETWORKDEVICE_H_INCLUDED
///////////////////////////////// [citk_NetworkDevice.h] END
///////////////////////////////// [citk_NetworkServer.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_NETWORKSERVER_H_INCLUDED
#define CITK_NETWORKSERVER_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTNetworkServer);
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////
class CITK_API CTNetworkServer : public CTNetworkDevice
{
	DECLARE_ALL(CTNetworkServer,CTNetworkDevice);
public:
	//! Create a new session (still in CTNetworkDevice)
//	virtual	bool	CreateSession( cdid_t connection_type, cstr_t session_name, int max_client =0, cstr_t params =NULL ) =0;
	//! Disconnect specified client from the current session (still in CTNetworkDevice)
//	virtual bool	DisconnectClient( clientid_t ) =0;
	//! Joins the specified client to a group.  
	virtual bool	JoinClientGroup( clientid_t joiner, clientid_t join_to, cstr_t group_name ) = 0;
};
///////////////////////////////////////////////////////////////////////////////
typedef DevicePtr<CTNetworkServer,false> PNetworkServer;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_NETWORKSERVER_H_INCLUDED
///////////////////////////////// [citk_NetworkServer.h] END
///////////////////////////////// [citk_SoundDevice.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_SOUND_H_INCLUDED
#define CITK_SOUND_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTSoundDevice);
/////////////////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////
class CTRenderState;
class CTVertexData;
///////////////////////////////////////////////////////////////////////
class CITK_API CTSoundDevice : public CTDevice
{
	DECLARE_ALL( CTSoundDevice, CTDevice );
public:
	// Methods to (un)mute the audio
	virtual bool	Mute()=0;
	virtual bool	Unmute()=0;
	// Change the global volume
	virtual bool	SetVolume( int level_in_dB ) = 0;
	// Start/Stop a specific sound buffer (2D and 3D)
	virtual void	StopSound( DSoundBuffer& ) = 0;
	virtual void	PlaySound( DSoundBuffer& ) = 0;
	virtual void	PauseSound( DSoundBuffer& ) = 0;
	virtual void	ContinueSound( DSoundBuffer& ) = 0;
	virtual void	MuteSound( DSoundBuffer& ) = 0;
	virtual void	UnmuteSound( DSoundBuffer& ) = 0;
	// Update a sound buffer (should be called every frame)
//	virtual void	RenderSound( DSoundBuffer& ) = 0;
	// Update the microphone position/velocity
//	virtual void	Update( CTMicrophone* ) = 0;
	// The New Way!
	virtual void	BeginScene( CTMicrophone* ) = 0;
	virtual void	AddObstruction( CTShape*, const DTransform&, CTRenderState* ) = 0;
	virtual void	AddEnvironment( CTShape*, const DTransform&, CTRenderState* ) = 0;
	virtual void	RenderSound( DSoundBuffer&, CTRenderState* ) = 0;
	virtual void	EndScene() = 0;
	// Capturing
	virtual CTSoundWave*	GetCaptureSoundWave() = 0;
};		   
/////////////////////////////////////////////////////////////////////////////////////////
typedef DevicePtr<CTSoundDevice,true> PSoundDevice;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
#endif // !CITK_SOUND_H_INCLUDED
///////////////////////////////// [citk_SoundDevice.h] END
///////////////////////////////// [citk_Timer.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_TIMER_H_INCLUDED
#define CITK_TIMER_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTTimer);
/////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////
class CITK_API CTTimer : public CTDevice
{
	DECLARE_ALL( CTTimer, CTDevice );
public:
	// Regular interface
	virtual	ctime_t		GetTime() =0;
	virtual	void		Pause() =0;
	virtual	void		Continue() =0;
	// Advanced:
	virtual	ctime_t		GetRawTime() =0;
	virtual	ctime_t		SetTime( ctime_t ) =0;
	// Let the timer start over again (from 0)
	virtual bool		Reset();
	// Sleep / wait for the specified amount of time
	virtual void		Sleep( ctime_t ) = 0;
};
/////////////////////////////////////////////////////////////////////////////
typedef DevicePtr<CTTimer,true> PTimer;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITK_TIMER_H_INCLUDED
///////////////////////////////// [citk_Timer.h] END
///////////////////////////////// [citk_AVPlayer.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_AVPLAYER_H_INCLUDED
#define CITK_AVPLAYER_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTAVPlayer);
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////
// Forwards:
class CTRenderTarget;
class CTTexture;
	
///////////////////////////////////////////////////////////////////////
class CITK_API CTAVPlayer : public CTDevice
{
	DECLARE_ALL( CTAVPlayer, CTDevice);
public:
	// Inherited from CTDevice:
	virtual bool	IsShareable() const { return false; }
	virtual bool	StopOnRelease() const { return true; }
	// Basic control:
	virtual bool	SetSource( cstr_t ) =0;
	virtual void    SetLooping( bool ) =0;    
	virtual bool	IsPlaying() =0;
	// Playback target (background if no texture given)
	virtual bool	SetTarget( CTRenderTarget* ) =0;
	virtual bool	SetTargetTexture( CTTexture* ) =0;
	virtual	bool	GetResolution( int&, int& ) =0;
	virtual bool	GetBitmapData( DBitmap* data ) =0;
	// Playback control
	virtual bool	StartPlayback() =0;
	virtual bool	PausePlayback() =0;
	virtual bool	ContinuePlayback() =0;
	virtual bool	StopPlayback() =0;
	// Advanced media control
	virtual void	FlipImage(bool) = 0;
	virtual void	Mute() = 0;
	virtual void	Unmute() = 0;
	virtual float	GetVolume() = 0;
	virtual bool	SetVolume( float in_dB ) = 0;
	virtual ctime_t	GetTime() = 0;
	virtual bool	SetTime( ctime_t ) = 0;
	virtual ctime_t	GetMediaLength() = 0;
	// Helper methods
	bool			Forward()		{ return SetTime( GetTime() + 750 MILLISECONDS ); }
	bool			Rewind()		{ return SetTime( GetTime() - 750 MILLISECONDS ); }
	bool			VolumeUp()		{ return SetVolume( GetVolume() + 1.0f ); }
	bool			VolumeDown()	{ return SetVolume( GetVolume() - 1.0f ); }
	// Members for consistency with music player
	bool			Load( cstr_t url ) { return SetSource(url); }
	bool			Free() { return SetSource(NULL); }
};
///////////////////////////////////////////////////////////////////////////////
typedef DevicePtr<CTAVPlayer> PAVPlayer;		// no device sharing
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_AVPLAYER_H_INCLUDED
///////////////////////////////// [citk_AVPlayer.h] END
///////////////////////////////// [citk_VoiceChat.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_VOICECHAT_INCLUDED
#define CITK_VOICECHAT_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTVoiceChat);
/////////////////////////////////////////////////////////////////////////////
namespace citk {
// Forward declarations:
class CTSoundWave;
class CTSoundDevice;
///////////////////////////////////////////////////////////////////////////////
//! Abstract class CTVoiceChat containing the base function wich should be implemented
class CITK_API CTVoiceChat : public CTDevice
{
	DECLARE_ALL(CTVoiceChat, CTDevice);
public:
	enum {
		MSG_VOICECHAT_ACTIVE = 0xDF275FDE,
		MSG_VOICECHAT_INACTIVE,
		MSG_VOICECHAT_PAUSE,
		MSG_VOICECHAT_CONTINUE
	};
	// Note about following functions:
	//  They do not replace DoStart functions of device
	//  Those can do a pre-check if this voicechat is possible at all (pre-selection)
	//  Device's DoStop should call StopVoiceChat
	//! Starts the MultiUser ("3d?") VoiceChat on the given network interface (call on started device)
	virtual bool			StartMU( CTNetworkDevice*, CTSoundDevice* ) = 0;
	//! Starts Peer-2-Peer VoiceChat using a certain (implementation specific) connection string (call on started device)
	virtual bool			StartP2P( cstr_t connectionstring, CTSoundDevice* ) = 0;
	//! Starts Peer-2-Peer VoiceChat to the specified user over the current (IV) net device (call on started device)
	virtual bool			StartP2P( CTNetworkDevice*, CTNetworkDevice::clientid_t, CTSoundDevice* ) = 0;
	//! Returns the local connection string;
	virtual String			GetConnectionString() = 0;
	//! Stops the voice chat
	virtual void			StopVoiceChat() = 0;
	//! Returns 'true' if the user is currently in an active voice-chat
	virtual bool			IsActive() = 0;
	//! Pause the microphone broadcast
	virtual bool			PauseBroadcast() = 0;
	//! Resume what Pause did
	virtual bool			ContinueBroadcast() = 0;
	//! Sets the CTSoundWave to use as the source for voice chat (i.e. mike)
	virtual void			SetSourceSoundWave( CTSoundWave* ) = 0;
	//! Gives the CTSoundWave for a specific network client (MultiUser only)
	virtual CTSoundWave*	GetSoundWaveForClient( CTNetworkDevice::clientid_t ) = 0;
	//! Gives the CTSoundWave for all the clients or for P2P
	virtual	CTSoundWave*	GetSoundWaveForAllClients() = 0;
	//! Sets global playback volume for all SoundWaves. Return false if not supported
	virtual bool			SetPlaybackVolume( cfloat__t dB ) = 0;
	//! Set recording volume. return false if not supported
	virtual bool			SetRecordVolume( cfloat__t dB ) = 0;
	//! Set automatic recording volume. return false if not supported
	virtual bool			SetAutoRecordVolume() = 0;
	//! Set threshold for automatic mic on/off. false if not supported 0=always on, 100 is always off
	virtual bool			SetMicThreshold( cfloat__t percent ) = 0;
	//! Set automatic threshold for automatic mic on/off. false if not supported
	virtual bool			SetAutoMicThreshold() = 0;
	//! Disable threshold for automatic mic on/off. (mic always open) false if not supported
	virtual bool			SetDisableMicThreshold() = 0;
	//! Higher quality => bigger latency; 0.0 == automatic control.
	virtual bool			SetBufferQuality( cfloat__t percent ) = 0;
};
///////////////////////////////////////////////////////////////////////////////
typedef DevicePtr<CTVoiceChat> PVoiceChat;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
#endif // !CITK_VOICECHAT_INCLUDED
///////////////////////////////// [citk_VoiceChat.h] END
///////////////////////////////// [citk_AnimatedTexture.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_ANIMATEDTEXTURE_H_INCLUDED
#define CITK_ANIMATEDTEXTURE_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTAnimatedTexture );
/////////////////////////////////////////////////////////////////////////////
namespace citk {
	
/////////////////////////////////////////////////////////////////////////////
class CITK_API CTAnimatedTexture : public CTTexture
{
	DECLARE_ALL( CTAnimatedTexture, CTTexture );
public:
	CTAnimatedTexture();
	int			Load( cstr_t printf_style, int first );
	int			LoadIFL( cstr_t ifl_name );
	void		SetFPS( float fps ) { SetFrameTime( __ftoi((1 SECOND)/fps) ); }
//	int			GetFPS() const { return fps; }
	void		SetFrameTime( ctime_t ft );
	ctime_t		GetFrameTime() const { return frametime; }
	bool		AddFrame( CTTexture* );
	bool		AddFrame( DBitmap* );
	int			GetFrameCount() const { return frames.Count(); }
	CTTexture*	GetFrameNo( int i ) const { return frames.GetNo(i); }
	bool		SetCurrentFrame( int i );
	bool		Step();
	bool		Start();
	bool		Stop();
	// Inherited from CTTexture:
	virtual bool	Load( cstr_t filename );
//	virtual DBitmap*	GetData();
	virtual bool	RemoveData();
	// Inherited from CTCached:
	virtual	bool	DoCache();
	virtual	void	DoFlush();
	virtual size_t	GetSizeEstimate();
	// Streaming:
	virtual void	WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool	ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	virtual ~CTAnimatedTexture();
	virtual void DoAddProperties();
	StrongArray<CTTexture>	frames;
	int					current_frame;
	ctime_t				frametime;
	bool				running;
	void		_SetFrame();
	void		_CopyStuff( CTTexture* );
	UPDATEFUNC	_Update( ctime_t );
};
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTAnimatedTexture> PAnimatedTexture;
/////////////////////////////////////////////////////////////////////////////
} // namespace citk
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITK_ANIMATEDTEXTURE_H_INCLUDED
///////////////////////////////// [citk_AnimatedTexture.h] END
///////////////////////////////// [citk_AVTexture.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_AVTEXTURE_H_INCLUDED
#define CITK_AVTEXTURE_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTAVTexture );
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTAVTexture : public CTTexture
{
	DECLARE_ALL( CTAVTexture, CTTexture );
public:
	// Inherited from CTTexture:
	virtual bool		Load( cstr_t);
	virtual DBitmap*	GetData();
	// AVPlayer methods
	CTAVPlayer*			GetAVPlayer() { return pAVPlayer.IsValid()?pAVPlayer:NULL; }
protected:
	virtual bool DoCache();
	virtual void DoAddProperties();
private:
	PAVPlayer		pAVPlayer;
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTAVTexture> PAVTexture;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_AVTEXTURE_H_INCLUDED
///////////////////////////////// [citk_AVTexture.h] END
///////////////////////////////// [citk_CubeTexture.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_CUBETEXTURE_H_INCLUDED
#define CITK_CUBETEXTURE_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTCubeTexture );
/////////////////////////////////////////////////////////////////////////////
namespace citk {
	
/////////////////////////////////////////////////////////////////////////////
class CITK_API CTCubeTexture : public CTTexture
{
	DECLARE_ALL( CTCubeTexture, CTTexture );
public:
	enum dir_t
	{
		PosX = 0,
		NegX,
		PosY,
		NegY,
		PosZ,
		NegZ,
		COUNT
	};
	void			SetFace( dir_t, CTTexture* tex );
	CTTexture*		GetFace( dir_t ) const;
	// Inherited from CTTexture
	virtual bool	RemoveData();
	// Inherited from CTCached:
	virtual	bool	DoCache();
	virtual	void	DoFlush();
	virtual size_t	GetSizeEstimate();
	// Streaming:
	virtual void	WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool	ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	virtual void	DoAddProperties();
	PTexture		Faces[COUNT];
};
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTCubeTexture> PCubeTexture;
/////////////////////////////////////////////////////////////////////////////
} // namespace citk
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITK_CUBETEXTURE_H_INCLUDED
///////////////////////////////// [citk_CubeTexture.h] END
///////////////////////////////// [citk_BitmapExport.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_BITMAPEXPORT_INCLUDED
#define CITK_BITMAPEXPORT_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTBitmapExport);
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citk {
	
/////////////////////////////////////////////////////////////////////////////
class CTTexture;
/////////////////////////////////////////////////////////////////////////////
class CITK_API CTBitmapExport : public CTImportExport
{
	DECLARE_ALL(CTBitmapExport,CTImportExport);
public:
	bool			Export( cstr_t, CTTexture* );
protected:
	virtual bool	DoExport( cstr_t, CTTexture* ) = 0;
};
/////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTBitmapExport> PBitmapExport;
/////////////////////////////////////////////////////////////////////////////
} // namespace citk
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITK_BITMAP_EXPORT_INCLUDED
///////////////////////////////// [citk_BitmapExport.h] END
///////////////////////////////// [citk_BitmapImport.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_BITMAPIMPORT_INCLUDED
#define CITK_BITMAPIMPORT_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTBitmapImport);
/////////////////////////////////////////////////////////////////////////////
namespace citk {
	
/////////////////////////////////////////////////////////////////////////////
class CITK_API CTBitmapImport : public CTImport
{
	DECLARE_ALL(CTBitmapImport,CTImport);
public:
	// Return the current texture; must be (de)referenced
	CTTexture*			GetTexture() const { return Texture; }
protected:
	StrongPtr<CTTexture> Texture;
	virtual void		SetDefaults();
};
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTBitmapImport> PBitmapImport;
/////////////////////////////////////////////////////////////////////////////
} // namespace citk
//////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITK_BITMAPIMPORT_INCLUDED
///////////////////////////////// [citk_BitmapImport.h] END
///////////////////////////////// [citk_BitmapIO.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_BITMAPIO_INCLUDED
#define CITK_BITMAPIO_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTBitmapIO);
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citk {
	
/////////////////////////////////////////////////////////////////////////////
class CITK_API CTBitmapIO : public CTBitmapImport
{
	DECLARE_ALL(CTBitmapIO,CTBitmapImport);
public:
	CTBitmapIO();
	void			RescanImporters();
	// Pretend we know all protocols
	virtual bool	HandlesProtocol(cstr_t) const { return true; }
protected:
	virtual bool	DoImport( cstr_t );
	virtual ~CTBitmapIO();
private:
	StrongArray<CTBitmapImport> Importers;
	bool			_Import( cstr_t );
};
/////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTBitmapIO> PBitmapIO;
/////////////////////////////////////////////////////////////////////////////
} // namespace citk
//////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITK_BITMAPIO_INCLUDED
///////////////////////////////// [citk_BitmapIO.h] END
///////////////////////////////// [citk_CITK_Stream.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_STREAM_H_INCLUDED
#define CITK_STREAM_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
class CITK_API CITK_Stream : public CTStream
{
public:
	// Constructor
	CITK_Stream();
	// Destructor
	virtual ~CITK_Stream();
	// Level of detail functions
	void				SetLevelOfDetail( streamlod_t lod );
	streamlod_t			GetLevelOfDetail();
	// Number of objects in the stream
	int					GetObjectCount() const;
	// Return a specific object in current stream
	CTStreamed*			GetObjectNo(int) const;
	// Synchronous reading
	bool				Process( CTStreamed* =NULL );
	// Asynchronous reading (stop on <0)
	long				ReadFirstChunk( CTStreamed* =NULL );
	long				ReadNextChunk( long end );
	// Inherited from CTStream:
	virtual bool		Skip( filepos_t nbytes ) { return nbytes>0?SeekBy(nbytes):!nbytes; }
	virtual bool		StartChunk(chunkid_t chid, cstr_t ChuckDesc);
	virtual bool		EndChunk();
	virtual CTStreamed* ReadReference();
	virtual bool		WriteReference( CTStreamed* );
	// Writes the object if it doesn't exist in the stream already
	virtual bool		WriteObject( CTStreamed* ); 
	// Start an 'object data' chunk and write the objects' data in it
	virtual bool		WriteObjectData( CTStreamed* ); 
	virtual bool		WriteObjectChunk( CTStreamed*, chunkid_t chid ); 
								
	// Find and replace a reference in the stream 
	virtual void		ReplaceReferences( CTStreamed* find, CTStreamed* replace );
	// Writes a comment as a generic comment chunk
	virtual bool		WriteComment( cstr_t );
protected:
	bool				IsWriting() const { return writing; }
	bool				IsReading() const { return reading; }
	void				StopReading() { reading=false; }
	CTStreamed*			DataObject;
	bool				HasStreamID(CTStreamed *const);
	streamlod_t			LevelOfDetail;
	streamid_t			GetStreamID(CTStreamed *const);
	void				SetStreamID(CTStreamed *const, streamid_t);
	streamid_t			CreateStreamID(CTStreamed *const);
	CTStreamed*			GetStreamObject(streamid_t);
	void				ProcessObjectDataChunk( int size, CTStreamed* );
	void				ProcessObjectChunk( int size );
	void				ProcessIncludeChunk( CTStreamed* destobject );
	void				ProcessTotalChunk( int size );
	bool				StartStream();
	bool				EndStream();
	void				FlushAllStuff();
	bool				EndChunkStop();
	virtual bool		ReadChunk(CTStreamed*);
	virtual CTStreamed*	ProcessObjectChunkHeader();
	virtual bool		WriteObjectChunkHeader( CTStreamed* );
	virtual bool		SeekBy( filepos_t nbytes ) = 0;
	// This will process a single chunk for this stream
	bool				ProcessChunk( CTStreamed*, chunkid_t, int size );
	// Inherit this for processing custom chunks
	virtual bool		DoCustomChunk( chunkid_t, int size );
private:
	StrongArray<CTStreamed>	idstreams;
	StrongArray<CTStreamed>	obsolete;
	ArrayVal<filepos_t>		chunkpos;
	bool				writing;
	bool				reading;
};
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_STREAM_H_INCLUDED
///////////////////////////////// [citk_CITK_Stream.h] END
///////////////////////////////// [citk_Codec.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_CODEC_H_INCLUDED
#define CITK_CODEC_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTCodec );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
typedef unsigned long fourcc_t;
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTCodec : public CTInterface
{
	DECLARE_ALL( CTCodec, CTInterface );
public:
	// Returns the unique 4CC code for this codec (i.e. 'gzip')
	virtual fourcc_t	GetFourCC() = 0;
	virtual bool		Compress( memoryblock_t in, memoryblock_t &out ) = 0;
	virtual bool		Decompress( memoryblock_t in, memoryblock_t &out ) = 0;
	// Encryption / Decryption
	virtual bool		SetKey( memoryblock_t key ) = 0;
	// Streaming
//	virtual bool		SetInput( memoryblock_t in ) = 0;
//	virtual size_t		GetOutput( memoryblock_t out ) = 0;
};
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_CODEC_H_INCLUDED
///////////////////////////////// [citk_Codec.h] END
///////////////////////////////// [citk_Crypto.h]
#ifndef CTCRYPTO_H_INCLUDED
#define CTCRYPTO_H_INCLUDED
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTCrypto );
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTCrypto : public CTInterface
{
	DECLARE_ALL( CTCrypto, CTInterface );
public:
	//! Get current public key
	virtual bool	GetPublicKey( memoryblock_t& )=0;
	//! Encrypt data using current public key
	virtual bool	EncryptData( const memoryblock_t& in, memoryblock_t& out )=0;
	//! Encrypt data using given public key
	virtual bool	EncryptData( const memoryblock_t& in, memoryblock_t& out, const memoryblock_t& key )=0;
	//! Decrypt data using current private key
	virtual bool	DecryptData( const memoryblock_t& in, memoryblock_t& out )=0;
	//! Decrypt data using given private key OPTIONAL
	virtual bool	DecryptData( const memoryblock_t& in, memoryblock_t& out, const memoryblock_t& key )=0;
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTCrypto> PCrypto;
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif
///////////////////////////////// [citk_Crypto.h] END
///////////////////////////////// [citk_DataBlock.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_DATABLOCK_H_INCLUDED
#define CITK_DATABLOCK_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTDataBlock );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////
class CTDataBlock : public CTStreamed
{
	DECLARE_ALL( CTDataBlock, CTStreamed );
public:
	virtual CTDataBlock*	Copy() = 0;
	virtual void*	Lock() = 0;
	virtual void	Unlock() = 0;
	virtual long	GetSize() = 0;
	virtual bool	Allocate( long ) = 0;
	virtual bool	Resize( long ) = 0;
	virtual bool	Free() = 0;
	// Streaming:
	virtual void	WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool	ProcessChunk( CTStream* stream, chunkid_t chid );
};
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTDataBlock> PDataBlock;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_DATABLOCK_H_INCLUDED
///////////////////////////////// [citk_DataBlock.h] END
///////////////////////////////// [citk_DummyStream.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_DUMMYSTREAM_H_INCLUDED
#define CITK_DUMMYSTREAM_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_FileStreamReader.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_FILESTREAMREADER_H_INCLUDED
#define CITK_FILESTREAMREADER_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTFileStreamReader );
///////////////////////////////////////////////////////////////////////////////
namespace citk {
	
/////////////////////////////////////////////////////////////////////////////
class CITK_API CTFileStreamReader : public CITK_Stream
{
	DECLARE_ALL( CTFileStreamReader, CITK_Stream );
public:
	CTFileStreamReader() : Version(0) {}
	// File version; 
	int				Version;
	// Manual stream creation (used by Write)
	bool			CreateStream( cstr_t filename );
	bool			CloseStream();
	// Writes objects to a new file
	bool			Write ( cstr_t filename, CTStreamed**, int count );
	// Reads a file
	bool			Read ( cstr_t filename );
	// Reads a file; sends the chunks to the specified object
	bool			ReadSendDataTo ( cstr_t filename, CTStreamed* );
	// Only get the file's version number (-1 on error)
	int				GetVersion( cstr_t filename );
	// Inherited open
	virtual bool	OpenURL( cstr_t url );
	// Regular file access (used internally)
	virtual bool	OpenFile( cstr_t filename ) = 0;
	virtual bool	CreateFile( cstr_t filename ) = 0;
	virtual void	CloseFile() = 0;
#ifdef _BIG_ENDIAN
	// These swap the bytes on big-endian machines
	virtual int		ReadInt();
	virtual float	ReadFloat();
	virtual double	ReadDouble();
#endif
protected:
	void			_WriteVersionChunk( int, int );
	int				stream_version;
	// Inherited:
	virtual bool	DoCustomChunk( chunkid_t, int );
};
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
	
/////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_FILESTREAMREADER_H_INCLUDED
///////////////////////////////// [citk_FileStreamReader.h] END
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DECLARE_CLASSDESC( DummyStream );
///////////////////////////////////////////////////////////////////////////////
namespace citk {
	
/////////////////////////////////////////////////////////////////////////////
class CITK_API DummyStream : public CTFileStreamReader
{
	DECLARE_ALL( DummyStream, CTFileStreamReader );
public:
	DummyStream() : filesize(0) {}
	//! Returns current file size; can be called at any moment
	filepos_t		GetPos() const					{ return filesize; }
	// Inherited:
	virtual cstr_t	GetCurrentURL()					{ return _T("dummy:"); }
	virtual filepos_t	GetCurrentPosition()		{ return filesize; }
	virtual bool	OpenFile( cstr_t filename )		{ return false; } 
	virtual bool	CreateFile( cstr_t filename )	{ filesize=0; return true; }
	virtual void	CloseFile() {}
	virtual int		ReadBlock( void*, int )			{ return 0; }
	virtual bool	WriteByte( const char )			{ filesize++; return true; }
	virtual bool	WriteBlock( const void*, int s)	{ filesize+=s; return true; }
private:
	filepos_t		filesize;
	// Inherited:
	bool		SeekBy( filepos_t )					{ return false; }
};
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
	
/////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_DUMMYSTREAM_H_INCLUDED
///////////////////////////////// [citk_DummyStream.h] END
///////////////////////////////// [citk_FileStream.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_FILESTREAM_H_INCLUDED
#define CITK_FILESTREAM_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_SmartFile.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_SMARTFILE_H_INCLUDED
#define CITK_SMARTFILE_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
// DFile is not an exported class, so can't use: class CITK_API .......
class DSmartFile : public DFile
{
public:
	DSmartFile() : original(NULL) {}
	virtual CITK_API ~DSmartFile();
	CITK_API bool		Open( cstr_t, bool read_write =false );
	CITK_API bool		Create( cstr_t, bool read_write =true );
	CITK_API bool		Append( cstr_t );
	CITK_API bool		EndOfFile() const;
	CITK_API void		SeekTo( filepos_t );
	CITK_API void		SeekEnd( filepos_t );
	CITK_API filepos_t	FilePos() const;
	CITK_API filepos_t	FileSize();
protected:
	DFile*				original;
	filepos_t			offset, size;
	CITK_API bool		AttachAndDelete( DFile* );
};
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_SMARTFILE_H_INCLUDED
///////////////////////////////// [citk_SmartFile.h] END
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( FileStream );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
	
/////////////////////////////////////////////////////////////////////////////
class CITK_API FileStream : public CTFileStreamReader
{
	DECLARE_ALL( FileStream, CTFileStreamReader );
public:
	FileStream() : ReadBuffer(NULL) {}
	// Destructor
	~FileStream();
	// Methods for regular file access (from CTFileStreamReader)
	virtual bool		OpenFile( cstr_t filename );
	virtual bool		CreateFile( cstr_t filename );
	virtual void		CloseFile();
	// Inherited from CTStream:
	virtual cstr_t		GetCurrentURL();
	virtual filepos_t	GetCurrentPosition();
	// Reading:
	virtual int			ReadByte();
	virtual int			ReadBlock( void*, int size );
	virtual DynString	ReadString();		// OLD strings are ASCIIZ
	// Writing:
	virtual bool		WriteByte( const char );
	virtual bool		WriteBlock( const void*, int size );
protected:
	String			filename;
	DSmartFile		file;
	// Inherited:
	virtual bool	SeekBy( filepos_t nbytes );
	char*			ReadBuffer;
	filepos_t		ReadBufferSize;
	filepos_t		ReadPos;
};
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
	
/////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_FILESTREAM_H_INCLUDED
///////////////////////////////// [citk_FileStream.h] END
///////////////////////////////// [citk_FrontEnd.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_FRONTEND_H_INCLUDED
#define CITK_FRONTEND_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_ErrorMan.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef	CITK_ERRORMAN_H_INCLUDED
#define	CITK_ERRORMAN_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_Manager.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_MANAGER_H_INCLUDED
#define CITK_MANAGER_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_ServicePtr.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_SERVICEPTR_H_INCLUDED
#define CITK_SERVICEPTR_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
template <class _T>
class ServicePtr : public StrongPtr<_T>
{
public:
	//! Tries to aquire an instance. Returns 'true' if ready for use
	bool	Acquire()	{ if (!ptr) PointTo( _Get() ); return _Check(); }
	//! Finds an existing instance in case we don't want to be the one to acquire
	bool	Find()		{ if (!ptr) PointTo( _Find() ); return _Check(); }
	//! Check whether we point to a valid (started) service
	bool	IsValid() const { return ptr && ptr->IsStarted(); }
	// Indirection operators; make sure the pointer is valid before returning
	_T* operator -> (void) { if (!ptr || !ptr->IsStarted()) _Assert(); return ptr; }
	_T& operator * (void) { if (!ptr || !ptr->IsStarted()) _Assert(); return *ptr; }
	ServicePtr& operator = ( _T* p ) { PointTo(p); return *this; }
	ServicePtr& operator = ( const ServicePtr& sp ) { PointTo((_T*)sp); return *this; }
protected:
	void	_Assert();
	bool	_Check()  { return ptr?(ptr->IsStarted()?true:ptr->Start()):false; }
	static _T*	_Get()  { return (_T*)citk_GetService ( _T::_CD() ); }
	static _T*	_Find() { return (_T*)citk_FindService( _T::_CD() ); }
};
///////////////////////////////////////////////////////////////////////////////
template <class _T>
void ServicePtr<_T>::_Assert() 
{ 
	Acquire();
	if (!ptr) 
		citk_assert(_T("ServicePtr<>::Acquire()")); 
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// The use of these macros is deprecated! Keep your own ServicePtr<> instead.
#define CALL_SERVICE(__class_name,__stuff) \
	{ ServicePtr<__class_name> __ptr; if (__ptr.Acquire()) __ptr.Target()->__stuff; }
#define CALL_SERVICE2(__class_name,__stuff,__value) \
	{ ServicePtr<__class_name> __ptr; if (__ptr.Acquire()) __value = __ptr.Target()->__stuff; }
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_SERVICEPTR_H_INCLUDED
///////////////////////////////// [citk_ServicePtr.h] END
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTManager );
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTManager : public CTLogged
{
	DECLARE_ALL( CTManager, CTLogged );
public:
	CTManager();
	// Makes sure the service is stopped before attempting to delete
	virtual void	Delete();
	// Start the service
	bool			Start();
	// Stop the service (frees ALL allocated resources)
	bool			Stop( bool force_stop =false );
	// Check for service status
	bool			IsStarted() const { return Started; }
protected:
	// Call this in 'DoStart' to add managers that must be stopped before 'this'
	void			AddDependency( CTManager* );
	virtual bool	DoStart();
	virtual bool	DoStop( bool force_stop );
	virtual void	DoAddProperties();
private:
	bool	Started;
	ArrayPtr<CTManager>	Dependencies;
};
///////////////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_MANAGER_H_INCLUDED
///////////////////////////////// [citk_Manager.h] END
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTErrorManager);
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
//typedef ulong	errorcode_t;
/*
#define ET_INFO			0x10000000		// Error type
#define ET_WARNINGOK	0x20000000
#define ET_WARNING		0x90000000
#define ET_ERROR		0xA0000000
#define ET_FATAL		0xB0000000
#define ET_INTERNAL		0xC0000000
#define ET_MASK			0xF0000000		// Masks out the type
#define EVL_0			0x00000000		// Verbose level
#define EVL_1			0x01000000
#define EVL_2			0x02000000
#define EVL_3			0x03000000
#define EVL_4			0x04000000
#define EVL_5			0x05000000
#define EVL_6			0x06000000
#define EVL_7			0x07000000
#define EVL_8			0x08000000
#define EVL_9			0x09000000
#define EVL_10			0x0A000000
#define EVL_11			0x0B000000
#define EVL_12			0x0C000000
#define EVL_13			0x0D000000
#define EVL_14			0x0E000000
#define EVL_15			0x0F000000
#define EVL_MASK		0x0F000000		// Masks out the verbose level
#define EVL_SHIFT		24
*/
///////////////////////////////////////////////////////////////////////
struct errorstruct_t
{
	CTBasic*		object;				// Object that posted the error
	cdid_t			classid;			// ClassID of that object
	errorcode_t		error;				// Error code
	String			msg;				// Message string
};
///////////////////////////////////////////////////////////////////////
class CITK_API CTErrorManager : public CTManager
{
	DECLARE_ALL(CTErrorManager, CTManager);
public:
	// Add a message
	virtual void	Add( errorcode_t, CTBasic*, cstr_t param=NULL ) = 0;
	// Add an info message (this will probably be removed soon)
	virtual void	AddInfo( cstr_t, CTBasic* =NULL ) = 0;
	virtual void	AddWarning( cstr_t, CTBasic* =NULL ) = 0;
	virtual void	AddError( cstr_t, CTBasic* =NULL ) = 0;
	// Iteration through all 'errors'
	virtual int		GetErrorsCount() const = 0;
	virtual errorstruct_t*	GetErrorNo( const int ) const = 0;
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
typedef ServicePtr<CTErrorManager> PErrorManager;
///////////////////////////////////////////////////////////////////////////////
CITK_API void			citk_ErrorCode( errorcode_t, CTBasic*, cstr_t arg =NULL );
CITK_API int			citk_GetErrorsCount();
CITK_API errorstruct_t*	citk_GetErrorNo( const int );
/*
CITK_API void			citk_Info( cstr_t, CTBasic* =NULL );
CITK_API void			citk_Warning( cstr_t, CTBasic* =NULL );
CITK_API void			citk_Error( cstr_t, CTBasic* =NULL );
CITK_API void CDECL		citk_Printf( cstr_t, ... );
*/
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_ERRORMAN_H_INCLUDED
///////////////////////////////// [citk_ErrorMan.h] END
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTFrontEnd);
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citk {
/////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// Generic front-end command
#define FEM_COMMAND			0xFE300000		// Parameter: cstr_t
// Progress function
#define FE_PROGRESS_MAX		100
#define FEM_INITPROGRESS	0xFE300001		// Parameter: cstr_t Name
#define FEM_SETPROGRESS		0xFE300002		// Parameter: int pos (0..MAX)
#define FEM_ENDPROGRESS		0xFE300003		// No parameter
// Watches! Allows for monitoring certain properties
#define FEM_ADDWATCH		0xFE300005		// Parameter: DProperty*
#define FEM_REMOVEWATCH		0xFE300006		// Parameter: DProperty*
#define FEM_DEBUGSTRING		0xFE300007		// Parameter: cstr_t
// Notification for an error / warning / message
#define FEM_ERRORMANMESSAGE	0xFE310001		// Parameter: errorstruct_t*
#define FEM_FILEMANOPEN		0xFE310002		// Parameter: cstr_t
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTFrontEnd : public CTLogged
{
	DECLARE_ALL( CTFrontEnd, CTLogged );
public:
	
	// Default constructor
	// NOTE: This will register the front end with its manager!
	CTFrontEnd();
	// Notification
	// Called by the front-end manager
	virtual void	OnNotify( CTBasic *sender, msgid_t msg, msgdata_t data );
protected:
	// Methods for communication to game:
	void			QuitApp( int exit_code = 0 );
	
	// inherited:
	// For registering with an objects service
	virtual bool	DoRegisterWithService();
	virtual bool	DoUnregisterWithService();
	// Methods for inheritance 
	// Inherit these instead of overriding OnNotify
	virtual void	Command ( cstr_t ) {}
	virtual void	ErrorManagerMessage ( errorstruct_t* error ) {}
	virtual void	FileManagerOpen ( cstr_t filename ) {}
	virtual int		InitProgress ( cstr_t name ) { return 0; }
	virtual void	SetProgress ( int pos ) {}
	virtual void	EndProgress (int=0) {}
	virtual void	AddWatch ( DProperty* ) {}
	virtual void	RemoveWatch ( DProperty* ) {}
	virtual void	DebugString ( cstr_t ) {}
	// Destructor
	// Unregisters with the manager
	virtual ~CTFrontEnd();
};
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTFrontEnd> PFrontEnd;
/////////////////////////////////////////////////////////////////////////////
} // namespace citk
/////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_FRONTEND_H_INCLUDED
///////////////////////////////// [citk_FrontEnd.h] END
///////////////////////////////// [citk_MemoryStream.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_MEMORYSTREAM_H_INCLUDED
#define CITK_MEMORYSTREAM_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
	
/////////////////////////////////////////////////////////////////////////////
class CITK_API MemoryStream : public CITK_Stream
{
public:
	// Destructor
	~MemoryStream();
	virtual bool		OpenURL(cstr_t url) { return false; }
	virtual cstr_t		GetCurrentURL() { return _T("citk://memory"); }
	virtual filepos_t	GetCurrentPosition();
	// Writing:
	bool			CreateDummyStream();
	bool			CreateStream( void*, size_t max_bytes );
	bool			CloseStream();
	virtual bool	WriteBlock( const void*, int size );
	// Reading:
	bool			Read( const void* );
	bool			ReadSendDataTo( const void*, CTStreamed* );
	virtual int		ReadBlock( void*, int size );
protected:
	char*	memory;
	char*	cursor;
	size_t	max_bytes;
	virtual bool	SeekBy( filepos_t nbytes );
};
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
	
/////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_MEMORYSTREAM_H_INCLUDED
///////////////////////////////// [citk_MemoryStream.h] END
///////////////////////////////// [citk_PackageFile.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_PACKAGEFILE_H_INCLUDED
#define CITK_PACKAGEFILE_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTPackageFile );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
/////////////////////////////////////////////////////////////////////////////
class CTPackageFile : public CTLogged
{
	DECLARE_ALL( CTPackageFile, CTLogged);
public:
	//! Open the specified package file
	virtual bool		Open( cstr_t ) = 0;
	virtual void		Close() = 0;
	virtual bool		IsOpened() const = 0;
	// Methods to open a file/stream from this package
	// (Try to use streaming when possible)
	virtual DFile*		OpenFile( cstr_t, long *psize =NULL ) = 0;
	virtual CTStream*	OpenStream( cstr_t, long *psize =NULL ) = 0;
	// FindFirst/Next-like method for iteration
	// Returns: -1 on error, value for next call to FindFrom otherwise
	virtual int			Find( cstr_t, String&, long *psize =NULL ) = 0;
	virtual int			FindFrom( int, cstr_t, String&, long *psize =NULL ) = 0;
	//! Extraction of entire archive to a destination path
	virtual bool		ExtractTo( cstr_t dest_path ) = 0;
};
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTPackageFile> PPackageFile;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
/////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_PACKAGEFILE_H_INCLUDED
///////////////////////////////// [citk_PackageFile.h] END
///////////////////////////////// [citk_SimpleDataBlock.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_SIMPLEDATABLOCK_H_INCLUDED
#define CITK_SIMPLEDATABLOCK_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTSimpleDataBlock );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
	
/////////////////////////////////////////////////////////////////////////////
class CTSimpleDataBlock : public CTDataBlock
{
	DECLARE_ALL( CTSimpleDataBlock, CTDataBlock );
public:
	
	CTSimpleDataBlock();
	CTSimpleDataBlock( CTDataBlock* );
	virtual CTDataBlock*	Copy();
	virtual void*	Lock();
	virtual void	Unlock();
	virtual long	GetSize();
	virtual bool	Allocate( long );
	virtual bool	Resize( long );
	virtual bool	Free();
protected:
	~CTSimpleDataBlock();
private:
	void*	memory;
	long	size;
	int		locked;
};
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTSimpleDataBlock> PDefDataBlock;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
	
/////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_SIMPLEDATABLOCK_H_INCLUDED
///////////////////////////////// [citk_SimpleDataBlock.h] END
///////////////////////////////// [citk_StreamedWavSoundWave.h]
//  Copyright (C) 2002 Crystal Interactive.  All rights reserved.
//  
#ifndef CITK_STREAMEDWAVSOUNDWAVE_H_INCLUDED
#define CITK_STREAMEDWAVSOUNDWAVE_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTStreamedWavSoundWave );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
	
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTStreamedWavSoundWave : public CTSoundWave
{
	DECLARE_ALL( CTStreamedWavSoundWave, CTSoundWave );
public:
	bool			OpenFile( cstr_t fn );				// Opens the file
	void			CloseFile();						// Closes file. After this, return nothing.
	virtual bool	SetSource( cstr_t );					// Open / Close with filename / NULL
	virtual int		GetNumChannels();					// Number of channels (1 or 2)
	virtual int		GetSampleRate();					// Sampled frequency
	virtual int		GetSampleResolution();				// Bits per sample
	virtual ctime_t	GetTimeEstimate();
	virtual int		GetBytesPerSample();
	virtual int		GetBytesPerSecond();
	// Raw PCM interface; returns NULL and 0 for big waves
	virtual void*	GetPCMData();
	virtual long	GetPCMDataSize();
	// Streaming interfaces
	virtual bool	StreamedIsAvailable();
	virtual size_t	StreamedCopyBuffer( void* buffer, size_t buffersize, int& ixx );
	virtual bool	StreamedSeekTo ( ctime_t AbsoluteTime, int& ixx );
	virtual bool	StreamedSeekBy ( ctime_t RelativeTime, int& ixx );
	virtual ctime_t	StreamedGetPosition ( int& ixx );
	// From CTCached
	virtual	bool	DoCache();
	virtual void	DoFlush();
private:
	DFile			File;
	struct swswWaveHeader
	{
		ulong RIFF;
		ulong Size1;
		ulong WAVE;
		ulong fmt;
		ulong Size2;
		ushort Format_1;
		ushort NumChannels;
		ulong SampleRate;
		ulong ByteRate;
		ushort BlockAlign;
		ushort BitsPerSample;
		bool IsUsable();
	} wavefmt;
	int				WaveSize;
	int				HeaderSize;
	bool			FixIxx( int& ixx );
	ArrayVal<int>	Positions;
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTStreamedWavSoundWave> PsStreamedWavSoundWave;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
	
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_STREAMEDWAVSOUNDWAVE_H_INCLUDED
///////////////////////////////// [citk_StreamedWavSoundWave.h] END
///////////////////////////////// [citk_Spectator.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_SPECTATOR_H_INCLUDED
#define CITK_SPECTATOR_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_Viewport.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_VIEWPORT_H_INCLUDED
#define CITK_VIEWPORT_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CITK_API DViewport
{
public:
	// Draw-list for this viewport (for GUI, HUD etc..); use with PF_DRAW_xxx
	SafeArray<CTProcess>	DrawList;
	// Constructor
	DViewport();
	// Destructor
	~DViewport();
	double			GetAspectRatio();
	double			GetHorizontalFOV();
	double			GetVerticalFOV();
	float__t		CalcSqrLODDistance( cvec_t worldpos );
	void			AutoCameraRect ();
	void			SetHorCameraRect ( float x1, float x2 );
	void			SetVerCameraRect ( float y1, float y2 );
	void			SetCameraRect ( float x1, float y1, float x2, float y2 );
	bool			GetCameraRect ( float &x1, float &y1, float &x2, float &y2 );
	const DRect<float>& GetCameraRect() const { return camrect; }
	void			SetViewportRect ( float x1, float y1, float x2, float y2 );
	bool			GetViewportRect ( float &x1, float &y1, float &x2, float &y2 );
	const DRect<float>& GetViewportRect() const { return vprect; }
	void			SetDeviceRect ( int x1, int y1, int x2, int y2 );
	bool			GetDeviceRect ( int& x1, int& y1, int& x2, int& y2 );
	const DRect<int>& GetDeviceRect() const { return devrect; }
	void			SetDevice( CTRenderTarget* );
	void			SetCamera( CTCamera* );
	CTRenderTarget*	GetDevice() const;
	CTCamera*		GetCamera() const;
	bool			IsStereo() const { return Stereo!=NULL; }
	bool			IsVisible() const;
	void			SetBackgroundPicture( CTTexture* );
	CTTexture*		GetBackgroundPicture() { return BackgroundPicture; }
	void			SetBackgroundColor( const Color32& );
	Color32			GetBackgroundColor() { return BackgroundColor; }
	bool			Render();
	DRenderContext*	GetRenderContext();
	// TEMP for Philippe:
	void			InvalidateCamera( bool update_frustum =true );
	// Stereo mode methods:
	void			SetStereo( bool =true );
	void			SetStereoEyeSeparation( cfloat__t sep );
	DViewport*		GetStereoViewport() const { return Stereo; }
	// Transform methods:
	const DTransform&	GetWorldToCameraTransform() const { return CameraTransform; }
	const DTransform&	GetCameraToViewTransform() const { return ViewTransform; }
	const DTransform&	GetViewToDeviceTransform();
	const DTransform&	GetWorldToViewTransform();
	cfloat__t		GetQuality() const { return Quality; }
	void			SetQuality( cfloat__t nq ) { Quality = nq; }
	ctime_t			GetMaxFadeTime() const { return MaxFadeTime; }
	void			SetMaxFadeTime( ctime_t nt ) { MaxFadeTime = nt; }
	// Register a shape to be rendered; when_to_draw determines whether the
	// shape will be drawn before or after the world tree (or both)
	void			AddDrawable( CTProcess*, flags_t when_to_draw = PF_DRAW_POST ); // flag will be stored in CTProcess
	void			RemoveDrawable( CTProcess* );
private:
	int				DevResX, DevResY;
	float__t		StereoDist, SqrLODBias, Quality;
	ctime_t			MaxFadeTime;
	DTransform		CameraTransform;				// World -> Camera
	DTransform		ViewTransform;					// Camera -> View
	DTransform		DeviceTransform;				// View -> Device
	DTransform		WorldViewTransform;				// World -> View
	Color32			BackgroundColor;
	PTexture		BackgroundPicture;
	DViewport*		Stereo;
	DFlags			Hints;
	DRect<float>	camrect;
	DRect<float>	vprect;
	DRect<int>		devrect;
	StrongPtr<CTRenderTarget>	renderdevice;			// No DevicePtr<>
	SafePtr<CTCamera>			camera;
	DRenderContext	RenderContext;
	bool			UpdateCameraRect();
	void			UpdateViewportRect();
	void			UpdateDeviceRect();
	bool			UpdateFrustum();
	void			UpdateViewTransform();
	// Updates DevResX/DevResy/DevMinX/DevMinY
	bool			UpdateDeviceResolution();
	void			UpdateRenderContext();
};
					
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_VIEWPORT_H_INCLUDED
///////////////////////////////// [citk_Viewport.h] END
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTSpectator);
DLL_DECLARE_CLASSDESC(CTBasicSpectator);
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
	
///////////////////////////////////////////////////////////////////////////////
#define	SPEC_AUDIO		0x00000001
#define	SPEC_VIDEO		0x00000100
#define	SPEC_MOTION		0x00010000
#define	SPEC_ENABLE		0x01000000
#define	SPEC_DEVICESOK	0x02000000
#define	SPEC_PAUSED		0x04000000
/////////////////////////////////////////////////////////////////////////////
class CITK_API CTSpectator : public CTLogged
{
	DECLARE_ALL(CTSpectator, CTLogged);
public:
	// Renders screen, updates sound and motion
	virtual void Process() =0;
	// Returns 'true' if the spectator is activated
	virtual bool IsActive() const =0;
	// (Un)Register with the EngineManager
	virtual bool DoRegisterWithService();
	virtual bool DoUnregisterWithService();
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTBasicSpectator : public CTSpectator
{
	DECLARE_ALL(CTBasicSpectator, CTSpectator);
public:
	// Default constructor:
	CTBasicSpectator();
	DViewport		Viewport;
	// Inherited. Disables the spectator
	virtual void	Delete();
	// Inherited from CTSpectator. Renders screen, updates sound and motion
	virtual void	Process();		
	bool			Enable();
	void			Disable();
	// Pause will temporarily disable all output functionality in the process function.
	// Spectator will not render or play sound or motion
	// Spectator WILL update its state, so Disable and so still work.
	//
	// Works only in "Enabled" mode, in other modes the spectator will be set to continue
	bool			Pause();
	void			Continue();
	bool			IsEnabled() { return Flags.Any(SPEC_ENABLE); }
	virtual bool	IsActive() const { return State == ssActive; }
	bool			IsPaused() const { return Flags.Any(SPEC_PAUSED); }
	CTCamera*		GetCamera() const { return camera; }
	virtual void	SetCamera( CTCamera* c );
	CTMicrophone*	GetMicrophone() const { return mic; }
	virtual void	SetMicrophone( CTMicrophone* c );
	CTEntity*		GetSensor() const { return sensor->GetEntity(); }
	virtual void	SetSensor( CTEntity* c );
	CTSoundDevice*	GetAudioDevice() const { return audiodev; }
	CTRenderTarget*	GetVideoDevice() const { return videodev; }
	CTMotionBase*	GetMotionDevice() const { return motiondev; }
	void			SetAudioDevice(CTSoundDevice* d) { audiodev = d; }
	void			SetVideoDevice(CTRenderTarget* d){ videodev = d; }
	void			SetMotionDevice(CTMotionBase* d) { motiondev = d; }
	void			UseAudio( bool =true );
	void			UseVideo( bool =true );
	void			UseMotion( bool =true );
private:
	PRenderTarget		videodev;
	PSoundDevice		audiodev;
	PMotionBase			motiondev;
	SafePtr<CTCamera>			camera;
	SafePtr<CTMicrophone>		mic;
	PMotionSensor				sensor;
	bool	didvideoshow;
	bool	WasVisible; // Now, spec may only once Show the VideoDev.
	// If once it was shown (visible) and NOT visible later, Disable()
	enum specstate_t { ssIdle, ssDevices, ssActive, ssPaused } State;
	DFlags			Flags;
	bool			UpdateDevices( bool generate_errors = false);
	void			ReleaseDevices();
	void			UpdateStates();
	void			SetState( specstate_t );
};
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTBasicSpectator> PBasicSpectator;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
	
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_SPECTATOR_H_INCLUDED
///////////////////////////////// [citk_Spectator.h] END
///////////////////////////////// [citk_PlugInLib.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_PLUGINLIB_H_INCLUDED
#define CITK_PLUGINLIB_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_VersionMan.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef	CITK_VERSIONMAN_H_INCLUDED
#define	CITK_VERSIONMAN_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTVersionManager);
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////////////
typedef int version_t;
struct VersionInfo_t
{
	cstr_t		ID;
	version_t	No;
	cstr_t		Name;
	VersionInfo_t() {}
	VersionInfo_t( cstr_t id, version_t no, cstr_t name =NULL ) : ID(id), No(no), Name(name?name:id) {}
};
///////////////////////////////////////////////////////////////////////
class CITK_API CTVersionManager : public CTManager
{
	DECLARE_ALL( CTVersionManager, CTManager );
public:
	// Check (add) version information (returns false if incompatible)
	virtual bool			CheckVersionInfo( const VersionInfo_t& ) = 0;
	virtual bool			CheckVersionInfos( const VersionInfo_t*, int num ) = 0;
	// Iterate through version information (from 0 till first NULL)
	virtual const VersionInfo_t& GetVersionInfoNo( int no ) = 0;
};
///////////////////////////////////////////////////////////////////////
typedef ServicePtr<CTVersionManager> PVersionManager;
///////////////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
#endif // !CITK_VERSIONMAN_H_INCLUDED
///////////////////////////////// [citk_VersionMan.h] END
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTPlugInLib);
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTPlugInLib : public CTBasic
{
	DECLARE_ALL( CTPlugInLib, CTBasic );
public:
	//! Register all classes with the class-manager (calls DoClasses)
	bool			RegisterClasses();
	//! Unregister all classes from this lib
	void			UnregisterClasses();
	//! Get the current number of instances of classes in this lib
	int				GetInstancesCount() const;
	//! Get the number of classes in this lib (calls DoClasses)
	int				GetClassCount();
	//! Get a specific ClassDesc from this plug-in
	ClassDesc*		GetClassNo( int i ) const;
	//! Returns the URL for this plug-in
	virtual	String	GetURL() const = 0;
	//! Returns the name of the product this plug-in is a part of
//	virtual	String	GetProductName() const = 0;
protected:
	// Add a class to the lib. Call this in DoClass()
	void			AddClass( ClassDesc* );
	// Add some version info
	void			AddVersion( cstr_t ver_id, version_t ver_no, cstr_t ver_name =NULL );
	virtual void	DoClasses() = 0;
	// Destructor; will unregister all classes
	virtual ~CTPlugInLib();
private:
	// Classes in this lib
	ArrayPtr<ClassDesc>	Classes;
	// Version control info
	ArrayVal<VersionInfo_t>	Versions;
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// Use this define in YourPlugIn::DoClasses
#define ADDCLASS(__name)			DECLARE_CLASSDESC(__name); AddClass( CD(__name) )
#define ADDVERSION(__name)			AddVersion( _T(#__name), __name )
#define ADDVERSION2(__name,__desc)	AddVersion( _T(#__name), __name, __desc )
///////////////////////////////////////////////////////////////////////////////
#define IMPLEMENT_PLUGINCLASS2_HELPER(name,copyright)					\
	DECLARE_CLASSDESC( name );											\
	static class name : public citk::CTPlugInLib {						\
		DECLARE_ALL( name, CTPlugInLib );								\
		virtual void DoClasses();										\
		virtual String GetURL() const { return String(_T(#name)); }		\
	public:																\
		name() { ADDVERSION(CITK_CORE_VER); ADDVERSION(CITK_TYPES_VER); }	\
	} __citk_plugin;													\
	IMPLEMENT_CLASSDESC_ABSTRACT(0,name,CTPlugInLib,0,copyright,_T(#name) _T(" plug-in"),_T(#name),_T(#name))
// This define declares and implements your own plugin-class.
// You only need one pair of braces filled with ADDCLASS(xxx)
#define IMPLEMENT_PLUGINCLASS2(name,copyright)							\
	IMPLEMENT_PLUGINCLASS2_HELPER(name,copyright)						\
	bool CDECL RegisterPlugInClasses_##name() {							\
		return __citk_plugin.RegisterClasses(); }						\
	void name::DoClasses()
// Same thing, but for DLLs (hybrid plug-ins)
#define DLL_IMPLEMENT_PLUGINCLASS2(name,copyright)						\
	IMPLEMENT_PLUGINCLASS2_HELPER(name,copyright)						\
	extern "C" DLL_EXPORT void* CDECL citk_DllMain2( int ver ) {		\
		if (ver!=CITK_CORE_VER) return NULL;							\
		return &__citk_plugin; }										\
	DLL_EXPORT bool CDECL RegisterPlugInClasses_##name() {				\
		return __citk_plugin.RegisterClasses(); }						\
	citk::CTPlugInLib* citk_ThisPlugInLib() { return &__citk_plugin; }	\
	void name::DoClasses()
// Same as IMPLEMENT_PLUGINCLASS2, but without the copyright argument
#define IMPLEMENT_PLUGINCLASS(__name)									\
	IMPLEMENT_COPYRIGHT_NOBODY()										\
	IMPLEMENT_PLUGINCLASS2(__name,Nobody)
#define DLL_IMPLEMENT_PLUGINCLASS(__name)								\
	IMPLEMENT_COPYRIGHT_NOBODY()										\
	DLL_IMPLEMENT_PLUGINCLASS2(__name,Nobody)
// Use this define to register all the classes in a statically linked plug-in (LIB)
#define REGISTER_CLASSES(__name)										\
	bool CDECL RegisterPlugInClasses_##__name();						\
	RegisterPlugInClasses_##__name();
// Use this define to register all the classes in a hybrid plug-in (DLL)
#define DLL_REGISTER_CLASSES(__name)									\
	DLL_IMPORT bool CDECL RegisterPlugInClasses_##__name();				\
	RegisterPlugInClasses_##__name();
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_PLUGINLIB_H_INCLUDED
///////////////////////////////// [citk_PlugInLib.h] END
///////////////////////////////// [citk_VectorBezierTrack.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
#ifndef CITK_VECTORBEZIERTRACK_H_INCLUDED
#define CITK_VECTORBEZIERTRACK_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTVectorBezierTrack );
///////////////////////////////////////////////////////////////////////////////
namespace citk {
	
/////////////////////////////////////////////////////////////////////////////
class CITK_API CTVectorBezierTrack : public CTVectorTrack
{
	DECLARE_ALL( CTVectorBezierTrack, CTVectorTrack );
public:
	// Track methods:
	void			SetValue( ctime_t, cvec_t, cvec_t in, cvec_t out );
	// Key methods:
//	Vector*			GetKeyIn( int ) const;
//	Vector*			GetKeyOut( int ) const;
	virtual void	Precalc();
	virtual Vector	_Interpolate( int key, cfloat__t ) const;
	virtual Vector	_InterpolateD1( int key, cfloat__t ) const;
	virtual Vector	_InterpolateD2( int key, cfloat__t ) const;
	// For streaming / networking:
	virtual void	WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool	ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	virtual keyframe_t*	NewKey( keyframe_t* );
};
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTVectorBezierTrack> PVectorBezierTrack;
/////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_VECTORBEZIERTRACK_H_INCLUDED
///////////////////////////////// [citk_VectorBezierTrack.h] END
///////////////////////////////// [citk_VectorTCBTrack.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
#ifndef CITK_VECTORTCBTRACK_H_INCLUDED
#define CITK_VECTORTCBTRACK_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTVectorTCBTrack );
///////////////////////////////////////////////////////////////////////////////
namespace citk {
	
/////////////////////////////////////////////////////////////////////////////
class CITK_API CTVectorTCBTrack : public CTVectorTrack
{
	DECLARE_ALL( CTVectorTCBTrack, CTVectorTrack );
public:
	// Track methods:
	void			SetValue( ctime_t, cvec_t, cfloat__t t, cfloat__t c, cfloat__t b );
	virtual void	Precalc();
	virtual Vector	_Interpolate( int key, cfloat__t ) const;
	virtual Vector	_InterpolateD1( int key, cfloat__t ) const;
	virtual Vector	_InterpolateD2( int key, cfloat__t ) const;
	// For streaming / networking:
	virtual void	WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool	ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	virtual keyframe_t*	NewKey( keyframe_t* );
};
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTVectorTCBTrack> PVectorTCBTrack;
/////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_VECTORTCBTRACK_H_INCLUDED
///////////////////////////////// [citk_VectorTCBTrack.h] END
///////////////////////////////// [citk_QuatSmoothTrack.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_QUATSMOOTHTRACK_H_INCLUDED
#define CITK_QUATSMOOTHTRACK_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTQuatSmoothTrack );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
	
/////////////////////////////////////////////////////////////////////////////
class CITK_API CTQuatSmoothTrack : public CTQuatTrack
{
	DECLARE_ALL( CTQuatSmoothTrack, CTQuatTrack );
public:
	virtual void	Precalc();
	// For streaming / networking:
protected:
	virtual Quaternion	_Interpolate( ctime_t, int key ) const;
	virtual keyframe_t*	NewKey( keyframe_t* );
};
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTQuatSmoothTrack> PQuatSmoothTrack;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
	
/////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_QUATSMOOTHTRACK_H_INCLUDED
///////////////////////////////// [citk_QuatSmoothTrack.h] END
///////////////////////////////// [citk_QuatTCBTrack.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_QUATTCBTRACK_H_INCLUDED
#define CITK_QUATTCBTRACK_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTQuatTCBTrack );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
	
/////////////////////////////////////////////////////////////////////////////
class CITK_API CTQuatTCBTrack : public CTQuatTrack
{
	DECLARE_ALL( CTQuatTCBTrack, CTQuatTrack );
public:
	// Track methods:
	void			SetValue( ctime_t, const Quaternion&, cfloat__t t, cfloat__t c, cfloat__t b );
	virtual void	Precalc();
	// For streaming / networking:
	virtual void	WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool	ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	virtual Quaternion	_Interpolate( ctime_t, int key ) const;
	virtual keyframe_t*	NewKey( keyframe_t* );
};
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTQuatTCBTrack> PQuatTCBTrack;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
	
/////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_QUATTCBTRACK_H_INCLUDED
///////////////////////////////// [citk_QuatTCBTrack.h] END
///////////////////////////////// [citk_XMLStream.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_XMLSTREAM_H_INCLUDED
#define CITK_XMLSTREAM_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( XMLStream );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
	
/////////////////////////////////////////////////////////////////////////////
class CITK_API XMLStream : public CITK_Stream
{
	DECLARE_ALL( XMLStream, CITK_Stream );
public:
	// Destructor
	~XMLStream();
	// Inherited open
	virtual bool	OpenURL( cstr_t url ) { return Read(url); }
	// Creates a file
	bool			CreateStream ( cstr_t filename );
	// Reads a file
	bool			Read ( cstr_t filename );
	// Reads a file; sends the chunks to the specified object
	bool			ReadSendDataTo ( cstr_t filename, CTStreamed* );
	
	// Closes the current stream
	bool			CloseStream ();
	virtual cstr_t	GetCurrentURL();
	virtual filepos_t GetCurrentPosition();
	// Reading:
	virtual bool		ReadChunk( CTStreamed* );
	virtual int			ReadByte();
	virtual DynString	ReadString();
	virtual int			ReadBlock( void*, int size );
	virtual double		ReadDouble();
	virtual float		ReadFloat();
	virtual int			ReadInt();
	virtual Vector		ReadVector();
	virtual Quaternion	ReadQuat();
	virtual Matrix		ReadMatrix();
	virtual flags_t		ReadTransform( DTransform& );
	// Writing:
	virtual bool	WriteByte( const char );	// "<char value='d'/>"
	virtual bool	WriteString( cstr_t );		// "<string value=""/>"
	virtual bool	WriteBlock( const void*, int size );	// "<!CDATA[[..]]>"
	virtual bool	WriteReference( CTStreamed* ); 
	
	virtual bool	WriteDouble( const double& );
	virtual bool	WriteFloat( const float );
	virtual bool	WriteInt( const int );
	virtual bool	WriteVector(const Vector&);
	virtual bool	WriteQuat(const Quaternion&);
	virtual bool	WriteMatrix(const Matrix&);
	virtual bool	WriteTransform(const DTransform&, flags_t );
	virtual bool	WriteComment( cstr_t );
	virtual bool	StartChunk(chunkid_t chid, cstr_t chunkdesc );
	virtual bool	EndChunk();
protected:
	String			filename;
	DSmartFile		file;
//	DScriptReader	xml;
	int				indent;
	// Inherited:
	virtual bool	SeekBy( filepos_t nbytes ) { /*ignore*/ return true; }
};
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
	
/////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_XMLSTREAM_H_INCLUDED
///////////////////////////////// [citk_XMLStream.h] END
///////////////////////////////// [citk_ActivityTypes.h]
#ifndef CITK_ACTIVITYTYPES_H_INCLUDED
#define CITK_ACTIVITYTYPES_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk
{
struct CITK_API variant_t
{
	enum vartype_t {
		vtNull=0, vtAnyValue, vtBool, vtInt, vtString, vtFloat, vtObject, vtVoidPtr, vtArray=8
	}				type;
	union {
		bool		_bool;
		int			_int;
		float		_float;
		void*		_voidptr;
	};
	SafePtr<CTAggregated>	_object;
	ArrayVal<variant_t>		_array;
	DynString				_string;
	variant_t() { type = vtNull; }
	explicit variant_t(bool b) { _bool = b; type = vtBool; }
	explicit variant_t(int i) { _int = i; type = vtInt; }
	explicit variant_t(float f) { _float = f; type = vtFloat; }
	explicit variant_t(cstr_t s) { _string = s; type = vtString; }
	explicit variant_t(CTAggregated* a) { _object = a; type = vtObject; }
	explicit variant_t(void* a) { _voidptr = a; type = vtVoidPtr; }
	variant_t& operator = (bool b) { _bool = b; type = vtBool; return SELF; }
	variant_t& operator = (int i) { _int = i; type = vtInt; return SELF; }
	variant_t& operator = (float f) { _float = f; type = vtFloat; return SELF; }
	variant_t& operator = (cstr_t s) { _string = s; type = vtString; return SELF; }
	variant_t& operator = (CTAggregated* a) { _object = a; type = vtObject; return SELF; }
	variant_t& operator = (void* a) { _voidptr = a; type = vtVoidPtr; return SELF; }
	static bool IsCompatible( vartype_t a, vartype_t b );
};
}; // namespace
using citk::variant_t;
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif //#ifndef CITK_ACTIVITYTYPES_H_INCLUDED
///////////////////////////////// [citk_ActivityTypes.h] END
///////////////////////////////// [citk_VariantList.h]
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#ifndef CITK_VARIANTLIST_H_INCLUDED
#define CITK_VARIANTLIST_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk
{
class CITK_API DVariantList
{
public:
	// Con- and desctuction
	DVariantList() {}
	DVariantList( const DVariantList& );
	~DVariantList();
	DVariantList& operator = ( const DVariantList& );
	void	SetVariable( cstr_t , const variant_t& );
	bool	GetVariable( cstr_t, variant_t& ) const;
	cstr_t	GetVariable( cstr_t ) const;
	
	void	RemoveAll();
	void	RemoveVariable( cstr_t );
	bool	HasVariable( cstr_t ) const;
	int		GetVariableCount() const;
	cstr_t	GetVariableNameNo( int ) const;		// may return NULL
	cstr_t	GetVariableValueNo( int ) const;	// may return NULL
private:
	struct vlitem_t {
		String		name;
		variant_t	value;
	};
	DHashTable<vlitem_t> hash_table;
	
	static hash_t _GetHash( cstr_t );
};
}; // namespace
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_VARIANTLIST_H_INCLUDED
///////////////////////////////// [citk_VariantList.h] END
///////////////////////////////// [citk_Application.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
//  citk_Application.h
//
#ifndef CITK_APPLICATION_H_INCLUDED
#define CITK_APPLICATION_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTApplication);
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////////////
class CITK_API CTApplication : public CTManager
{
	DECLARE_ALL(CTApplication, CTManager);
public:
	// The main function.
	// Does any initialisation and (optionally) calls Engine->Loop()
	virtual int		Main( int argc, cstr_t argv[] ) = 0;
	// Signals the application to stop and (optionally) calls Engine->StopLoop()
	virtual void	Quit( int ) = 0;
};
///////////////////////////////////////////////////////////////////////////////////////
typedef ServicePtr<CTApplication> PApplication;
///////////////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
#endif // !CITK_APPLICATION_H_INCLUDED
///////////////////////////////// [citk_Application.h] END
///////////////////////////////// [citk_ClassMan.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef	CITK_CLASSMAN_H_INCLUDED
#define	CITK_CLASSMAN_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTClassManager);
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////
class CITK_API CTClassManager : public CTManager
{
	DECLARE_ALL(CTClassManager,CTManager);
public:
	// Class registration
	virtual void		RegisterClass( ClassDesc* ) = 0;
	virtual void		UnregisterClass( ClassDesc* ) = 0;
	// Find a class descriptor
	virtual ClassDesc*	FindClassDesc( const cdid_t ) = 0;
	virtual ClassDesc*	FindClassDescByName( cstr_t ) = 0;
	virtual ClassDesc*	FindClassDescByNameIC( cstr_t ) = 0;
	virtual int			FindCompatibleClasses( const cdid_t, ArrayPtr<ClassDesc> &array_of_classdesc ) = 0;
	// Create an instance
	virtual CTBasic*	CreateClass( const cdid_t ) = 0;
	virtual CTBasic*	CreateClassByName( cstr_t ) = 0;
	virtual CTBasic*	CreateClassByNameIC( cstr_t ) = 0;
	// Iterate through all available classes
	virtual int			GetClassDescCount() const = 0;
	virtual ClassDesc*	GetClassDescNo( const int ) const = 0;
	// Conversion ClassName <-> ClassID
	virtual String		GetClassName( const cdid_t ) = 0;
	virtual cdid_t		GetClassID( cstr_t ) = 0;
};
///////////////////////////////////////////////////////////////////////
typedef ServicePtr<CTClassManager> PClassManager;
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
#define REGISTER_CLASS(a) \
	DLL_DECLARE_CLASSDESC( a ); \
	CALL_SERVICE( CTClassManager, RegisterClass( CD(a) ) )
///////////////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
#define MSG_CLASSMANAGER_CLASS_REGISTERED	0x07FCF9F7
#define MSG_CLASSMANAGER_CLASS_UNREGISTERED	0x07FCF9F8
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
#endif // !CITK_CLASSMAN_H_INCLUDED
///////////////////////////////// [citk_ClassMan.h] END
///////////////////////////////// [citk_CodecManager.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
//  citk_CodecManager.h
//
#ifndef CITK_CODECMANAGER_H_INCLUDED
#define CITK_CODECMANAGER_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTCodecManager);
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////////////
class CITK_API CTCodecManager : public CTManager
{
	DECLARE_ALL(CTCodecManager, CTManager);
public:
	// Requery the class-manager for all registered codecs
	virtual int		RegisterAllCodecs() = 0;
	// Compression / decompression methods
	virtual bool	Compress( fourcc_t fcc_out, memoryblock_t in, memoryblock_t &out, memoryblock_t *key ) = 0;
	virtual bool	Decompress( fourcc_t fcc_in, memoryblock_t in, memoryblock_t &out ) = 0;
	// Encryption / decryption methods
	virtual bool	Encrypt( fourcc_t fcc_out, memoryblock_t in, memoryblock_t &out, memoryblock_t key ) = 0;
	virtual bool	Decrypt( fourcc_t fcc_in, memoryblock_t in, memoryblock_t &out, memoryblock_t key ) = 0;
};
///////////////////////////////////////////////////////////////////////////////////////
typedef ServicePtr<CTCodecManager> PCodecManager;
///////////////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
#endif // !CITK_CODECMANAGER_H_INCLUDED
///////////////////////////////// [citk_CodecManager.h] END
///////////////////////////////// [citk_CollisionMan.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_COLLISIONMAN_H_INCLUDED
#define CITK_COLLISIONMAN_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTCollisionManager );
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#define CM_NONE					0x00000000
#define CM_ALL					0xFFFFFFFF
#define CM_HEIGHT				0x80000000
#define CM_ALLBUTHEIGHT			0x7FFFFFFF
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTCollisionManager : public CTManager
{
	DECLARE_ALL( CTCollisionManager, CTManager );
public:
	enum response_t { rtNone, rtSimple, rtWitnessed };
	// Detect collisions (returns the number of callbacks called)
	virtual int			Detect() = 0;
	// Detect collisions for this object only
	virtual int			Detect( CTEntity * ) = 0;
	// Add an entity to be detected
	virtual bool		Add( CTEntity*, response_t =rtNone, collisionmask_t = CM_ALL ) = 0;
	// Change the response / collision properties of an entity
//	virtual bool		Change( CTEntity*, int, collisionmask_t = CM_ALL ) = 0;
	// Remove an entity from detection
	virtual void		Remove( CTEntity* ) = 0;
	// Remove all entities
	virtual void		RemoveAll() = 0;
	// Pair override (all pairs are enabled by default)
	virtual void		EnablePair( CTEntity*, CTEntity* ) = 0;
	virtual void		DisablePair( CTEntity*, CTEntity* ) = 0;
	
	// Vertical distance query
	virtual double		DistanceDown( const Vector&, Normal *normal=NULL, void* cache=NULL ) = 0;
	virtual double		HeightDown( const Vector&, Normal *normal=NULL, void* cache=NULL ) = 0;
	virtual double		Height( const Vector&, Normal *normal=NULL, void* cache=NULL ) = 0;
	virtual void*		NewCache() = 0;
	virtual void		DeleteCache( void* ) = 0;
};
///////////////////////////////////////////////////////////////////////////////
typedef ServicePtr<CTCollisionManager> PCollisionManager;
///////////////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_COLLISIONMAN_H_INCLUDED
///////////////////////////////// [citk_CollisionMan.h] END
///////////////////////////////// [citk_DeviceMan.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef	CITK_DEVICEMAN_H_INCLUDED
#define	CITK_DEVICEMAN_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTDeviceManager);
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTDeviceManager : public CTManager
{
	DECLARE_ALL(CTDeviceManager, CTManager);
public:
	virtual void			AddDevice( CTDevice* ) = 0;
	virtual int				GetDevicesCount() const = 0;
	virtual CTDevice*		GetDeviceNo( int ) const = 0;
	virtual CTDevice*		ObtainDevice( cdid_t classid, bool share =false ) = 0;
	virtual CTDevice*		ObtainDeviceByName( cstr_t, bool share =false ) = 0;
	virtual CTDevice*		ObtainDevice( cdid_t classid, devid_t, bool share =false ) = 0;
	virtual CTDevice*		ObtainDeviceByName( cstr_t, devid_t, bool share =false ) = 0;
	virtual bool			ShareDevice( CTDevice* ) = 0;
	virtual void			ReleaseDevice( CTDevice* ) = 0;
	virtual void			CreateAllDevices() = 0;
	// inherited:
//	CTBrowseInfo*			CreateBrowseInfo( CTBrowseInfo* Parent, int subdir_id );
};
///////////////////////////////////////////////////////////////////////////////
typedef ServicePtr<CTDeviceManager> PDeviceManager;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
// Declared outside the namespace:
CITK_API citk::CTDevice*	citk_ObtainDevice( citk::cdid_t classid, bool share =false );
CITK_API citk::CTDevice*	citk_ObtainDeviceByName( cstr_t classname, bool share =false );
CITK_API citk::CTDevice*	citk_ObtainDevice( citk::cdid_t classid, citk::devid_t, bool share =false );
CITK_API citk::CTDevice*	citk_ObtainDeviceByName( cstr_t classname, citk::devid_t, bool share =false );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_DEVICEMAN_H_INCLUDED
///////////////////////////////// [citk_DeviceMan.h] END
///////////////////////////////// [citk_DownloadMan.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_DOWNLOADMAN_H_INCLUDED
#define CITK_DOWNLOADMAN_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTDownloadManager );
///////////////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTDownloadManager : public CTManager
{
	DECLARE_ALL( CTDownloadManager, CTManager );
public:
	virtual bool	SetServer( cstr_t server ) =0;
	virtual bool	SetResource( cstr_t file ) =0;
	virtual int		GetStatusCode() =0;
	virtual size_t	GetContentSize() =0;
	virtual size_t	GetAvailableData() =0;
	virtual size_t	ReadData( void*, size_t ) =0;
};
///////////////////////////////////////////////////////////////////////
typedef ServicePtr<CTDownloadManager> PDownloadManager;
///////////////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_DOWNLOADMAN_H_INCLUDED
///////////////////////////////// [citk_DownloadMan.h] END
///////////////////////////////// [citk_EngineMan.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_ENGINEMAN_H_INCLUDED
#define CITK_ENGINEMAN_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTEngineManager);
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
namespace citk {
/////////////////////////////////////////////////////////////////////////////
class CITK_API CTEngineManager : public CTManager
{
	DECLARE_ALL(CTEngineManager,CTManager);
public:
	// Enters the actual engine-loop.
	// Returns only when StopLoop() gets called.
	virtual void		Loop() = 0;
	// Stops the inner loop (as soon as possible)
	virtual bool		StopLoop() = 0;
	// Pause the inner loop (loop keeps running, but DoFrame does nothing)
	virtual bool		Pause() = 0;			
	// Continue the inner loop
	virtual bool		Continue() = 0;			
	// Obtain the current state of the loop
	virtual bool		IsLooping() const = 0;
	virtual bool		IsPaused() const = 0;
	// Process one frame. Called by Loop().
	// For example: while (!kbhit()) Engine->DoFrame();
	virtual ctime_t		DoFrame() = 0;
	// Lock/Unlock the engine update (locked in DoFrame)
	virtual void		Lock() = 0;
	virtual void		Unlock() = 0;
	// Process a new rendercontext (called by viewport)
	virtual bool		DoRenderContext( DRenderContext* ) = 0;
	virtual bool		RenderAudio( CTSoundDevice*, CTMicrophone* ) = 0;
	// Get the current frame ID (increased in DoFrame)
	virtual frameid_t	GetFrameID() const = 0;
	// Register a shape to be rendered; when_to_draw determines whether the
	// shape will be drawn before or after the world tree (or both)
//	virtual void		AddDrawable( CTEntity*, flags_t when_to_draw =PF_DRAW_POST ) = 0;
//	virtual void		RemoveDrawable( CTEntity* ) = 0;
	// Spectator functions:
	virtual void		RegisterSpectator( CTSpectator* ) = 0;
	virtual void		UnregisterSpectator( CTSpectator* ) = 0;
//	virtual void		EnableSpectators() = 0;
//	virtual void		DisableSpectators() = 0;
	// Environment functions
	virtual void		AddEnvironment( CTEnvironment* ) = 0;
	virtual void		RemoveEnvironment( CTEnvironment* ) = 0;
	virtual CTEnvironment* GetDefaultEnvironment() = 0;
	// Find the environment at a specific point in world-space
	virtual CTEnvironment* FindEnvironment( const Vector&, CTGroup* Root ) = 0;
};
///////////////////////////////////////////////////////////////////////
typedef ServicePtr<CTEngineManager> PEngineManager;
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Engine lock object
//  Locks the engine-loop in the constructor; unlocks it on destruction
class DEngineLock
{
private:
	CTEngineManager *Engine;
public:
	DEngineLock() { Engine = (CTEngineManager*)citk_FindService(CD(CTEngineManager)); if (Engine) Engine->Lock(); }
	DEngineLock( CTEngineManager* em ) : Engine(em) { if (Engine) Engine->Lock(); }
	~DEngineLock() { if (Engine) Engine->Unlock(); }
};
///////////////////////////////////////////////////////////////////////////////////////
} // namespace citk
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITK_ENGINEMAN_H_INCLUDED
///////////////////////////////// [citk_EngineMan.h] END
///////////////////////////////// [citk_EntityManager.h]
#ifndef CITK_ENTITYMANAGER_H_INCLUDED
#define CITK_ENTITYMANAGER_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#define MSG_ENTITYMANAGER_ROOT_ADDED	0x34A236AF
#define MSG_ENTITYMANAGER_ROOT_REMOVED	0xBB268DD6
#define MSG_ENTITYMANAGER_ROOT_CHANGED	0xA6B94A51
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTEntityManager);
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
class CTEntity;
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTEntityManager : public CTManager
{
	DECLARE_ALL( CTEntityManager, CTManager );
public:
	// Roots
	virtual void	AddRoot( CTGroup* root )=0;
	virtual void	RemoveRoot( CTGroup* root )=0;
	// Find
	virtual CTEntity* FindEntity( cstr_t Path, bool ForceLoad=false )=0; // only return if there is 1
	virtual CTEntity* FindRelativeEntity( CTEntity*, cstr_t RelPath, bool ForceLoad=false )=0; // only return if there is 1, relative path to selected entity
	virtual DynString GetPath( CTEntity* )=0; // only return path if Root is known. Root always included in path
	virtual DynString GetRelativePath( CTEntity* a, CTEntity* b )=0; // To find A from B
	virtual bool	HasUniquePath( CTEntity* )=0; // check if there are other objects with same path
	virtual bool	IsPathLike( cstr_t path, cstr_t wildcard )=0; // does special IsLike for paths
	virtual bool	IsPathLike( CTEntity*, cstr_t wildcard )=0; // does special IsLike, on the entity's path
	virtual int		FindEntities_SLOW( cstr_t wildcard, ArrayPtr<CTEntity>&, bool ForceLoad=false )=0; // add to list, does not empty it. return n_added
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
typedef ServicePtr<CTEntityManager> PEntityManager;
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // #ifndef CITK_ENTITYMANAGER_H_INCLUDED
///////////////////////////////// [citk_EntityManager.h] END
///////////////////////////////// [citk_FileMan.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_FILEMAN_H_INCLUDED
#define CITK_FILEMAN_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTFileManager );
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
namespace citk {
class CTCrypto;		// forward for SetPassword
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTFileManager : public CTManager
{
	DECLARE_ALL( CTFileManager, CTManager );
public:
	// Packages:
	virtual bool		OpenPackage( cstr_t ) = 0;
	virtual int			OpenPackages( cstr_t ) = 0;
	virtual bool		ClosePackage( cstr_t ) = 0;
	// Streams (caller must ->Delete() the stream object):
	virtual CTStream*	OpenStream( cstr_t ) = 0;
	virtual CTStream*	CreateStream( cstr_t ) = 0;
	// Files (caller must 'delete' the file object):
   	virtual DFile*		OpenFromPackage( cstr_t, long *size =NULL ) = 0;
   	virtual DFile*		Open( cstr_t, bool const read_write =false ) = 0;
	virtual DFile*		Create( cstr_t, bool const read_write =true ) = 0;
	virtual DFile*		Append( cstr_t ) = 0;
	// Querying:
	struct findstruct_t : public DOS::findstruct_t {
//		String			name;			// File name (includes path)
//		long			size;			// File size (-1 == unknown)
//		String			wc;				// Used internally; don't change!
//		long			fh;				// Used internally; don't change!
//		void*			fd;				// Used internally; don't change!
		int				vdl;			// Used internally; don't change!
	};
	// File searching (searches packages as well as the path)
	virtual bool		FindFirst( cstr_t wildcard, findstruct_t&, bool vdl =true ) = 0;
	virtual bool		FindNext( findstruct_t& ) = 0;
	virtual void		FindClose( findstruct_t& ) = 0;
	// Add/Remove paths
	virtual void		AddPath( cstr_t ) = 0;
	virtual void		RemovePath( cstr_t ) = 0;
	// Password protected files
	virtual bool		SetPassword( const memoryblock_t&, CTCrypto* =NULL ) = 0;
	virtual bool		GetPassword( memoryblock_t& ) = 0;
};
///////////////////////////////////////////////////////////////////////
typedef ServicePtr<CTFileManager> PFileManager;
///////////////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_FILEMAN_H_INCLUDED
///////////////////////////////// [citk_FileMan.h] END
///////////////////////////////// [citk_FrontEndMan.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_FRONTENDMAN_H_INCLUDED
#define CITK_FRONTENDMAN_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTFrontEndManager );
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CTFrontEnd;
///////////////////////////////////////////////////////////////////////////////
#define FRONTENDMESSAGE(a)		citk_Notify(this,(msgid_t)(a));
#define FRONTENDMESSAGE2(a,b)	citk_Notify(this,(msgid_t)(a),(msgdata_t)(b));
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTFrontEndManager : public CTManager
{
	DECLARE_ALL( CTFrontEndManager, CTManager );
public:
	// Send a notification to all front-ends
	virtual void		Notify( CTBasic *sender, msgid_t message, msgdata_t=0 ) = 0;
	// Add a front-end to this manager
	virtual void		AddFrontEnd( CTFrontEnd* ) = 0;
	// Remove a front-end from this manager
	virtual void		RemoveFrontEnd( CTFrontEnd* ) = 0;
	// Iteration through available frontends
	virtual int			GetFrontEndCount() = 0;
	virtual CTFrontEnd*	GetFrontEndNo( int ) = 0;
};
///////////////////////////////////////////////////////////////////////
typedef ServicePtr<CTFrontEndManager> PFrontEndManager;
///////////////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_FRONTENDMAN_H_INCLUDED
///////////////////////////////// [citk_FrontEndMan.h] END
///////////////////////////////// [citk_MemoryMan.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
//  citk_MemoryMan.h
//
#ifndef CITK_MEMORYMAN_H_INCLUDED
#define CITK_MEMORYMAN_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTMemoryManager);
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////////////
class CITK_API CTMemoryManager : public CTManager
{
	DECLARE_ALL(CTMemoryManager, CTManager);
public:
	// Allocate memory
	virtual void*	Alloc( size_t size ) = 0;
	// Free memory
	virtual void	Free( void* ptr ) = 0;
};
///////////////////////////////////////////////////////////////////////////////////////
typedef ServicePtr<CTMemoryManager> PMemoryManager;
///////////////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
#endif // !CITK_MEMORYMAN_H_INCLUDED
///////////////////////////////// [citk_MemoryMan.h] END
///////////////////////////////// [citk_NetworkMan.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_NETWORKMAN_H_INCLUDED
#define CITK_NETWORKMAN_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTNetworkManager );
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CTNetworkDevice;
class CTStreamed;
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTNetworkManager : public CTManager
{
	DECLARE_ALL( CTNetworkManager, CTManager );
public:
	// New:
	virtual bool		UseNetDevice( CTNetworkDevice* ) = 0;
//Stayers:
	// Send a message to an specific object across the network (CTNamed only)
	virtual bool		SendMessage( netid_t who, msgid_t msg, long param =0 ) = 0;
	virtual bool		SendData( netid_t who, msgid_t msg, msgdata_t data, int msgdata_size ) = 0;
	virtual bool		SendStream( CTStreamed *str, streamlod_t lod ) = 0;
	virtual bool		SendChunk( CTStreamed *str, chunkid_t chid ) = 0;
	// Request an unique ID for use across the network
	virtual netid_t		RequestNetID()  = 0;
	// Not called directly! Only via CTStreamed::SetNetID
	virtual netid_t		AddNetObject( CTStreamed* ) = 0;
	virtual void		RemoveNetObject( CTStreamed* ) = 0;
	// Set or Get the Streamlod used when synchronizing the NetObjects
	virtual void		SetSynchronizeStreamLod( streamlod_t ) = 0;
	virtual streamlod_t	GetSynchronizeStreamLod() = 0;
	// Finds a specific object by it's NetID
	// NOTE: This can post a request for an object if it's not known at this time
	virtual CTStreamed*	FindNetObject( netid_t ) = 0;
	////// For iteration (property page)
	virtual int			GetNetObjectCount() = 0;
	virtual CTStreamed*	GetNetObjectNo( int ) = 0;
	// DUNNO YET:
	// Is synched? (got all remote netid-ed objects)
	virtual bool		IsSynchronized() = 0;
	// Send a message to all joined computer's CTApplications
	virtual bool		SendApplicationMessage( msgid_t msg, long param =0 ) = 0;
	virtual bool		SendApplicationData( msgid_t msg, msgdata_t data, int msgdata_size ) = 0;
	// TO BE GONE:
/*
	// Create a new game (Maximum supported clients as default)
	virtual bool		StartAsHost( const int maxclients =0 ) = 0;		
	// Joins a running game (After a call to QuerySessions)
	virtual bool		StartAsClient( const int GameToJoin ) = 0;	
	// Stop the running session
	virtual bool		StopNetwork() = 0;								
	///// General methods:
	virtual bool		IsHosting() const = 0;
	virtual bool		IsNetworked() const = 0;
//	virtual bool		IsSynchronized() const = 0; //stayer
	// Iterate connected clients
	virtual int			GetClientCount() const = 0;
	virtual int			GetClientNo( int ) const = 0;
	// Get my own Client-ID
	virtual int			GetClientID() const = 0;
	///// Tunneled methods (Usually directed to network device):
	virtual int			GetSessionCount() const = 0;
	virtual bool		GetSessionInfo( int s, String& name, int& nump, int& maxp ) = 0;
	virtual int			QuerySessions() = 0;
	virtual void		SetSessionName( cstr_t name ) = 0;
	virtual void		SetClientName( cstr_t name ) = 0;
*/
};
///////////////////////////////////////////////////////////////////////////////
typedef ServicePtr<CTNetworkManager> PNetworkManager;
///////////////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_NETWORKMAN_H_INCLUDED
///////////////////////////////// [citk_NetworkMan.h] END
///////////////////////////////// [citk_PhysicsMan.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_PHYSICSMAN_H_INCLUDED
#define CITK_PHYSICSMAN_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTPhysicsManager );
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
class CTAbstractDyna;
class CTSpring;
class CTConstraint;
class CTEnvironment;
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTPhysicsManager : public CTManager
{
	DECLARE_ALL( CTPhysicsManager, CTManager );
public:
	
	virtual void	UpdatePhysics( ctime_t frametime ) = 0;
	virtual	void	AddDyna( CTAbstractDyna* ) = 0;
	virtual	void	RemoveDyna( CTAbstractDyna* ) = 0;
	virtual void	AddSpring( CTSpring* ) = 0;
	virtual void	RemoveSpring( CTSpring* ) = 0;
	virtual void	AddConstraint( CTConstraint* ) = 0;
	virtual void	RemoveConstraint( CTConstraint* ) = 0;
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
typedef ServicePtr<CTPhysicsManager> PPhysicsManager;
///////////////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_PHYSICSMAN_H_INCLUDED
///////////////////////////////// [citk_PhysicsMan.h] END
///////////////////////////////// [citk_PlugInMan.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_PLUGINMANAGER_H_INCLUDED
#define CITK_PLUGINMANAGER_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTPlugInManager );
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTPlugInManager : public CTManager
{
	DECLARE_ALL( CTPlugInManager, CTManager );
public:
	// Load a specific plugin lib
	virtual	CTPlugInLib*	Load( cstr_t ) = 0;
	// Load all default libs
	// Returns the number of successfully loaded plug-ins
	virtual int				LoadAll( cstr_t path =NULL ) = 0;
	// Iterate through all loaded plug-ins
	virtual int				GetPlugInCount() = 0;
	virtual CTPlugInLib*	GetPlugInLib( int ) = 0;
	virtual String			GetPlugInName( int ) = 0;		// Actual file name
};
///////////////////////////////////////////////////////////////////////
typedef ServicePtr<CTPlugInManager> PPlugInManager;
///////////////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_PLUGINMANAGER_H_INCLUDED
///////////////////////////////// [citk_PlugInMan.h] END
///////////////////////////////// [citk_PropertyPageMan.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_PROPERTYPAGEMAN_H_INCLUDED
#define CITK_PROPERTYPAGEMAN_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTPropertyPageManager );
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTPropertyPageManager : public CTManager
{
	DECLARE_ALL( CTPropertyPageManager, CTManager );
public:
	// Show the property page(s) for a specific object
	virtual bool	ShowPropertyPage( CTBasic* object, bool asynchronous =false ) = 0;
};
///////////////////////////////////////////////////////////////////////
typedef ServicePtr<CTPropertyPageManager> PPropertyPageManager;
///////////////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_PROPERTYPAGEMAN_H_INCLUDED
///////////////////////////////// [citk_PropertyPageMan.h] END
///////////////////////////////// [citk_RenderStateMan.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_RENDERSTATEMAN_H_INCLUDED
#define CITK_RENDERSTATEMAN_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTRenderStateManager );
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
class CTRenderState;
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTRenderStateManager : public CTManager
{
	DECLARE_ALL( CTRenderStateManager, CTManager );
public:
	// Add a material to this manager
	virtual void			Add( CTRenderState* ) = 0;				
	// Remove a material from this manager
	virtual void			Remove( CTRenderState* ) = 0;			
	// Delete all materials
	virtual void			RemoveAll() = 0;
	// Create a new material (by name)
	// ('found' becomes 'true' if the material was found, 'false' if created)
	virtual CTRenderState*		Create( cstr_t, bool *found = NULL ) = 0;
	// Search for a material (by name)
	virtual CTRenderState*		Find( cstr_t ) = 0;				
	// Returns the default material (never NULL)
	virtual CTRenderState*		GetDefault() const = 0;
	// Iterate through all the available textures
	virtual int					GetRenderStateCount() = 0;
	virtual CTRenderState*		GetRenderStateNo( int ) = 0;
};
///////////////////////////////////////////////////////////////////////////////
typedef ServicePtr<CTRenderStateManager> PRenderStateManager;
///////////////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_RENDERSTATEMAN_H_INCLUDED
///////////////////////////////// [citk_RenderStateMan.h] END
///////////////////////////////// [citk_SceneCacheMan.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_SCENECACHEMAN_H_INCLUDED
#define CITK_SCENECACHEMAN_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTSceneCacheManager);
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CTGroup;
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTSceneCacheManager : public CTManager
{
	DECLARE_ALL( CTSceneCacheManager, CTManager );
public:
	enum {
		MSG_SCENE_LOADED = 0x1F9B8E6D	// after load, data = CTGroup*
	};
	// Flush cache
	virtual void		Flush() = 0;							
	// Flush entire cache
	virtual void		FlushAll() = 0;							
	// Load a new scene from relative path
	virtual bool		Load( CTGroup*, cstr_t filename, cfloat__t scaling =1.0f, bool cache =true ) = 0;
	// Load a new scene from absolute path
	virtual bool		LoadFile( CTGroup*, cstr_t filename, cfloat__t scaling =1.0f, bool cache =true ) = 0;
	// Set the path used by 'Load()'
	virtual void		SetPath( cstr_t ) = 0;
	// Check to see wether a file is present in the cache
	virtual CTGroup*	QueryCache( cstr_t filename ) = 0;
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
typedef ServicePtr<CTSceneCacheManager> PSceneCacheManager;
///////////////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_SCENECACHEMAN_H_INCLUDED
///////////////////////////////// [citk_SceneCacheMan.h] END
///////////////////////////////// [citk_ServiceManager.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_SERVICEMAN_H_INCLUDED
#define CITK_SERVICEMAN_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTServiceManager );
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTServiceManager : public CTManager
{	
	DECLARE_ALL( CTServiceManager, CTManager );
public:
	virtual CTManager*	GetService( ClassDesc* ) = 0;
	virtual CTManager*	GetService( cdid_t ) = 0;
	virtual CTManager*	GetServiceByName( cstr_t ) = 0;
	virtual CTManager*	FindService( ClassDesc* ) = 0;
	virtual CTManager*	FindService( cdid_t ) = 0;
	virtual CTManager*	FindServiceByName( cstr_t ) = 0;
	virtual int			GetServiceCount() const = 0;
	virtual CTManager*	GetServiceNo( int ) const = 0;
	virtual bool		SetClassFactory( ClassDesc* ) = 0;
	// inherited:
//	CTBrowseInfo*		CreateBrowseInfo( CTBrowseInfo* Parent, int subdir_id );
};
///////////////////////////////////////////////////////////////////////////////
typedef ServicePtr<CTServiceManager> PServiceManager;
///////////////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_SERVICEMAN_H_INCLUDED
///////////////////////////////// [citk_ServiceManager.h] END
///////////////////////////////// [citk_SoundMan.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_SOUNDMAN_H_INCLUDED
#define CITK_SOUNDMAN_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTSoundManager );
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CTSoundWave;
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTSoundManager : public CTManager
{
	DECLARE_ALL( CTSoundManager, CTManager );
public:
	// Add a wave file to the managed list
	virtual void			Add( CTSoundWave* ) = 0;			
	// Remove a wave file from the managed list
	virtual void			Remove( CTSoundWave* ) = 0;			
	
	// Delete all waves
	virtual void			RemoveAll() = 0;						
	// Flush the wave cache
	virtual void			Flush() = 0;							
	// Flush the entire cache
	virtual void			FlushAll() = 0;							
	// Create a wave
//	virtual CTPCMSoundWave*	Create( cstr_t ) = 0;
	// Load a wave into an existing object
//	virtual bool			Load( CTPCMSoundWave*, cstr_t ) = 0;
	// Load a new wave from file (relative) and manage it
	virtual CTSoundWave*	Load( cstr_t ) = 0;
	// Load a new wave from file (absolute path) and manage it
	virtual CTSoundWave*	LoadFile( cstr_t ) = 0;
	// Create a CTSoundWave instance for a selected extension IC (with dot!, eg. ".ogg")
	virtual CTSoundWave*	CreateSoundWaveForFileType( cstr_t ext ) = 0;
	// Search for a wave in list
	virtual CTSoundWave*	Find( cstr_t ) = 0;
	// Set the path used by 'Load()'
	virtual void			SetPath( cstr_t ) = 0;
	// Iterate through all the available soundwaves
	virtual int				GetSoundWaveCount() = 0;
	virtual CTSoundWave*	GetSoundWaveNo( int ) = 0;
};
///////////////////////////////////////////////////////////////////////
typedef ServicePtr<CTSoundManager> PSoundManager;
///////////////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_SOUNDMAN_H_INCLUDED
///////////////////////////////// [citk_SoundMan.h] END
///////////////////////////////// [citk_TextureMan.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_TEXTUREMAN_H_INCLUDED
#define CITK_TEXTUREMAN_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTTextureManager );
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTTextureManager : public CTManager
{
	DECLARE_ALL( CTTextureManager, CTManager );
public:
	// Add texture to list
	virtual void			Add( CTTexture* ) = 0;	
	// Remove texture			
	virtual void			Remove( CTTexture* ) = 0;
	// Delete all textures
	virtual void			RemoveAll() = 0;						
	// Flush cache
	virtual void			Flush() = 0;							
	// Flush entire cache
	virtual void			FlushAll() = 0;							
	// Create a new texture
	virtual CTTexture*		Create( cstr_t ) = 0;
	// Load a file into an existing texture
	virtual bool			Load( CTTexture*, cstr_t ) = 0;
	// Load a new texture from a file
	virtual CTTexture*		Load( cstr_t ) = 0;
	// Search for a texture
	virtual CTTexture*		FindTexture( cstr_t ) = 0;
	// Set the path used by 'Load()'
	virtual void			SetPath( cstr_t ) = 0;
	// Iterate through all the available textures
	virtual int				GetTextureCount() = 0;
	virtual CTTexture*		GetTextureNo( int ) = 0;
};
///////////////////////////////////////////////////////////////////////
typedef ServicePtr<CTTextureManager> PTextureManager;
///////////////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_TEXTUREMAN_H_INCLUDED
///////////////////////////////// [citk_TextureMan.h] END
///////////////////////////////// [citk_UpdateMan.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_UPDATEMAN_H_INCLUDED
#define CITK_UPDATEMAN_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTUpdateManager);
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////
class CITK_API CTUpdateManager : public CTManager
{
	DECLARE_ALL(CTUpdateManager,CTManager);
public:
	// Call any events for which the time has come
	virtual void	Update( ctime_t ) = 0;				
	// Remove all update/messages for a specific object
	virtual void	RemoveAny( CTAggregated* ) = 0;
	// Updates:
	virtual void	AddUpdate( CTAggregated* object, updatefunc_t, ctime_t delay =UM_TIME_ASAP, int count=UM_COUNT_FOREVER ) = 0;
	virtual void	ChangeUpdateTime( CTAggregated*, updatefunc_t, ctime_t delay ) = 0;
	virtual void	RemoveUpdate( CTAggregated* object, updatefunc_t ) = 0;
	virtual void	RemoveUpdates( CTAggregated* object ) = 0;
	// Messages:
	virtual void	AddMessage( CTAggregated* object, msgid_t msg, msgdata_t data=0, ctime_t delay =UM_TIME_ASAP, int count=UM_COUNT_ONCE ) = 0;
	virtual void	ChangeMessageTime( CTAggregated*, msgid_t, ctime_t delay ) = 0;
	virtual void	ChangeMessageData( CTAggregated*, msgid_t, msgdata_t ) = 0;
	virtual void	RemoveMessage( CTAggregated*, msgid_t ) = 0;
	virtual void	RemoveMessages( CTAggregated* ) = 0;
};
///////////////////////////////////////////////////////////////////////
typedef ServicePtr<CTUpdateManager> PUpdateManager;
///////////////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
#endif // !CITK_UPDATEMAN_H_INCLUDED
///////////////////////////////// [citk_UpdateMan.h] END
// This one last I think...
///////////////////////////////// [citk_Globals.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_GLOBALS_H_INCLUDED
#define CITK_GLOBALS_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// Forward declarations used by this file
namespace citk {
struct DRenderContext;
struct VersionInfo_t;
class CTDrawable;
class CTSpectator;
class CTEnvironment;
class ClassDesc;
class CTBasic;
class CTPlugInLib;
class CTAggregated;
class CTMaterial;
class CTRenderState;
class CTSoundWave;
class CTTexture;
class CTGroup;
class CTDevice;
} // namespace citk
/////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// Application:
CITK_API int			citk_Main( cstr_t app_name, int argc, cstr_t argv[] );
CITK_API void			citk_Quit( int exit_code = 0 );
///////////////////////////////////////////////////////////////////////////////
// EngineManager:
CITK_API void			citk_Loop();
CITK_API bool			citk_StopLoop();
CITK_API bool			citk_Pause();			
CITK_API bool			citk_Continue();			
CITK_API bool			citk_IsLooping();
CITK_API bool			citk_IsPaused();
CITK_API ctime_t		citk_DoFrame();
CITK_API void			citk_Lock();
CITK_API void			citk_Unlock();
CITK_API bool			citk_DoRenderContext( citk::DRenderContext* );
CITK_API citk::frameid_t	citk_GetFrameID();
CITK_API citk::frameid_t	citk_IncrementFrameID(); // to force scene change
//CITK_API void			citk_AddDrawable( citk::CTEntity*, flags_t post_draw =PF_DRAW_POST );
//CITK_API void			citk_RemoveDrawable( citk::CTEntity* );
CITK_API void			citk_RegisterSpectator( citk::CTSpectator* );
CITK_API void			citk_UnregisterSpectator( citk::CTSpectator* );
// Environment:
CITK_API void			citk_AddEnvironment( citk::CTEnvironment* );
CITK_API void			citk_RemoveEnvironment( citk::CTEnvironment* );
CITK_API citk::CTEnvironment*	citk_GetDefaultEnvironment();
CITK_API citk::CTEnvironment*	citk_FindEnvironment( const Vector3&, citk::CTGroup* Root );
///////////////////////////////////////////////////////////////////////////////
// ClassManager:
CITK_API void				citk_RegisterClass( citk::ClassDesc* );
CITK_API void				citk_UnregisterClass( citk::ClassDesc* );
CITK_API citk::ClassDesc*	citk_FindClassDesc( const citk::cdid_t );
CITK_API citk::ClassDesc*	citk_FindClassDescByName( cstr_t );
CITK_API citk::ClassDesc*	citk_FindClassDescByNameIC( cstr_t );
CITK_API citk::CTBasic*		citk_CreateClass( const citk::cdid_t );
CITK_API citk::CTBasic*		citk_CreateClassByName( cstr_t );
CITK_API citk::CTBasic*		citk_CreateClassByNameIC( cstr_t );
CITK_API int				citk_GetClassDescCount();
CITK_API citk::ClassDesc*	citk_GetClassDescNo( const int );
CITK_API String				citk_GetClassName( const citk::cdid_t );
CITK_API citk::cdid_t			citk_GetClassID( cstr_t );
///////////////////////////////////////////////////////////////////////////////
// ErrorManager:
/*
struct errorstruct_t;
CITK_API void			citk_ErrorCode( errorcode_t, CTBasic*, cstr_t arg =NULL );
  CITK_API int			citk_GetErrorsCount();
CITK_API errorstruct_t*	citk_GetErrorNo( const int );
*/
CITK_API void			citk_Info( cstr_t, citk::CTBasic* =NULL );
CITK_API void			citk_Warning( cstr_t, citk::CTBasic* =NULL );
CITK_API void			citk_Error( cstr_t, citk::CTBasic* =NULL );
CITK_API void CDECL		citk_Printf( cstr_t, ... );		// using citk_Info
///////////////////////////////////////////////////////////////////////////////
// PropertyPageManager:
CITK_API bool			citk_ShowPropertyPage( citk::CTBasic*, bool asynchronous =false );
///////////////////////////////////////////////////////////////////////////////
// PlugInManager:
CITK_API citk::CTPlugInLib*	citk_LoadPlugIn( cstr_t );
CITK_API int				citk_LoadAllPlugIns( cstr_t path =NULL );
CITK_API int				citk_GetPlugInCount();
CITK_API citk::CTPlugInLib*	citk_GetPlugInLib( int );
///////////////////////////////////////////////////////////////////////////////
// MaterialManager:
#ifdef FULL_CITK
CITK_API citk::CTMaterial*	citk_CreateMaterial( cstr_t, bool *found = NULL );
CITK_API citk::CTMaterial*	citk_FindMaterial( cstr_t );
CITK_API citk::CTMaterial*	citk_GetDefaultMaterial();
#endif // FULL_CITK
///////////////////////////////////////////////////////////////////////////////
// RenderStateManager:
CITK_API citk::CTRenderState*	citk_CreateRenderState( cstr_t, bool *found = NULL );
CITK_API citk::CTRenderState*	citk_FindRenderState( cstr_t );
CITK_API citk::CTRenderState*	citk_GetDefaultRenderState();
///////////////////////////////////////////////////////////////////////////////
// SoundManager:
CITK_API citk::CTSoundWave*		citk_LoadWave( cstr_t );
CITK_API citk::CTSoundWave*		citk_LoadWaveFile( cstr_t );
CITK_API citk::CTSoundWave*		citk_FindWave( cstr_t );
///////////////////////////////////////////////////////////////////////////////
// TextureManager:
CITK_API citk::CTTexture*		citk_CreateTexture( cstr_t );
CITK_API bool					citk_LoadTexture( citk::CTTexture*, cstr_t );
CITK_API citk::CTTexture*		citk_LoadTexture( cstr_t );
CITK_API citk::CTTexture*		citk_FindTexture( cstr_t );
///////////////////////////////////////////////////////////////////////////////
// NetworkManager:
//CITK_API bool			citk_StartNetworkAsHost( const int maxclients =0 );
//CITK_API bool			citk_StartNetworkAsClient( const int GameToJoin );
//CITK_API bool			citk_StopNetwork();
CITK_API citk::netid_t		citk_RequestNetworkID();
CITK_API citk::netid_t		citk_AddNetworkObject( citk::CTStreamed* );
CITK_API citk::CTStreamed*	citk_FindNetworkObject( citk::netid_t );
CITK_API void			citk_RemoveNetworkObject( citk::CTStreamed* );
CITK_API void			citk_SendNetworkMessage( citk::netid_t nid, citk::msgid_t id, long param =0 );
CITK_API void			citk_SendNetworkData( citk::netid_t nid, citk::msgid_t id, citk::msgdata_t data, int msgdata_size );
CITK_API void			citk_SendNetworkStream( citk::CTStreamed* str, citk::streamlod_t lod );
CITK_API void			citk_SendNetworkChunk( citk::CTStreamed* str, citk::chunkid_t chid );
///////////////////////////////////////////////////////////////////////////////
// SceneCacheManager:
CITK_API void			citk_FlushSceneCache();
CITK_API void			citk_FlushEntireSceneCache();
CITK_API bool			citk_LoadScene( citk::CTGroup*, cstr_t, cfloat__t scaling =1.0f, bool cache=true );
CITK_API bool			citk_LoadSceneFile( citk::CTGroup*, cstr_t, cfloat__t scaling =1.0f, bool cache=true );
CITK_API void			citk_SetScenePath( cstr_t );
///////////////////////////////////////////////////////////////////////////////
// FrontEndManager:
CITK_API void			citk_Notify( citk::CTBasic *sender, citk::msgid_t message, citk::msgdata_t =0 );
CITK_API void CDECL		citk_Debug( cstr_t, ... );
CITK_API void			citk_Debug( const String& );
CITK_API void			citk_Debug( const DynString& );
///////////////////////////////////////////////////////////////////////////////
// DeviceManager:
/*
CITK_API CTDevice*		citk_ObtainDevice( cdid_t classid, bool share =false );
CITK_API CTDevice*		citk_ObtainDeviceByName( cstr_t classname, bool share =false );
CITK_API CTDevice*		citk_ObtainDevice( cdid_t classid, devid_t, bool share =false );
CITK_API CTDevice*		citk_ObtainDeviceByName( cstr_t classname, devid_t, bool share =false );
*/
CITK_API bool			citk_ShareDevice( citk::CTDevice* );
CITK_API void			citk_ReleaseDevice( citk::CTDevice* );
///////////////////////////////////////////////////////////////////////////////
// UpdateManager:
/*
CITK_API void			citk_AddUpdate( CTNamed* object, updatefunc_t, ctime_t delay =UM_TIME_ASAP, int count=UM_COUNT_FOREVER );
CITK_API void			citk_AddUpdate( CTNamed* object, updatefunc_t, ctime_t delay =UM_TIME_ASAP, int count=UM_COUNT_FOREVER );
CITK_API void			citk_ChangeUpdateTime( CTNamed*, updatefunc_t, ctime_t delay );
CITK_API void			citk_RemoveUpdate( CTNamed* object, updatefunc_t );
CITK_API void			citk_RemoveUpdates( CTNamed* object );
CITK_API void			citk_AddMessage( CTNamed* object, msgid_t msg, msgdata_t data=0, ctime_t delay =UM_TIME_ASAP, int count=UM_COUNT_ONCE );
CITK_API void			citk_ChangeMessageTime( CTNamed*, msgid_t, ctime_t delay );
CITK_API void			citk_ChangeMessageData( CTNamed*, msgid_t, msgdata_t );
CITK_API void			citk_RemoveMessage( CTNamed*, msgid_t );
CITK_API void			citk_RemoveMessages( CTNamed* );
*/
///////////////////////////////////////////////////////////////////////////////
// VersionManager:
CITK_API bool						citk_CheckVersionInfo( const citk::VersionInfo_t& );
CITK_API bool						citk_CheckVersionInfos( const citk::VersionInfo_t*, int num );
CITK_API const citk::VersionInfo_t&	citk_GetVersionInfoNo( int no );
#define CHECK_VERSION(__name)			citk_CheckVersionInfo(VersionInfo_t(#__name,__name))
#define CHECK_VERSION2(__name,__desc)	citk_CheckVersionInfo(VersionInfo_t(#__name,__name,__desc))
///////////////////////////////////////////////////////////////////////////////
// MemoryManager:
CITK_API void*		citk_Alloc( unsigned long size );
CITK_API void		citk_Free( void* );
///////////////////////////////////////////////////////////////////////////////
// UpdateManager:
CITK_API void citk_AddUpdate( citk::CTAggregated*, citk::updatefunc_t, ctime_t delay =UM_TIME_ASAP, int count =UM_COUNT_FOREVER );
CITK_API void citk_ChangeUpdateTime( citk::CTAggregated*, citk::updatefunc_t, ctime_t delay );
CITK_API void citk_RemoveUpdate( citk::CTAggregated*, citk::updatefunc_t );
CITK_API void citk_AddMsg( citk::CTAggregated*, citk::msgid_t, citk::msgdata_t =0, ctime_t delay =UM_TIME_ASAP, int count =UM_COUNT_ONCE );
CITK_API void citk_RemoveMsg( citk::CTAggregated*, citk::msgid_t );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_GLOBALS_H_INCLUDED
///////////////////////////////// [citk_Globals.h] END
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#ifndef CITK_EXCLUDE_EAX
///////////////////////////////// [citk_SoundRoom.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_SOUNDROOM_H_INCLUDED
#define CITK_SOUNDROOM_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC (CTSoundRoom);
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citk {
/////////////////////////////////////////////////////////////////////////////
class CITK_API CTSoundRoom : public CTEntity
{
	DECLARE_ALL( CTSoundRoom, CTEntity );
public:
	// Constructor (3 in 1)
	CTSoundRoom( cstr_t name =NULL, CTGroup* parent =NULL );
	// Copy constructor
	CTSoundRoom( const CTSoundRoom * copy_this_one );
	// Process function
	virtual void		Process( ProcessInfo_t& );
	// Inherited
	virtual CTEntity*	Copy() const;
	
	// For networking, loading & saving
	virtual void		WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool		ProcessChunk( CTStream* stream, chunkid_t chid );
	// Non inherited stuff
	void				SetSoundEnvironment( CTShape* sh, CTRenderState* st );
};
/////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTSoundRoom> PSoundRoom;
/////////////////////////////////////////////////////////////////////////////
} // namespace citk
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITK_SOUNDROOM_H_INCLUDED
///////////////////////////////// [citk_SoundRoom.h] END
///////////////////////////////// [citk_SoundObstruct.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_SOUNDOBSTRUCT_H_INCLUDED
#define CITK_SOUNDOBSTRUCT_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC (CTSoundObstruct);
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citk {
/////////////////////////////////////////////////////////////////////////////
class CITK_API CTSoundObstruct : public CTEntity
{
	DECLARE_ALL( CTSoundObstruct, CTEntity );
public:
	// Constructor (3 in 1)
	CTSoundObstruct( cstr_t name =NULL, CTGroup* parent =NULL );
	// Copy constructor
	CTSoundObstruct( const CTSoundObstruct * copy_this_one );
	// Process function
	virtual void		Process( ProcessInfo_t& );
	// Inherited
	virtual CTEntity*	Copy() const;
	
	// For networking, loading & saving
	virtual void		WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool		ProcessChunk( CTStream* stream, chunkid_t chid );
	// Non inherited stuff
	void				SetSoundObstruction( CTShape* sh, CTRenderState* st );
};
/////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTSoundObstruct> PSoundObstruct;
/////////////////////////////////////////////////////////////////////////////
} // namespace citk
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITK_SOUNDOBSTRUCT_H_INCLUDED
///////////////////////////////// [citk_SoundObstruct.h] END
#endif // !CITK_EXCLUDE_EAX
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#ifdef USING_CITK
using namespace citk;
#endif
#undef CITK_API
#define CITK_API
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !ONLY_VERSION_INFO
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !_CITK_H_INCLUDED_
///////////////////////////////// [_citk.h] END
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#ifndef ONLY_VERSION_INFO
///////////////////////////////////////////////////////////////////////////////
// Legacy stuff:
///////////////////////////////// [citk_3DFont.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_3DFONT_H_INCLUDED
#define CITK_3DFONT_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_Visual.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_VISUAL_H_INCLUDED
#define CITK_VISUAL_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_Material.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_MATERIAL_H_INCLUDED
#define CITK_MATERIAL_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTMaterial);
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citk {
	
/////////////////////////////////////////////////////////////////////////////
// Enum for a texture's UV source
enum tex_uv_t { uv1, uvStanMap, uvCamDir, uvReflect, uvVtxCol, uvObjectXY, uvObjectYZ, uvObjectXZ, uvUnknown };
// Texture stage flags (these override the texture's setting)
#define TSF_UVTRANSFORM		0x00000001
#define TSF_FILTER_NO		0x00000010
#define TSF_FILTER_YES		0x00000020
#define TSF_UMODE_WRAP		0x00000100
#define TSF_UMODE_CLAMP		0x00000200
#define TSF_UMODE_MIRROR	0x00000400
#define TSF_UMODE_BORDER	0x00000800
#define TSF_VMODE_WRAP		0x00001000
#define TSF_VMODE_CLAMP		0x00002000
#define TSF_VMODE_MIRROR	0x00004000
#define TSF_VMODE_BORDER	0x00008000
struct texturestage_t
{
	DFlags		Flags;
	PTexture	Texture;
	tex_uv_t	TextureUV;
	String		ColorBlend;
	String		AlphaBlend;
	Matrix		UVTransform;
	Vector		UVOffset;
};
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#define MATID_NONE	-1/*INVALID_ITEM*/
#define MF_USEALPHA		0x00000001
/*
#define MF_DEFAULT
#define MF_USEAMBIENT
#define MF_USEDIFFUSE
#define MF_USESPECULAR
#define MF_USEEMISSIVE
#define MF_USEVERTEXCOLOR
#define MF_NOFOG
#define MF_ANITALIASED
#define MF_DOUBLESIDED
#define MF_SORTALPHA
*/
/////////////////////////////////////////////////////////////////////////////
class CITK_API CTMaterial : public CTNamed
{
	DECLARE_ALL( CTMaterial, CTNamed );
public:
	String		AlphaBlend;
	bool		UseAlpha;
	bool		UseAmbient;
	bool		UseDiffuse;
	bool		UseSpecular;
	bool		UseEmissive;
	bool		UseVertexColor;
	bool		NoFog;
	bool		AntiAliased;
	bool		DoubleSided;
	bool		NoDepthBuffer;
	int			DepthBias;
	float		Alpha;
	float		Power;
	DColor		Emissive;
	DColor		Ambient;
	DColor		Diffuse;
	DColor		Specular;
	// Texture blending factor
	DColor		BlendColor;
	float		BlendFactor;
	// Active texture [obsolete]
	PTexture	Texture;
	// Automatic UV generation (environment mapping) [obsolete]
	tex_uv_t	AutomaticUV;
	// Default constructor
	CTMaterial( cstr_t =NULL );
	// Copy constructor
	CTMaterial( const CTMaterial * const );
	virtual CTMaterial* Copy() const;
	void			SetAlpha( cfloat__t alpha );
	void			SetColor( const DColor &col );
	void			SetAmbient( const DColor &col );
	void			SetDiffuse( const DColor &col );
	void			SetSpecular( const DColor &col );
	void			SetEmissive( const DColor &col );
	bool			LoadTexture( cstr_t, int stage =0 );
	// Used by the renderer to determine blending:
	inline flags_t	GetFlags() const { return Flags; }
	flags_t			UpdateFlags();
	// MatID methods
	id__t			GetID() const { return MatID; }
	id__t			RequestID();
	// NEW: Texture stage methods
	bool			SetTexture( CTTexture*, int stage =0 );
	bool			SetTextureUV( tex_uv_t, int stage =0 );
	bool			SetTextureBlending( cstr_t color, cstr_t alpha =NULL, int stage =0 );
	bool			SetTextureUVTransform( const DTransform&, int stage =0 );
	int				GetTextureCount() const { return Textures.Count(); }
	CTTexture*		GetTexture( int stage =0 ) const;
	bool			GetTextureUVTransform( DTransform&, int stage =0 );
	int				AddTexture( CTTexture*, cstr_t colorblend =NULL, cstr_t alpha_blend =NULL, tex_uv_t =uv1 );
	bool			RemoveTexture( int stage =0 );
	texturestage_t*	GetTextureStage( int stage =0 ) const;
	// Streaming:
	virtual void	WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool	ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	virtual			~CTMaterial();
	virtual void	DoAddProperties();
	virtual bool	DoRegisterWithService();
	virtual bool	DoUnregisterWithService();
private:
	// Texture stages
	ArrayPtr<texturestage_t>	Textures;
	DFlags			Flags;
	id__t			MatID;
};
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTMaterial> PMaterial;
/////////////////////////////////////////////////////////////////////////////
} // namespace citk
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITK_MATERIAL_H_INCLUDED
///////////////////////////////// [citk_Material.h] END
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC (CTVisual);
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citk {
/////////////////////////////////////////////////////////////////////////////
enum billboard_t {
	bbFixed,			// Sprite is in XY plane of Transform (eg. BillBoard)
	bbVert,				// Sprite rotates toward cam_pos, around local V_UP (eg. Trees)
	bbFree,				// Sprite is always a square, up-vector tends upward in localspace (volumes at short distance, eg. Clouds)
	bbFree2D,			// Sprite is always a STRAIGHT SQUARE on the screen (eg. Flares)
	bb2D,				// Sprite is always a fixed-size straight square (eg. Hovering opponent name)
	bbLookAt			// Sprite looks at cam_pos (Volumes at larger distance, eg. Explosions)
};
/////////////////////////////////////////////////////////////////////////////
class CITK_API CTVisual : public CTEntity
{
	DECLARE_ALL( CTVisual, CTEntity );
public:
	// Constructor (3 in 1)
	CTVisual( cstr_t name =NULL, CTGroup* parent=NULL );
	// Copy constructor
	CTVisual( const CTVisual* );
	// Material
	PMaterial			Material;
	// Bill-boarding:
	void				SetBillBoardType( billboard_t Type );
	billboard_t			GetBillBoardType() const { return BillBoard; }
	// Render this drawable (for the current context)
	virtual void		Render( RenderInfo_t&, CTMaterial *override =NULL ) = 0;
	// Inherited: Calls Render if applicable
	virtual void		Process( ProcessInfo_t& );
	// For networking, loading & saving
	virtual void		WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool		ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	billboard_t			BillBoard;
	DTransform*			WorldTrans;
	void				UpdateBillBoard( RenderInfo_t& );
	virtual void		DoAddProperties();
	// Destructor
	virtual ~CTVisual();
};
/////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTVisual> PVisual;
/////////////////////////////////////////////////////////////////////////////
} // namespace citk
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITK_VISUAL_H_INCLUDED
///////////////////////////////// [citk_Visual.h] END
///////////////////////////////// [citk_RenderShape.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_RENDERSHAPE_H_INCLUDED
#define CITK_RENDERSHAPE_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_Face.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_FACE_H_INCLUDED
#define CITK_FACE_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
struct DVertex
{
	vtxid_t		idVector, idNormal;
	float		u, v;					// UV1
	float		Alpha;
	DColor		Color;					// Or UVW2
	DVertex() {}
	DVertex( int vec ) : idVector((vtxid_t)vec) {}
	void		SetNormal( int n ) { idNormal=(vtxid_t)n; }
	void		SetVector( int n ) { idVector=(vtxid_t)n; }
	void		SetAlpha( float _a ) { Alpha=_a; }
	void		SetUV( float _u, float _v ) { u=_u; v=_v; }
	void		SetUV2( float _u, float _v ) { Color.r=_u; Color.g=_v; }
	void		SetUVW2( float _u, float _v, float _w ) { Color.Set(_u,_v,_w); }
	void		SetColor( const DColor &_c ) { Color=_c; }
};
///////////////////////////////////////////////////////////////////////////////
struct DEdge
{
	vtxid_t		v0, v1;			// Vertices
	vtxid_t		f0, f1;			// Faces
	DEdge() {}
	DEdge( int va, int vb ) : v0((vtxid_t)va), v1((vtxid_t)vb) {}
	void		SetVertices( int va, int vb ) { v0=(vtxid_t)va; v1=(vtxid_t)vb; }
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
class DRenderShape;
///////////////////////////////////////////////////////////////////////////////
struct DBases
{
	bool		Simple;
	Normal*		NormalBase;
	Vector*		VectorBase;
	DVertex*	VertexBase;
	CITK_API void SetRenderShape( DRenderShape* );
	inline Normal&		GetNormal( int i ) const { return NormalBase[i]; }
	inline Vector&		GetVector( int i ) const { return VectorBase[i]; }
	inline DVertex&		GetVertex( int i ) const { return VertexBase[i]; }
	inline Vector&		GetVertexVector( int i ) const {
		return Simple?VectorBase[i]:VectorBase[(int)VertexBase[i].idVector]; }
	inline Normal&		GetVertexNormal( int i ) const {
		return Simple?NormalBase[i]:NormalBase[(int)VertexBase[i].idVector]; }
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#define FF_HAS_VERTEX_NORMALS	0x00000001
#define FF_USE_VERTEX_NORMALS	0x00000002
#define FF_HAS_EDGES			0x00000010
#define FF_HAS_SMOOTHINGGROUP	0x00000020
#define FF_HAS_FACE_NORMAL		0x00000040
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
class CITK_API DFace
{
public:
	enum {
		MAX_VERTICES = 3
	};
	flags_t			Flags;
	vtxid_t			idFaceNormal, NumVertices;
	vtxid_t			idVertex[MAX_VERTICES];
	vtxid_t			idEdge[MAX_VERTICES];
	int	SmoothingGroup;
	CTMaterial*		Material;
//	CTTexture*		Texture;
	// Default constuctor
	DFace() : NumVertices(0), idFaceNormal((vtxid_t)-1), 
		Material(NULL), SmoothingGroup(-1), Flags(0) {}
	// Methods to create/delete a face (using a facepool)
	static DFace*		New();
	void				Delete();
	// Set face normal
	inline void			SetNormal( const int n )			{ Flags|=FF_HAS_FACE_NORMAL; idFaceNormal=n; }
	inline void			SetSmoothingGroup( const int n )	{ Flags|=FF_HAS_SMOOTHINGGROUP; SmoothingGroup=n; }
	// Get face normal
	inline Normal&		GetNormal( const DBases &base ) const { return base.GetNormal(idFaceNormal); }
	// Get plane-representation for this face
	inline double		GetPlaneDist( const DBases &base ) const { return GetNormal(base)^GetVector(base,0); }
	inline Plane3		GetPlane( const DBases &base ) const { Normal n=GetNormal(base); return Plane3( n, n^GetVector(base,0) ); }
	// Number of vertices
	inline int			GetNumVertices() const		{ return NumVertices; }
	inline DVertex&		GetVertex( const DBases &base, const int n ) const { return base.GetVertex(idVertex[n]); }
	inline int			GetVectorNo( const DBases &base, const int n ) const { return GetVertex(base,n).idVector; }
	inline Vector&		GetVector( const DBases &base, const int n ) const { return base.GetVertexVector( idVertex[n] ); }
	inline Normal&		GetVertexNormal( const DBases &base, const int n ) const { return base.GetNormal( (Flags&FF_USE_VERTEX_NORMALS)?GetVertex(base,n).idNormal:idFaceNormal ); }
	inline Normal&		GetVertexNormal2( const DBases &base, const int n ) const { return base.GetVertexNormal( idVertex[n] ); }
	inline vtxid_t*		GetIndexData()						{ return idVertex; }
	inline int			GetVertexNo( const int n ) const	{ return idVertex[n]; }
	// Vertex attribute modifiers
	void				SetVertexAlpha( const DBases &base, const float ) const;
	void				SetVertexColor( const DBases &base, const DColor& ) const;
	// Recalculate the face-normal
	const Normal&		UpdateNormal( const DBases &base );
	// Recalculate the face-distance (for plane representation)
//	inline float__t		UpdateDist( const DBases &base )		{ return FaceDist = GetNormal(base)^GetVector(base,0); }
	// Recalculate the face-normal and plane-distance
	inline void			UpdatePlane( const DBases &base )		{ UpdateNormal(base); /*UpdateDist(base);*/ }
	// Add a vertex id to the list of vertices
	inline bool			AddVertex( const int n ) {
		return (NumVertices>=MAX_VERTICES?false:(idVertex[NumVertices++]=n,true)); }
	// Set the vertices (as triangle)
	inline void			SetVertices( int a, int b, int c ) { NumVertices=3; idVertex[0]=(vtxid_t)a; idVertex[1]=(vtxid_t)b; idVertex[2]=(vtxid_t)c; }
	// Flip the order of the vertices
	void				Flip();
	// Sets all the members to their default settings (just like after construction)
	void				Clear();
	// Clear vertices
	inline void			ClearVertices() { NumVertices = 0; }
	// Checks if this face represents a triangle
	bool				IsTriangle() const { return NumVertices==3; }
	// Check if this face contains vertex no. 'n'
	bool				ContainsVertex( const int n ) const;
	bool				ContainsVector( const DBases&, const int n ) const;
	// Check whether this face contains an edge from vertex 'n1' to 'n2'
	bool				ContainsEdge( const int n1, const int n2 ) const;
	// Check whether this face shares an edge with another face
	bool				CommonEdge( const DFace* const ) const;
	// Checks if the face is convex
	bool				IsConvex() const;
	// Surface area
	double				CalcArea( const DBases &base ) const;
	// Volume of pyramid below this face.
	double				CalcVolume( const DBases &base );
	// Check the face against a plane
	int					CheckAgainstPlane( const DBases&, const Plane3& ) const;
	bool				CheckAgainstPlaneIn( const DBases&, const Plane3& ) const;
	bool				CheckAgainstPlaneOut( const DBases&, const Plane3& ) const;
	Vector				MidPoint( const DBases& ) const;
	bool				IsUnder( const DBases&, const Vector& ) const;
	// Fancy intersection test
	//  result.x/y		(s,t) on the triangle (UV)
	//  result.z		offset in line
	// Intersection point can be calculated as: line.Pos + result.z*line.Dir
	bool				Intersect( const DBases&, const Line3&, Vector& result, bool cull =true ) const;
	// Check if the face is convex [OBSOLETE]
	bool				CheckConvexity( const DBases& ) const;
};
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_FACE_H_INCLUDED
///////////////////////////////// [citk_Face.h] END
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// RenderShape-Data flags
#define	RSD_NOTHING				0x00000000
#define	RSD_VECTORS				0x00000001
#define	RSD_NORMALS				0x00000002
#define	RSD_VERTICES			0x00000004
#define	RSD_EDGES				0x00000008
#define	RSD_FACES				0x00000010
#define	RSD_STRIPS				0x00000020
#define	RSD_FANS				0x00000040
#define	RSD_POLYGONS			0x00000080
#define	RSD_FACENORMALS			0x00000100
#define	RSD_VERTEXNORMALS		0x00000200
#define	RSD_FIRSTLAST			0x00000400
#define	RSD_BOUNDINGSPHERE		0x00000800
#define	RSD_VERTEXCOLORS		0x00001000
#define	RSD_VERTEXALPHAS		0x00002000
#define	RSD_VERTEXUV			0x00004000
#define	RSD_SMOOTHINGGROUPS		0x00008000
#define RSD_NORMALS_AUTO		0x01000000		// Normal were generated (don't stream)
#define RSD_EDGES_AUTO			0x02000000		// Edges were generated (don't stream)
#define RSD_EDGES_AUTOV			0x04000000		// ... Vector edges
// RenderState flags
#define	RSF_NOTHING				0x00000000
#define RSF_CLIPPED				0x00000001
#define RSF_LIT					0x00000002
#define RSF_CULLED				0x00000004		// Not really a flag
#define RSF_SORTEDMAT			0x00000008		// Faces sorted on material
#define	RSF_ORIGINAL			0x00000010
#define RSF_OPTIMIZED			0x00000020
#define RSF_TEMP				0x00000040		// Temporary shape; deleted when done
#define RSF_SIMPLE				0x00000080		// HINT: Vertices[t].idVector == t
#define RSF_LOCALSPACE			0x00000100		// Could be enums instead of flags
#define RSF_WORLDSPACE			0x00000200
#define RSF_CAMERASPACE			0x00000400
#define RSF_VIEWPORTSPACE		0x00001000
#define RSF_PIXELSPACE			0x00002000
#define RSF_SPACE_MASK			0x0000FF00
#define RSF_SPHERICAL_UV		0x00010000		// UV coordinates must be calculated
#define RSF_DONT_SORT			0x00020000		// Won't sort alpha faces
#define RSF_PRELIT				0x00040000		// Vertices already contain SOME lighting
#define RSF_STATIC				0x00080000		// HINT: Static shape (cache in world space)
#define RSF_DONT_CACHE			0x00100000		// Won't cache the shape on hardware
#define RSF_READ_ONLY			0x00200000		// Don't affect shape in any way
#define RSF_NO_DEPTHBUFFER		0x00400000		// Don't use depth buffering
#define RSF_CONVEX				0x00800000		// HINT: convex shape
#define RSF_DRAW_FACES			0x01000000
#define RSF_DRAW_EDGES			0x02000000
#define RSF_DRAW_POINTS			0x04000000
#define RSF_DRAW_VERTEXNORMALS	0x10000000
#define RSF_DRAW_FACENORMALS	0x20000000
#define RSF_DEST_MASK			0xFF000000
///////////////////////////////////////////////////////////////////////////////
typedef ulong renderstate_t;
typedef ulong renderdata_t;
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
class CITK_API DRenderShape 
{
public:
	DBases				Bases;				// All your bases are belong to us
	DRenderShape*		Original;
	CTMaterial*			Material;			// Global (override) material
	CTMaterial*			DefaultMaterial;	// Default material (always set!)
	renderstate_t		State;				// Current state
	renderdata_t		Items;				// Available mesh data
	int					First, Last;		// First & Last primitive to be rendered
	// Bounding sphere:
	Vector				Pivot;
	float__t				Radius;
	// Actual mesh data:
	ArrayVal<DVertex>	Vertices;
	ArrayVal<DEdge>		Edges;
	ArrayVal<Normal>	Normals;
	ArrayVal<Vector>	Vectors;
	ArrayPtr<DFace>		pFaces;
	// Default constructor
	DRenderShape();
	// Destructor
	~DRenderShape();
	void			UpdateBases() { Bases.SetRenderShape(this); }
	void			RecalcBoundingSphere();
	void			RecalcFaceNormals();
	void			RecalcVertexNormals();
	void			ApplySmoothingGroups();
	void			OptimizeMaterials();
	void			Optimize();
	void			MakeSimple();
	void			FlipFaces();
	void			BuildEdges();
	void			BuildVectorEdges();
	const Normal&	GetFaceNormal( const int i ) const { return Normals[(int)pFaces[i]->idFaceNormal]; }
	Normal&			GetFaceNormal( const int i ) { return Normals[(int)pFaces[i]->idFaceNormal]; }
	const Normal&	GetVertexNormal( const int i ) const { return Normals[(int)Vertices[i].idNormal]; }
	Normal&			GetVertexNormal( const int i ) { return Normals[(int)Vertices[i].idNormal]; }
	void			Clear();
	void			Empty();
	bool			Process( const RenderInfo_t&, renderstate_t dest =0 );
	void			SetFaceCount( int );
	void			SetNormalCount( int );
	void			SetVertexCount( int );
	void			SetVectorCount( int );
	void			SetEdgeCount( int );
	void			SetVertexAlpha( const float );
	void			SetVertexColor( const DColor& );
	void			SetFirstLast( int first, int last );
	void			CopyFrom( const DRenderShape& );
	int				AddVertex( const Vector& );
	int				AddEdge( const Vector&, const Vector& );
	int				AddEdge( int v0, int v1 );
	DFace*			AddFace();
	DFace*			AddFace( int v0, int v1, int v2 );
	// Vector/Normal Transformations:
	void			Transform( const DTransform& );
	void			BackTransform( const DTransform& );
	void			TransformVectors( const DTransform& );
	void			BackTransformVectors( const DTransform& );
	void			TransformNormals( const DTransform& );
	void			BackTransformNormals( const DTransform& );
	// ShapeID methods
	inline id__t		GetID() const { return shape_ID; }
	id__t			RequestID();
	// Change detection (for hardware chaching)
	void			Invalidate();
	inline ulong	GetVersionID() const { return shape_version; }
private:
	// These are NOT implemented, just to forbid usage
	DRenderShape( const DRenderShape& );
	DRenderShape& operator = ( const DRenderShape& );
	// Used for caching on hardware:
	ulong			shape_version;
	id__t			shape_ID;			
	void			RemoveFaces();
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_RENDERSHAPE_H_INCLUDED
///////////////////////////////// [citk_RenderShape.h] END
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CT3DFont );
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CITK_API CT3DFont : public CTVisual
{
	DECLARE_ALL( CT3DFont, CTVisual );
public:
	// Default constructor
	CT3DFont();
	// Copy Constructor
	CT3DFont( const CT3DFont* );
	// Contruct method
	void			Construct();
	// Font methods
	bool			Load( cstr_t, bool proportional =true );
	bool			LoadFrom( const CT3DFont* );
	void			Free();
	cstr_t			GetTextureName() const;
	void			SetText(cstr_t);			//	Supports \n and \r
	void			UseLocalSpace();
	void			UseCameraSpace();
	void			UseViewportSpace();
	void			VerAlignTop();
	void			VerAlignCenter();
	void			VerAlignBottom();
	void			HorAlignLeft();
	void			HorAlignCenter();
	void			HorAlignRight();
	void			HorAlignTotalRight(); // Not per-line!
	void			SetFontSize( cfloat__t hor, cfloat__t ver );//	In chosen units
	void			SetFontSize( cfloat__t sz );	//	In chosen units
	void			UseProportional();
	void			UseFixedWidth();
	bool			IsProportional() const;
	void			SetHorSpacing( cfloat__t );	//	Relative to size
	void			SetVerSpacing( cfloat__t );	//	Relative to size
	void			SetFixedVerSpacing( cfloat__t );	//	Fixed height per line
	void			BasePointMoveTo( cvec_t );	//	In the selected space
	void			BasePointMoveBy( cvec_t );	//	In the selected space
	void			SetAlpha( cfloat__t );
	void			SetColor( const DColor& );
	void			SetBackgroundProperties( bool per_line = false, const DColor& = COL_BLACK, cfloat__t alpha=0.2, cfloat__t margin=0.0);
	void			NoBackground( );
	void			SetTabStop( cfloat__t );
	// Inherited:
					
	virtual void	Render( RenderInfo_t&, CTMaterial *override =NULL );
	virtual CTEntity* Copy() const;
	struct letter_t;
	letter_t*		Letters[256];
protected:
	bool			Proportional ;
	DColor			Color;
	float			Alpha;
	DRenderShape	rs,bgrs;
	PMaterial		bgmat;
	Vector			Pivot, _dpos;
	float__t			TabStop;
	float__t			BGMargin;
	int				HorAlign, VerAlign;
	float			cur_width, cur_height, cur_horspace, cur_verspace;
	bool			ver_spacing_fixed, draw_background, background_per_line;
	String			Text;
	bool			Invalid, moveby, setalpha, setcolor;
	id__t			FontID;
	virtual ~CT3DFont();
	void			CreateRenderShape();
	void			CreateFont( CTTexture * );
};
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CT3DFont> P3DFont;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_3DFONT_H_INCLUDED
///////////////////////////////// [citk_3DFont.h] END
///////////////////////////////// [citk_Drawable.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_DRAWABLE_H_INCLUDED
#define CITK_DRAWABLE_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC (CTDrawable);
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citk {
//////////////////////////////////////////////////////////////////////
class CITK_API CTDrawable : public CTVisual
{
	DECLARE_ALL( CTDrawable, CTVisual );
public:
	// Constructor (3 in 1)
	CTDrawable( cstr_t name =NULL, CTGroup* parent=NULL );
	// Copy constructor
	CTDrawable( const CTDrawable* );
	// Functions to get/set the shape to be rendered
	void				SetShape( CTShape* );
	CTShape*			GetShape() const { return RenderShape; }
	/////////////////////////////////////////////////////////////////////////////
	// Inherited: 
	virtual bool		CheckWithRay( DTreePicker&, const Line3& );
	// Creates the most efficient bounding volume
	virtual CTShape*	UpdateBoundingVolume( kind_t kind =CTProcess::DRAW );
	// Make a copy of this drawable
	virtual CTEntity*	Copy() const;
	// Render this drawable (for the current context)
	virtual void		Render( RenderInfo_t&, CTMaterial *override =NULL );
	// For networking, loading & saving
	virtual void		WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool		ProcessChunk( CTStream* stream, chunkid_t chid );
	/////////////////////////////////////////////////////////////////////////////
protected:
	virtual void	DoAddProperties();
private:
	// Shape to be rendered
	PShape			RenderShape;
};
/////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTDrawable> PDrawable;
/////////////////////////////////////////////////////////////////////////////
} // namespace citk
//////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITK_DRAWABLE_H_INCLUDED
///////////////////////////////// [citk_Drawable.h] END
///////////////////////////////// [citk_PointShape.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_POINTSHAPE_H_INCLUDED
#define CITK_POINTSHAPE_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTPointShape );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTPointShape : public CTShape
{
	DECLARE_ALL( CTPointShape, CTShape );
public:
	DRenderShape		Shape;
	// Constructors
	CTPointShape( cstr_t name =NULL );
	CTPointShape( const CTPointShape* cop );
	// Various shit
	virtual CTShape*	Copy() const;
	virtual void		SetRenderState( flags_t s ) { Shape.State = s; }
	virtual flags_t		GetRenderState() const { return Shape.State; }
	virtual void		Render( const RenderInfo_t& );
	virtual void		Clear() { Shape.Clear(); }
	virtual bool		ApplyTransform( const DTransform& );
	// Collision detection helpers
	virtual bool		IsConvex() const { if (Convexity==ctUnknown) CheckConvexity(); return Convexity==ctConvex; }
	virtual Vector		GetNormal( const Vector& );
	virtual Vector		GetSupport( const Vector& );
	virtual double		GetMaxY( const Vector& );
	virtual CTSphere*	GetBoundingSphere();
	virtual CTBox*		GetBoundingBox();
	virtual intersect_t	CheckWithPoint( const Vector&, const DTransform* =NULL );
	virtual intersect_t	CheckWithHalfspace( const Plane3&, const DTransform* =NULL );
	virtual intersect_t	CheckWithLine( const Line3&, const DTransform* =NULL );
	virtual intersect_t CheckWithRay( const Line3& L, float__t &current_t, const DTransform *T =NULL );
	// For networking, loading & saving
	virtual void	WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool	ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	mutable enum { ctUnknown, ctConvex, ctNotConvex } Convexity;
//	enum { rtPoints, rtLines, rtFaces } RenderType;
	void			CheckConvexity() const;
	virtual void	DoAddProperties();
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTPointShape> PPointShape;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_POINTSHAPE_H_INCLUDED
///////////////////////////////// [citk_PointShape.h] END
///////////////////////////////// [citk_Sprite.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_SPRITE_H_INCLUDED
#define CITK_SPRITE_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTSprite );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
/////////////////////////////////////////////////////////////////////////////
class CITK_API CTSprite : public CTVisual
{
	DECLARE_ALL( CTSprite, CTVisual );
public:
	DRenderShape	RenderShape;
	CTSprite( cstr_t = NULL, CTGroup* = NULL );
	CTSprite( const CTSprite* );
	void			SetSize( cfloat__t, cfloat__t );
	void			SetSize( cfloat__t );
	void			SetThickness( cfloat__t );
	const float__t&	GetWidth() const { return cur_width; }
	const float__t&	GetHeight() const { return cur_height; }
	const float__t&	GetThickness() const { return cur_thickness; }
	// Change render shape properties:
	void			UseLighting( bool = true );
	void			SetVertexAlpha( const float );
	void			SetVertexColor( const DColor& );
	// Inherited:
	virtual void		Render( RenderInfo_t&, CTMaterial *override =NULL );
	virtual	CTEntity*	Copy() const;
	// For networking, loading & saving (inherited)
	virtual void	WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool	ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	float__t			cur_width, cur_height, cur_thickness;
	bool			invalid;
	void			CreateRenderShape();
	virtual void	DoAddProperties();
};
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTSprite> PSprite;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
/////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_SPRITE_H_INCLUDED
///////////////////////////////// [citk_Sprite.h] END
///////////////////////////////// [citk_SpriteShape.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_SPRITESHAPE_H_INCLUDED
#define CITK_SPRITESHAPE_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTSpriteShape );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTSpriteShape : public CTShape
{
	DECLARE_ALL( CTSpriteShape, CTShape );
public:
	CTSpriteShape( cstr_t = NULL );
	CTSpriteShape( const CTSpriteShape* );
	void				SetSize( cfloat__t, cfloat__t );
	void				SetSize( cfloat__t );
	void				SetThickness( cfloat__t );
	const float__t&		GetWidth() const { return cur_width; }
	const float__t&		GetHeight() const { return cur_height; }
	const float__t&		GetThickness() const { return cur_thickness; }
	// Change render shape properties:
	void				UseLighting( bool = true );
	void				SetVertexAlpha( const float );
	void				SetVertexColor( const DColor& );
	// Inherited from CTShape:
	virtual	CTShape*	Copy() const;
	virtual Vector3		GetSupport( const Vector& ) { return Vector::Z; }
	virtual Vector3		GetNormal( const Vector& ) { return Vector::Z; }
	virtual CTSphere*	GetBoundingSphere() { return NULL; }
	virtual CTBox*		GetBoundingBox() { return NULL; }
	virtual CTShape*	GetBoundingVolume() { return NULL; }
	virtual intersect_t	CheckWithPoint( const Vector&, const DTransform* =NULL ) { return irOut; }
	virtual intersect_t	CheckWithHalfspace( const Plane3&, const DTransform* =NULL ) { return irOut; }
	virtual intersect_t	CheckWithLine( const Line3&, const DTransform* =NULL );
	virtual intersect_t	CheckWithRay( const Line3&, float__t &dist, const DTransform* =NULL );
	// Rendering:
	virtual void		SetRenderState( flags_t s ) { rendershape.State = s; }
	virtual flags_t		GetRenderState() const { return rendershape.State; }
	virtual void		Render( const RenderInfo_t&, CTMaterial* =NULL );
protected:
	DRenderShape	rendershape;
	float__t			cur_width, cur_height, cur_thickness;
	bool			invalid;
	void			CreateRenderShape();
};
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTSpriteShape> PSpriteShape;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_SPRITESHAPE_H_INCLUDED
///////////////////////////////// [citk_SpriteShape.h] END
///////////////////////////////// [citk_Terrain.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_TERRAIN_H_INCLUDED
#define CITK_TERRAIN_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTTerrain);
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTTerrain : public CTShape
{
	DECLARE_ALL(CTTerrain, CTShape);
public:
	bool				LoadSatelliteImage( cstr_t filename );
	virtual bool		SetSatelliteImage( CTTexture* tex )=0;
	virtual bool		LoadHMP( cstr_t filename )=0;
	// LockHMP() returns a pointer to the actual heightmap. User may NOT delete this HM!
	// You must ALWAYS unlock (asap) to prevent (huge) memory leaks!
	virtual DHeightMap*	LockHMP()=0;
	virtual void		UnlockHMP( bool changed )=0;
	// Use SetHMP() to associate a new heightmap with the terrain.
	// This function will fail if the heightmap is currently locked!
	// If succesful: The CTTerrain will become owner of the HM, and might even delete it.
	//  Do not use the pointer afterwards.
	// If not, the DHeightmap object won't be used or deleted by the CTTerrain; the caller
	//  is still responisble for deleting it.
	virtual bool		SetHMP( DHeightMap* )=0;
	// Pre-calculations for optimized rendering
	virtual bool		PreProcess() { return true; }
	// Inherited from CTShape:
	virtual double		CalcVolume() { return 0.0; }
	virtual bool		IsConvex() const { return false; }
};
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTTerrain> PTerrain;
/////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITK_TERRAIN_H_INCLUDED
///////////////////////////////// [citk_Terrain.h] END
///////////////////////////////// [citk_ChildDyna.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_CHILDDYNA_H_INCLUDED
#define CITK_CHILDDYNA_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_DynaController.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_DYNACONTROLLER_H_INCLUDED
#define CITK_DYNACONTROLLER_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_AbstractDyna.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_ABSTRACTDYNA_H_INCLUDED
#define CITK_ABSTRACTDYNA_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTAbstractDyna );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTAbstractDyna : public CTEntityController
{
	DECLARE_ALL( CTAbstractDyna, CTEntityController );
public:
	// Recorded maximum impulse from collisions (must be reset manually)
	double				MaxCollisionImpulse;
	CTAbstractDyna();
	virtual void		DynaUpdate( double interval )=0;
	const DTransform&	GetNextTransform() { return NextMotionInfo.Transform; }
	const MotionInfo_t&	GetNextMotionInfo() { return NextMotionInfo; }
	const Vector&		GetPos();
	Vector				GetPos(const Vector& lp);
	const Vector&		GetVel();
	Vector				GetVel(const Vector& lp);
	const Vector&		GetAngVel();
	const Vector&		GetNextPos();
	Vector				GetNextPos(const Vector& lp);
	const Vector&		GetNextVel();
	Vector				GetNextVel(const Vector& lp);
	const Vector&		GetNextAngVel();
	virtual void		CalcNextState ( double interval )=0;
	const Vector&		GetInertialMass() const;
	cfloat__t			GetMass() const;
	virtual void		ApplyTorqueImpulse (const Vector& koppel)=0;
	virtual void		ApplyTorqueImpulse (const Vector& koppel, const Vector& localworkpoint)=0;
	virtual void		ApplyImpulse (const Vector& impulse, const Vector& localworkpoint)=0;
	virtual void		ApplyImpulse (const Vector& impulse)=0;
	virtual void		ApplyTorque(const Vector& koppel)=0;
	virtual void		ApplyTorque (const Vector& koppel, const Vector& localworkpoint)=0;
	virtual void		ApplyForce (const Vector& impulse, const Vector& localworkpoint)=0;
	virtual void		ApplyForce (const Vector& impulse)=0;
	virtual Vector		ForcePointVelocity(const Vector& desired_vel, const Vector& localworkpoint)=0; //returns reaction-impulse
	virtual Vector		ForceVelocity(const Vector& desired_vel)=0; //returns reaction-impulse
	virtual Vector		ProcessCollision(const Vector& desired_vel, const Vector& lp, const Vector& dir)=0; //returns reaction-impulse
	virtual MotionInfo_t* GetMotionInfoSource();
	virtual void		Reset();
	virtual void		EndFrame( double frametime )=0;
	virtual void		SetMaxVel( const Vector& b ) { MaxVel = b; }
	virtual void		SetMaxAngVel( const Vector& a ) { MaxAngVel = a; }
	// To make sure collisions won't be processed twice, the first one calls this in the other:
	virtual void		IgnoreNextCollision( CTEntity* entity_to_ignore_collision_with ) = 0;
	// Method for cloning (Cloned entities will have cloned controllers)
	virtual CTEntityController*	Copy() const;
protected:
	virtual bool		DoRegisterWithService();
	virtual bool		DoUnregisterWithService();
	virtual void		DoAddProperties();
	void			SetIntervalTime( double);
	virtual bool	DoEnable();
	virtual void	DoDisable();
//	DTransform		NextTransform;
	MotionInfo_t	MotionInfo;
	MotionInfo_t	NextMotionInfo;
	double			IntervalTime;
	double			ooIntervalTime;
	Vector			MaxVel;			// Hard limit. Inits at 1000 (3600 kmh);
	Vector			MaxAngVel;		// Hard Limit. Inits at 63 (10 rotations per sec);
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTAbstractDyna> PAbstractDyna;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_ABSTRACTDYNA_H_INCLUDED
///////////////////////////////// [citk_AbstractDyna.h] END
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTDynaController );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTDynaController : public CTAbstractDyna
{
	DECLARE_ALL( CTDynaController, CTAbstractDyna );
public:
	CTDynaController();
	virtual void	DynaUpdate( double interval );
	Vector3 GetImpulse();
	Vector3 GetNextImpulse();
	Vector3 GetTorque();
	Vector3 GetNextTorque();
	virtual void CalcNextState ( double interval );
	virtual void ApplyTorqueImpulse (const Vector& koppel);
	virtual void ApplyTorqueImpulse (const Vector& koppel, const Vector& localworkpoint);
	virtual void ApplyImpulse (const Vector& impulse, const Vector& localworkpoint);
	virtual void ApplyImpulse (const Vector& impulse);
	virtual void ApplyTorque(const Vector& koppel);
	virtual void ApplyTorque (const Vector& koppel, const Vector& localworkpoint);
	virtual void ApplyForce (const Vector& impulse, const Vector& localworkpoint);
	virtual void ApplyForce (const Vector& impulse);
	virtual Vector ForcePointVelocity(const Vector& desired_vel, const Vector& localworkpoint); //returns reaction-impulse
	virtual Vector ForceVelocity(const Vector& desired_vel); //returns reaction-impulse
///////////////////////////////////////////////////////////////////////////////
	const Vector& GetAppliedImpulse() const { return AppliedImpulse; }
	Vector GetAppliedTorque() {return AppliedTorqueImpulse*Entity->GetMatrix();}
	void SetVel(const Vector& v);
	void SetAngVel(const Vector& av);
	virtual Vector ProcessCollision(const Vector& desired_vel, const Vector& lp, const Vector& dir); //returns reaction-impulse
	void ApplyNormalForce(const Vector& direction, const Vector& localworkpoint);
	void ApplyNormalForce(const Vector& direction);
	void ProcessFrictionForces();
	void ProcessNormalForces();
/*	void CollisionDetect();
	void CollisionDetectPoint(const Vector& v);
	void CollisionDetectSphere(const float__t& r);
	void CollisionDetectSphere(const float__t& r, const Vector& lp);*/
	virtual void EndFrame( double frametime );
	virtual void OnCollision( CTEntity*, Vector3* local, Vector3* direction );
	virtual void	IgnoreNextCollision( CTEntity* entity_to_ignore_collision_with );
	double			SurfaceFriction;
private:
	Vector			AppliedTorqueImpulse;
	Vector			AppliedImpulse;
	Vector			AppliedForce;
	Vector			AppliedTorqueForce;
	bool			ImpulseApplied, TorqueApplied;
	bool			UpToDate;
	Vector			NormalDirection, NormalWorkPoint;
	bool			NormalForceApplied;
	bool			CollisionNotifyRequested;
	double			Mass, ooMass;
	SafePtr<CTEntity> IgnoreNextCollisionEntity;
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTDynaController> PDynaController;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_DYNACONTROLLER_H_INCLUDED
///////////////////////////////// [citk_DynaController.h] END
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTChildDyna );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTChildDyna : public CTAbstractDyna
{
	DECLARE_ALL( CTChildDyna, CTAbstractDyna );
public:
	CTChildDyna();
	void SetRealDyna (CTDynaController* dc) { RealDyna = dc; }
	virtual void	DynaUpdate( double interval );
	virtual void CalcNextState ( double interval );
	virtual void ApplyTorqueImpulse (const Vector3& koppel);
	virtual void ApplyTorqueImpulse (const Vector3& koppel, const Vector3& localworkpoint);
	virtual void ApplyImpulse (const Vector3& impulse, const Vector3& localworkpoint);
	virtual void ApplyImpulse (const Vector3& impulse);
	virtual void ApplyTorque(const Vector& koppel);
	virtual void ApplyTorque (const Vector& koppel, const Vector& localworkpoint);
	virtual void ApplyForce (const Vector& impulse, const Vector& localworkpoint);
	virtual void ApplyForce (const Vector& impulse);
	virtual Vector3 ForcePointVelocity(const Vector3& desired_vel, const Vector3& localworkpoint); //returns reaction-impulse
	virtual Vector3 ForceVelocity(const Vector3& desired_vel); //returns reaction-impulse
	virtual Vector ProcessCollision(const Vector& desired_vel, const Vector& lp, const Vector& dir); //returns reaction-impulse
	virtual void EndFrame( double frametime ) {}
	virtual void	IgnoreNextCollision( CTEntity* entity_to_ignore_collision_with ) {}
protected:
	virtual void	DoAddProperties();
	PDynaController	RealDyna;
	DTransform		Transform;
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTChildDyna> PChildDyna;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_CHILDDYNA_H_INCLUDED
///////////////////////////////// [citk_ChildDyna.h] END
///////////////////////////////// [citk_Spring.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_SPRING_H_INCLUDED
#define CITK_SPRING_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC (CTSpring);
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
enum SpringType_t { stSpring, stRubberBand, stBumper }; //TODO??? Also configure damperstuff ??
///////////////////////////////////////////////////////////////////////////////////////
class CITK_API CTSpring : public CTController
{
	DECLARE_ALL(CTSpring, CTController);
public:
	CTSpring();
	
	void SetEntity1( CTEntity*, const Vector3& localworkpoint );
	void SetEntity2( CTEntity*, const Vector3& localworkpoint );
	void SetEntities ( CTEntity* ent_a, const Vector3& lwp_a, CTEntity* ent_b, const Vector3& lwp_b );
	void SetLength ( const double& length_in_meters );
	void SetC ( const double& c );
	void SetB ( const double& b );
	void SetType ( SpringType_t );
	void NoMaxImpulse ();
	void SetMaxImpulse ( const double& mf );
	void NoSafeDirection ();
	void SetSafeDirection ( const Vector& sd );
	virtual void ApplyImpulse( double interval );
	virtual bool	DoEnable();
	virtual void	DoDisable();
protected:
	virtual bool	DoRegisterWithService();
	virtual bool	DoUnregisterWithService();
	virtual void	DoAddProperties();
	virtual ~CTSpring();
	Vector dir; // Set to (0,1,0) in Release functies!
	Vector SafeDir;
	bool Use_C, Use_B, Use_MF, Use_SD;
	SpringType_t Type;
	Vector3 LP1, LP2;
	double C,B,Length, MaxForce;
	SafePtr<CTEntity> Ent1, Ent2;
	CTDynaController *Dyna1, *Dyna2;
	PMotionSensor Sens1, Sens2;
	void ReleaseEnt1();
	void ReleaseEnt2();
};
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTSpring> PSpring;
///////////////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
#endif // !CITK_SPRING_H_INCLUDED
///////////////////////////////// [citk_Spring.h] END
///////////////////////////////// [citk_GridPlane.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef _GRIDPLANE_H_INCLUDED
#define _GRIDPLANE_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTGridPlane );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTGridPlane : public CTShape
{
	DECLARE_ALL( CTGridPlane, CTShape );
public:
	// Constructors:
	CTGridPlane( cstr_t =NULL );
	CTGridPlane( const CTGridPlane* const );			// Name"XX+1"
	// Box specific methods
	CTGridPlane( cfloat__t size, int sd );			// Size ( 3x same)
	CTGridPlane( cvec_t dim, int sdx, int sdz );	// Dimensions
	void				SetDimensions( cfloat__t );
	void				SetDimensions( cvec_t );
	void				SetSubdiv( int sx, int sz );
	void				SetSubdiv( int s );
	void				SetSubdivX( int s );
	void				SetSubdivZ( int s );
	void				SetTiling( cfloat__t sx, cfloat__t sz );
	void				SetTiling( cfloat__t s );
	void				SetTilingX( cfloat__t s );
	void				SetTilingZ( cfloat__t s );
	void				DoCheckerBoard( bool=true );
	void				SetColor( const DColor& );
	void				SetColors( const DColor&, const DColor& );
	void				SetColor1( const DColor& );
	void				SetColor2( const DColor& );
	void				SetAlpha( cfloat__t );
	void				SetAlphas( cfloat__t, cfloat__t );
	void				SetAlpha1( cfloat__t );
	void				SetAlpha2( cfloat__t );
	cvec_t				GetDimensions( ) const { return Dimensions; }
	int					GetSubdivX( ) const { return SubdivX; }
	int					GetSubdivZ( ) const { return SubdivZ; }
	float__t				GetTilingX( ) const { return TilingX; }
	float__t				GetTilingZ( ) const { return TilingZ; }
	const DColor&		GetColor( ) const { return Color1; }
	const DColor&		GetColor1( ) const { return Color1; }
	const DColor&		GetColor2( ) const { return Color2; }
	cfloat__t			GetAlpha( ) const { return Alpha1; }
	cfloat__t			GetAlpha1( ) const { return Alpha1; }
	cfloat__t			GetAlpha2( ) const { return Alpha2; }
	bool				DoesCheckerBoard() const { return CheckerBoard; }
	// General:
	virtual double		CalcVolume();
	virtual double		CalcArea();
	virtual	CTShape*	Copy() const;
	// Collision detection helpers:
	virtual Normal		GetNormal( cvec_t );
	virtual Vector		GetSupport( cvec_t );
	virtual double		GetMaxY( cvec_t );
	virtual bool		IsConvex() const { return true; }
	virtual CTSphere*	GetBoundingSphere();
	virtual CTBox*		GetBoundingBox();
	virtual CTShape*	GetBoundingVolume();
	// Rendering:
	virtual void		Render( const RenderInfo_t &, CTMaterial* =NULL );
	// Dinges
	virtual intersect_t	CheckWithPoint( cvec_t, const DTransform* =NULL );
	virtual intersect_t	CheckWithHalfspace( const Plane3&, const DTransform* =NULL );
	virtual intersect_t	CheckWithLine( const Line3&, const DTransform* =NULL );
	// For networking, loading & saving
	virtual void		WriteToStream( CTStream* stream, streamlod_t lod );
	virtual bool		ProcessChunk( CTStream* stream, chunkid_t chid );
protected:
	Vector			Dimensions, HalfDim;
	bool			SizeValid, rsInited;
	int				SubdivX, SubdivZ;
	float__t			TilingX, TilingZ;
	DColor			Color1, Color2;
	bool			CheckerBoard;
	float__t			Alpha1, Alpha2;
	DRenderShape	RenderShape;
	void			UpdateVectors();
	void			UpdateRenderShape();
	// Inherited:
	virtual void	UpdateCWMatrix();
	virtual void	DoAddProperties();
	virtual void	OnPropertyChanged( DProperty& );
};
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTGridPlane> PGridPlane;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_GRIDPLANE_H_INCLUDED
///////////////////////////////// [citk_GridPlane.h] END
///////////////////////////////// [citk_VMFShape.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_VMFSHAPE_H_INCLUDED
#define CITK_VMFSHAPE_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTVMFShape );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTVMFShape : public CTPointShape
{
	DECLARE_ALL( CTVMFShape, CTPointShape );
public:
	// Constructors
	CTVMFShape( cstr_t name = NULL );
	CTVMFShape( const CTVMFShape* cop );
	// Various shit
	virtual CTShape*	Copy() const;
	// Collision detection helpers
//	virtual Vector		GetNormal( const Vector& );
//	virtual double		GetMaxY( const Vector& );
//	virtual double		GetMaxYAndNormal( const Vector&, Normal& );
	virtual intersect_t	CheckWithPoint( const Vector&, const DTransform* =NULL );
private:
	int					SkipEdge;
//	bool				IsUnder_XZ( DFace*, const Vector& );
	int					CheckFor_XZ( int, const Vector& );
	int					FindFace_XZ( const Vector& );
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTVMFShape> PVMFShape;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_VMFSHAPE_H_INCLUDED
///////////////////////////////// [citk_VMFShape.h] END
///////////////////////////////// [citk_FatLine.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_FATLINE_H_INCLUDED
#define CITK_FATLINE_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC( CTFatLine );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
//////////////////////////////////////////////////////////////////////
class CITK_API CTFatLine : public CTVisual
{
	DECLARE_ALL( CTFatLine, CTVisual );
public:
	CTFatLine( cstr_t =NULL, CTGroup* =NULL );
	CTFatLine( const CTFatLine* );
	///// General:
	void			SetThickness( cfloat__t );
	float__t			GetThickness() const { return Thickness; }
	void			SetMaxPoints( int );
	int				GetMaxPoints() const;
	void			SetTextureScaling( cfloat__t );		// 0 means no texture
	void			UseLighting( bool = true );
	void			AddPoint( const Vector& );
	///// Inherited:
	virtual void		Render( RenderInfo_t&, CTMaterial *override =NULL );
	virtual	CTEntity*	Copy() const;
protected:
	DRenderShape	rendershape;
	float__t			Thickness;
	float__t			TextureScaling;
	bool			Texture;
	int				MaxPoints, LastPoint, LastFace;
	ArrayVal<Vector>	Points;
};
///////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTFatLine> PFatLine;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
//////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_FATLINE_H_INCLUDED
///////////////////////////////// [citk_FatLine.h] END
///////////////////////////////// [citk_GridTerrain.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_GRIDTERRAIN_H_INCLUDED
#define CITK_GRIDTERRAIN_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTGridTerrain);
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CITK_API CTGridTerrain : public CTTerrain
{
	DECLARE_ALL(CTGridTerrain, CTTerrain);
public:
	CTGridTerrain();
	// Inherited from CTTerrain:
	virtual bool		SetSatelliteImage( CTTexture* tex );
	virtual bool		LoadHMP( cstr_t filename );
	// LockHMP() returns a pointer to the actual heightmap. User may NOT delete this HM!
	//  You must ALWAYS unlock (asap) to prevent (huge) memory leaks!
	virtual DHeightMap*	LockHMP();
	virtual void		UnlockHMP( bool changed );
	// Use SetHMP() To 'set' a new HMP into the terrain. Only when HMP is NOT locked!!
	// The CTTerrain will become owner of the HM, and might even delete it.
	//  so do not use PTR afterwards!
	virtual bool		SetHMP( DHeightMap* );
	// Pre-calculations for optimized rendering
	virtual bool		PreProcess();
//	Inherited from CTShape	
	virtual void	Render( const RenderInfo_t&, CTMaterial* =NULL );
//	verplichte kutzooi van CTShape
	virtual CTShape*	Copy() const { return 0; }
	virtual Vector3		GetNormal( const Vector& );
	virtual Vector3		GetSupport( const Vector& );
	virtual double		GetMaxY( const Vector &vec ) { return 1; }
	virtual double		GetMaxYAndNormal( const Vector &vec, Normal &normal ) { return 1; }
	virtual intersect_t	CheckWithPoint( const Vector3&, DTransform* =0 );
	virtual intersect_t	CheckWithHalfspace( const Plane&, DTransform* =0 );
	virtual bool		IsConvex() const {return false;}
	virtual double		CalcVolume() const { return 0; }
	virtual double		CalcArea() const { return 0; }
protected:
	DHeightMap* Grid;
	int gridsize;
	float utile,vtile;
//	TFace* colface;
	void	DrawBlock(int x, int z, int blocksize, const RenderInfo_t& );
	bool	LoadFMP(String filename, float fac);
	void	RecalcMinMax();
	void	ScaleY(float);
	ArrayVal<ulong> renderstack;
	float _GetDyDz(int fx, int fz);
	float _GetDyDx(int fx, int fz);
	float GetDyDz(float fx, float fz);
	float GetDyDx(float fx, float fz);
	float GetY(float fx, float fz);
	ArrayPtr< ArrayVal<PMaterial> > lodmats;
	int WhoDid(int,int,int);
	ArrayVal<PMaterial> plainmat;
	int currentrenderitem;
	double qualityfac;
	ArrayPtr< Array2D<float> > minys;
	ArrayPtr< Array2D<float> > maxys;
	ArrayPtr< Array2D<float> > errors;
	double GetLocalMinY(int x, int z, int bsize);
	double GetLocalMaxY(int x, int z, int bsize);
	double GetLocalError(int x, int z, int bsize);
	DRenderShape		rendershape;
	bool WithinFrustum;
	DFlags FrustumFlags;
	const DTransform*	WorldTransform;
	bool	AddMaterialLod( CTTexture* origlfb );
	virtual ~CTGridTerrain();
};
/////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTGridTerrain> PGridTerrain;
/////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITK_GRIDTERRAIN_H_INCLUDED
///////////////////////////////// [citk_GridTerrain.h] END
/*
#include "Devices/citk_Tracker.h"
#include "Devices/citk_UserTracker.h"
#include "Devices/citk_TrackerHardwareIO.h"
#include "Devices/citk_Joystick.h"
#include "Devices/citk_JoystickInfo.h"
#include "Devices/citk_UserJoystick.h"
*/
//#include "General/citk_PipelineStage.h"
///////////////////////////////// [citk_ScriptReader.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_SCRIPTREADER_H_INCLUDED
#define CITK_SCRIPTREADER_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citk_ScriptHandler.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_SCRIPTHANDLER_H_INCLUDED
#define CITK_SCRIPTHANDLER_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
DLL_DECLARE_CLASSDESC(CTScriptHandler);
DLL_DECLARE_CLASSDESC(CTSmartScriptHandler);
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////////////
class CITK_API CTScriptHandler : public CTReferenced
{
	DECLARE_ALL( CTScriptHandler, CTReferenced );
public:
	virtual bool	ProcessMarkup ( const String& ) =0 ;
	virtual bool	ProcessContent( const String& ) =0 ;
	virtual bool	ProcessComment( const String& ) =0 ;
	virtual bool	End() =0 ;
};
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTScriptHandler> PScriptHandler;
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
//
// SMART SCRIPT HANDLER
//
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
//
// The Way It Works
// 
// If a handler receives new markup, it checks whether it can handle the markup.
// If not: return false  
// If yes, closing the markup we were started with:
//   Call End() and return; We should not receive any more content.
// If yes, internal handling:
//   handle.
// If yes, new handler required:
//   If applicable, create a new handler
//   Start the new handler by sending it this markup.
//   Keep sending it the following
//   markup/content/comment/errors until this handler's IsStarted returns false.
//
///////////////////////////////////////////////////////////////////////////////////////
class CITK_API CTSmartScriptHandler : public CTScriptHandler
{
	DECLARE_ALL(CTSmartScriptHandler, CTScriptHandler);
	friend class DScriptReader;
public:
	CTSmartScriptHandler();
	virtual bool	ProcessMarkup ( const String& );
	virtual bool	ProcessContent( const String& );
	virtual bool	ProcessComment( const String& );
	virtual bool	End() ;
	bool			IsActive() const { return Started; }
protected:
	virtual ~CTSmartScriptHandler();
	virtual bool	DoProcessMarkup ( const String&, const String& ) =0;
	virtual bool	DoProcessContent( const String& ) =0;
	virtual bool	DoProcessComment( const String& ) { return true; }
	bool			ActivateSubHandler( CTSmartScriptHandler*, const String&, const String& );
private:
	StrongPtr<CTSmartScriptHandler> SubHandler;
	bool			Started;
};
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
typedef StrongPtr<CTSmartScriptHandler> PSmartScriptHandler;
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////
#endif // !CITK_SCRIPTHANDLER_H_INCLUDED
///////////////////////////////// [citk_ScriptHandler.h] END
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citk {
///////////////////////////////////////////////////////////////////////////////
class CITK_API DScriptReader
{
public:
	DScriptReader();
	bool	ProcessScript( cstr_t filename, CTScriptHandler* );
	int		GetCurrentLine() const { return current_line; }
private:
	int		current_line;
	String	_PostProcess( String );
};
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_SCRIPTREADER_H_INCLUDED
///////////////////////////////// [citk_ScriptReader.h] END
//#include "Managers/citk_MaterialMan.h"
//#include "Managers/citk_RenderPipeMan.h"
///////////////////////////////////////////////////////////////////////////////
#endif // !ONLY_VERSION_INFO
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !_CITKFULL_H_INCLUDED_
///////////////////////////////// [_citkfull.h] END
