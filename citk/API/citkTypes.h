// This file was generated by HExpand v 1.6
//
///////////////////////////////// [_citkTypes.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef _CITKTYPES_H_INCLUDED
#define _CITKTYPES_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citkt_TypesVersion.h]
// This file was generated by HExpand v 1.6
//
#define CITK_TYPES_VER 327
///////////////////////////////// [citkt_TypesVersion.h] END
///////////////////////////////////////////////////////////////////////////////
// Check and set win32 build target for all Crystal Builds to Win2000, not higher //
///////////////////////////////////////////////////////////////////////////////
#ifndef _WIN32_WINNT
# define _WIN32_WINNT 0x0500 // Win 2000
#else
# if _WIN32_WINNT > 0x0500
#   error _WIN32_WINNT set to something higher than win2000 - Crystal Project should target windows 2000
# endif
#endif
#ifndef WINVER
# define WINVER 0x0500 // Win 2000
#endif
#ifndef NTDDI_VERSION
# define NTDDI_VERSION 0x05000400 //NTDDI_WIN2KSP4 //2000 sp4
#endif
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#ifndef ONLY_VERSION_INFO
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// Defines for MS VC++ compiler
#ifdef _MSC_VER
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
#ifndef CITK_NO_DEFAULTLIB
# pragma comment (lib,"citkTypes.lib")
#endif // !CITK_NO_DEFAULTLIB
#endif // _MSC_VER
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citkt_AArray.h]
#pragma once
///////////////////////////////// [citkt_General.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
//
//  General	Regularly used types
//
//  Copyright by Crystal Intertechnology BV 2000/2001 All rights reserved.
//
//  MSVC6 version  (bool, false/true, M_PI removed, VPC compat. removed)
//  Added support for TCHAR, CDECL
//
#ifndef CITKT_GENERAL_H_INCLUDED
#define CITKT_GENERAL_H_INCLUDED
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#ifdef _MSC_VER
// Only for Microsoft Visual C++
// 4127		conditional expression is constant
// 4163 	'identifier' : not available as an intrinsic function
// 4244 	'conversion' conversion from 'type1' to 'type2', possible loss of data
// 4251		'identifier' : class 'type' needs to have dll-interface to be used by clients of class 'type2'
// 4305* 	'identifier' : truncation from 'type1' to 'type2'
// 4710		'function' : function not inlined
// 4711		function 'function' selected for inline expansion
// 4511		'class' : copy constructor could not be generated
// 4512		'class' : assignment operator could not be generated
// 4996		'function' was declared deprecated
# pragma warning( disable : 4127 4163 4244 4251 4710 4711 4511 4512 4996 )
# undef CDECL
# define CDECL __cdecl
#else // _MSC_VER
# undef CDECL
# define CDECL
#endif // _MSC_VER
#ifdef __GNUC__
# include <stddef.h>
#endif
#include <stdlib.h>
///////////////////////////////// [citkt_tchar.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_TCHAR_H_INCLUDED
#define CITK_TCHAR_H_INCLUDED
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#include <string.h>
#ifdef _MSC_VER
#ifdef UTF8
	// Use _MBCS CRT functions in UTF8 mode
	#undef _UNICODE
	#undef _MBCS
	#define _MBCS
#endif
	#include <tchar.h>
	typedef TCHAR			char_t;
	typedef unsigned int	uchar_t;
	typedef TCHAR*			str_t;
	typedef const TCHAR*	cstr_t;
#else // !_MSC_VER
#if defined UTF8
	#include <ctype.h>
	#define _T(a)			a
	typedef char			char_t;
	typedef unsigned int	uchar_t;
	typedef char*			str_t;
	typedef const char*		cstr_t;
	#define _tcsicmp stricmp
	#define _tcscpy strcpy
	#define _tcscmp strcmp
	#define _tcslen strlen
	#define _tcscat strcat
	#define _tcsnicmp strnicmp
	#define _tcsstr strstr
	#define _tcscspn strcspn
	#define _tcsncpy strncpy
	#define _tcsncmp strncmp
	#define _tcsdup strdup
	#define _stscanf sscanf
	#define _tcsrchr utf8chr
	#define _tcstof strtof			// TODO
	#define _tcstod strtod			// TODO
	#define _tcstol strtol			// TODO
	#define _stprintf sprintf		// TODO
	#define _ftprintf fprintf		// TODO
	#define _vstprintf vsprintf		// TODO
	#define _vsntprintf vsnprintf	// TODO
	#define _vftprintf vfprintf		// TODO
	#define _tcslwr strlwr			// TODO
	#define _tcsupr strupr			// TODO
	#define _tcsrev strrev			// TODO
	#define _puttchar putchar		// TODO: use wcs* on WIN32
	#define _ttempnam tempnam		// TODO: use wcs* on WIN32
	#define _tprintf printf			// TODO: use wcs* on WIN32
	#define _vtprintf vprintf		// TODO: use wcs* on WIN32
	#define _putts puts				// TODO: use wcs* on WIN32
	#define _tfopen fopen			// TODO: use wcs* on WIN32
	#define _tremove remove			// TODO: use wcs* on WIN32
#elif !defined _UNICODE
	#define _T(a)			a
	typedef char			char_t;
	typedef char			uchar_t;
	typedef char*			str_t;
	typedef const char*		cstr_t;
	#define _tcsicmp stricmp
	#define _tcscpy strcpy
	#define _tcscmp strcmp
	#define _tcslen strlen
	#define _tcscat strcat
	#define _tcsnicmp strnicmp
	#define _tcsstr strstr
	#define _tcscspn strcspn
	#define _tcsncpy strncpy
	#define _tcsncmp strncmp
	#define _tcsdup strdup
	#define _stscanf sscanf
	#define _ttempnam tempnam
	#define _tcstof strtof
	#define _tcstod strtod
	#define _tcstol strtol
	#define _tcschr strchr
	#define _tcsrchr strrchr
	#define _puttchar putchar
	#define _tprintf printf
	#define _stprintf sprintf
	#define _ftprintf fprintf
	#define _vtprintf vprintf
	#define _vstprintf vsprintf
	#define _vsntprintf vsnprintf
	#define _vftprintf vfprintf
	#define _putts puts
	#define _tfopen fopen
	#define _tremove remove
	#define _tcslwr strlwr
	#define _tcsupr strupr
	#define _tcsrev strrev
#else // _UNICODE
	#include <wctype.h>
	#include <wchar.h>
	#define _T(a)			L##a
	typedef wchar_t			char_t;
	typedef wchar_t*		str_t;
	typedef const wchar_t*	cstr_t;
	#define _tcsicmp wcsicmp
	#define _tcscpy wcscpy
	#define _tcscmp wcscmp
	#define _tcslen wcslen
	#define _tcscat wcscat
	#define _tcsnicmp wcsnicmp
	#define _tcsstr wcsstr
	#define _tcscspn wcscspn
	#define _tcsncpy wcsncpy
	#define _tcschr wcschr
	#define _tcsrchr wcsrchr
	#define _tcsncmp wcsncmp
	#define _tcsdup wcsdup
	#define _tprintf wprintf
	#define _stprintf swprintf
	#define _ftprintf fwprintf
	#define _vtprintf vwprintf
	#define _vstprintf vswprintf	// check the prototype of _vstprintf
	#define _vsntprintf vswprintf	
	#define _vftprintf vfwprintf
	#define _putts putws
	#define _tcstof wcstof
	#define _tcstod wcstod
	#define _tcstol wcstol
	#define _tcslwr wcslwr
	#define _tcsupr wcsupr
	#define _tcsrev wcsrev
	#define _puttchar putwchar
	#define _stscanf swscanf		// TODO: use UTF8 on *NIX
	#define _tfopen _wfopen			// TODO: use UTF8 on *NIX
	#define _tremove _wremove		// TODO: use UTF8 on *NIX
	#define _ttempnam _wtempnam		// TODO: use UTF8 on *NIX
#endif // _UNICODE
#endif // !_MSC_VER
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITK_TCHAR_H_INCLUDED
///////////////////////////////// [citkt_tchar.h] END
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
/////////////////////////////////////////////////////////////////////////////
// Regularly used macro's:
#define _sqr(x)			((x)*(x))							// square
#define _sgn(x)			((x)?((x)>0?1:-1):0)				// sign
#define _abs(x)			((x)<0?-(x):x)						// absolute
#define _min(x,y)		((x)>(y)?(y):(x))					// minimum
#define _max(x,y)		((x)>(y)?(x):(y))					// maximum
#define _max3(x,y,z)	_max(_max(x,y),z)					// maximum of 3
#define _min3(x,y,z)	_min(_min(x,y),z)					// minimum of 3
#define _limit(a,x,y)	((a)<(x)?(x):((a)>(y)?(y):(a)))		// makes x<=a<=y
#define _mod(x,y)		((x) - (y)*floor((x)/(float)(y)))
#define _smaller(a,l)	((unsigned)(a)<(unsigned)(l))		// 0<=a<l ?
#define _smallereq(a,l)	((unsigned)(a)<=(unsigned)(l))		// 0<=a<=l ?
#ifdef _MSC_VER
# ifdef _M_IX86
#  define BREAK			__asm int 3		// CPU dependent breakpoint
# endif
#endif
#ifdef __GNUC__
# ifdef __i386__
#  define BREAK			asm("int $3")
# endif
	// TODO: Look up BREAK for MIPS and others
#endif
#ifndef BREAK
# define BREAK
#endif
#define SELF			(*this)			// easy access to 'this' object
#define lengthof(x)		(sizeof(x)/sizeof(x[0]))
#ifndef offsetof
# define offsetof(s,m)   (size_t)&(((s *)0)->m)
#endif
#ifndef interface
# define citk_interface		struct
#endif
#ifndef NULL
# define NULL			(0)				// can't cast void* to other*
#endif
#define null			(0)				// can't cast void* to other*
// Some floating-point math stuff
#define _fabs(x)	(fabs(x))
#define _fsqrt(s)	(sqrt(s))
#define _feqz(x)	(_fabs(x)<EPSILON)				// x == ~0.0 ?
#define _fneqz(x)	(!_feqz(x))						// x != ~0.0 ?
#define _feq(x,y)	_feqz((x)-(y))					// x == y ?
#define _fneq(x,y)	_fneqz((x)-(y))					// x != y ?
#define _fsgn(x)	((x)<0.0f?-1:1)					// sign for floats
#define _frnd(s)	(rand()*((s)/(float)(RAND_MAX)))
// For MSC, redefine _finite is used instead finite
#ifdef _MSC_VER
# define finite _finite
# define tempnam _tempnam
//# define vsnprintf _vsnprintf
#endif
// Math constants (should these be const double/float?)
#define EPSILON		(1.0e-5f)						// used by _feqz etc
#ifndef M_PI
# define M_PI	3.1415926535897932384626433832795	// from calc
#endif
#ifndef PI
# define PI M_PI
#endif
#define M_2PI (2*M_PI)
#define M_HPI (M_PI*0.5f)
#ifndef M_E
# define M_E	2.7182818284590452353602874713527	// from calc
#endif
#define DEG2RAD(x) ((x)*((float)M_PI/180.0f))
#define RAD2DEG(x) ((x)*(180.0f/(float)M_PI))
// Stringizing macros
#define __S(x) #x
#define _S(x) __S(x)
// Constants for unit conversions
#define MICRO			*(0.000001f)
#define MILLI			*(0.001f)
#define KILO			*(1000)
#define MEGA			*(1000000)
#define SECONDS			*(1000)						// only adjust this one
#define TIME(i)			((i)*0.001f)				// and maybe this one
#define MINUTES			*(60 SECONDS)
#define HOURS			*(60 MINUTES)
#define MILLISECONDS	/*(1 MILLI SECONDS)*/		// optimized
#define SECOND			SECONDS
#define MINUTE			MINUTES
#define HOUR			HOURS
#define MILLISECOND		MILLISECONDS
/////////////////////////////////////////////////////////////////////////////
// Some regularly used typedefs
typedef unsigned char	uchar;
#ifndef ULONG_BUILT_IN
typedef unsigned short	ushort;
typedef unsigned int	uint;
typedef unsigned long	ulong;
#endif
// Pascal/asm compatibility:
typedef unsigned char	byte;
typedef unsigned short	word;
typedef unsigned int	dchar;
typedef unsigned long	dword;
// Sized integers
typedef char			int8;
typedef unsigned char	uint8;
typedef short			int16;
typedef unsigned short	uint16;
typedef int				int32;
typedef unsigned int	uint32;
// For 64-bit compatibility:
#ifdef _MSC_VER
typedef	__int64				int64;
typedef	unsigned __int64	uint64;
#endif
#ifdef __GNUC__
typedef	long long			int64;
typedef	unsigned long long	uint64;
#endif
#ifdef _WIN64
typedef int64		long_ptr;
typedef uint64		ulong_ptr;
#else
typedef long		long_ptr;
typedef ulong		ulong_ptr;
#endif
// Important typedefs for citk
typedef float			float__t;		// floating point type for engine
typedef const float__t	cfloat__t;		// type for floats (parameters)
typedef long			ctime_t;		// type for times
typedef ulong_ptr		hash_t;			// type for hashes
// Comparison function (used by qsort a.o.)
typedef int (CDECL *comparefunc_t )(const void *elem1, const void *elem2 );
/////////////////////////////////////////////////////////////////////////////
inline void _set_nan( float &f )			{ ((int&)f) = ~0; }
inline void _set_nan( double &d )			{ ((int64&)d) = ~0; }
//inline void _set_nan( long double &d )	{ ((int64&)d) = ~0; }
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_GENERAL_H_INCLUDED
///////////////////////////////// [citkt_General.h] END
///////////////////////////////// [citkt_delegate.h]
#pragma once
///////////////////////////////// [FastDelegate.h]
//						FastDelegate.h 
//	Efficient delegates in C++ that generate only two lines of asm code!
//  Documentation is found at http://www.codeproject.com/cpp/FastDelegate.asp
//
//						- Don Clugston, Mar 2004.
//		Major contributions were made by Jody Hagins.
// History:
// 24-Apr-04 1.0  * Submitted to CodeProject. 
// 28-Apr-04 1.1  * Prevent most unsafe uses of evil static function hack.
//				  * Improved syntax for horrible_cast (thanks Paul Bludov).
//				  * Tested on Metrowerks MWCC and Intel ICL (IA32)
//				  * Compiled, but not run, on Comeau C++ and Intel Itanium ICL.
//	27-Jun-04 1.2 * Now works on Borland C++ Builder 5.5
//				  * Now works on /clr "managed C++" code on VC7, VC7.1
//				  * Comeau C++ now compiles without warnings.
//				  * Prevent the virtual inheritance case from being used on 
//					  VC6 and earlier, which generate incorrect code.
//				  * Improved warning and error messages. Non-standard hacks
//					 now have compile-time checks to make them safer.
//				  * implicit_cast used instead of static_cast in many cases.
//				  * If calling a const member function, a const class pointer can be used.
//				  * MakeDelegate() global helper function added to simplify pass-by-value.
//				  * Added fastdelegate.clear()
// 16-Jul-04 1.2.1* Workaround for gcc bug (const member function pointers in templates)
// 30-Oct-04 1.3  * Support for (non-void) return values.
//				  * No more workarounds in client code!
//					 MSVC and Intel now use a clever hack invented by John Dlugosz:
//				     - The FASTDELEGATEDECLARE workaround is no longer necessary.
//					 - No more warning messages for VC6
//				  * Less use of macros. Error messages should be more comprehensible.
//				  * Added include guards
//				  * Added FastDelegate::empty() to test if invocation is safe (Thanks Neville Franks).
//				  * Now tested on VS 2005 Express Beta, PGI C++
// 24-Dec-04 1.4  * Added DelegateMemento, to allow collections of disparate delegates.
//                * <,>,<=,>= comparison operators to allow storage in ordered containers.
//				  * Substantial reduction of code size, especially the 'Closure' class.
//				  * Standardised all the compiler-specific workarounds.
//                * MFP conversion now works for CodePlay (but not yet supported in the full code).
//                * Now compiles without warnings on _any_ supported compiler, including BCC 5.5.1
//				  * New syntax: FastDelegate< int (char *, double) >. 
// 14-Feb-05 1.4.1* Now treats =0 as equivalent to .clear(), ==0 as equivalent to .empty(). (Thanks elfric).
//				  * Now tested on Intel ICL for AMD64, VS2005 Beta for AMD64 and Itanium.
// 30-Mar-05 1.5  * Safebool idiom: "if (dg)" is now equivalent to "if (!dg.empty())"
//				  * Fully supported by CodePlay VectorC
//                * Bugfix for Metrowerks: empty() was buggy because a valid MFP can be 0 on MWCC!
//                * More optimal assignment,== and != operators for static function pointers.
#ifndef FASTDELEGATE_H
#define FASTDELEGATE_H
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
#include <memory.h> // to allow <,> comparisons
////////////////////////////////////////////////////////////////////////////////
//						Configuration options
//
////////////////////////////////////////////////////////////////////////////////
// Uncomment the following #define for optimally-sized delegates.
// In this case, the generated asm code is almost identical to the code you'd get
// if the compiler had native support for delegates.
// It will not work on systems where sizeof(dataptr) < sizeof(codeptr). 
// Thus, it will not work for DOS compilers using the medium model.
// It will also probably fail on some DSP systems.
#define FASTDELEGATE_USESTATICFUNCTIONHACK
// Uncomment the next line to allow function declarator syntax.
// It is automatically enabled for those compilers where it is known to work.
//#define FASTDELEGATE_ALLOW_FUNCTION_TYPE_SYNTAX
////////////////////////////////////////////////////////////////////////////////
//						Compiler identification for workarounds
//
////////////////////////////////////////////////////////////////////////////////
// Compiler identification. It's not easy to identify Visual C++ because
// many vendors fraudulently define Microsoft's identifiers.
#if defined(_MSC_VER) && !defined(__MWERKS__) && !defined(__VECTOR_C) && !defined(__ICL) && !defined(__BORLANDC__)
#define FASTDLGT_ISMSVC
#if (_MSC_VER <1300) // Many workarounds are required for VC6.
#define FASTDLGT_VC6
#pragma warning(disable:4786) // disable this ridiculous warning
#endif
#endif
// Does the compiler uses Microsoft's member function pointer structure?
// If so, it needs special treatment.
// Metrowerks CodeWarrior, Intel, and CodePlay fraudulently define Microsoft's 
// identifier, _MSC_VER. We need to filter Metrowerks out.
#if defined(_MSC_VER) && !defined(__MWERKS__)
#define FASTDLGT_MICROSOFT_MFP
#if !defined(__VECTOR_C)
// CodePlay doesn't have the __single/multi/virtual_inheritance keywords
#define FASTDLGT_HASINHERITANCE_KEYWORDS
#endif
#endif
// Does it allow function declarator syntax? The following compilers are known to work:
#if defined(FASTDLGT_ISMSVC) && (_MSC_VER >=1310) // VC 7.1
#define FASTDELEGATE_ALLOW_FUNCTION_TYPE_SYNTAX
#endif
// Gcc(2.95+), and versions of Digital Mars, Intel and Comeau in common use.
#if defined (__DMC__) || defined(__GNUC__) || defined(__ICL) || defined(__COMO__)
#define FASTDELEGATE_ALLOW_FUNCTION_TYPE_SYNTAX
#endif
// It works on Metrowerks MWCC 3.2.2. From boost.Config it should work on earlier ones too.
#if defined (__MWERKS__)
#define FASTDELEGATE_ALLOW_FUNCTION_TYPE_SYNTAX
#endif
#ifdef __GNUC__ // Workaround GCC bug #8271 
	// At present, GCC doesn't recognize constness of MFPs in templates
#define FASTDELEGATE_GCC_BUG_8271
#endif
////////////////////////////////////////////////////////////////////////////////
//						General tricks used in this code
//
// (a) Error messages are generated by typdefing an array of negative size to
//     generate compile-time errors.
// (b) Warning messages on MSVC are generated by declaring unused variables, and
//	    enabling the "variable XXX is never used" warning.
// (c) Unions are used in a few compiler-specific cases to perform illegal casts.
// (d) For Microsoft and Intel, when adjusting the 'this' pointer, it's cast to
//     (char *) first to ensure that the correct number of *bytes* are added.
//
////////////////////////////////////////////////////////////////////////////////
//						Helper templates
//
////////////////////////////////////////////////////////////////////////////////
namespace fastdelegate {
namespace detail {	// we'll hide the implementation details in a nested namespace.
//		implicit_cast< >
// I believe this was originally going to be in the C++ standard but 
// was left out by accident. It's even milder than static_cast.
// I use it instead of static_cast<> to emphasize that I'm not doing
// anything nasty. 
// Usage is identical to static_cast<>
template <class OutputClass, class InputClass>
inline OutputClass implicit_cast(InputClass input){
	return input;
}
//		horrible_cast< >
// This is truly evil. It completely subverts C++'s type system, allowing you 
// to cast from any class to any other class. Technically, using a union 
// to perform the cast is undefined behaviour (even in C). But we can see if
// it is OK by checking that the union is the same size as each of its members.
// horrible_cast<> should only be used for compiler-specific workarounds. 
// Usage is identical to reinterpret_cast<>.
// This union is declared outside the horrible_cast because BCC 5.5.1
// can't inline a function with a nested class, and gives a warning.
template <class OutputClass, class InputClass>
union horrible_union{
	OutputClass out;
	InputClass in;
};
template <class OutputClass, class InputClass>
inline OutputClass horrible_cast(const InputClass input){
	horrible_union<OutputClass, InputClass> u;
	// Cause a compile-time error if in, out and u are not the same size.
	// If the compile fails here, it means the compiler has peculiar
	// unions which would prevent the cast from working.
	typedef int ERROR_CantUseHorrible_cast[sizeof(InputClass)==sizeof(u) 
		&& sizeof(InputClass)==sizeof(OutputClass) ? 1 : -1];
	u.in = input;
	return u.out;
}
////////////////////////////////////////////////////////////////////////////////
//						Workarounds
//
////////////////////////////////////////////////////////////////////////////////
// Backwards compatibility: This macro used to be necessary in the virtual inheritance
// case for Intel and Microsoft. Now it just forward-declares the class.
#define FASTDELEGATEDECLARE(CLASSNAME)	class CLASSNAME;
// Prevent use of the static function hack with the DOS medium model.
#ifdef __MEDIUM__
#undef FASTDELEGATE_USESTATICFUNCTIONHACK
#endif
//			DefaultVoid - a workaround for 'void' templates in VC6.
//
//  (1) VC6 and earlier do not allow 'void' as a default template argument.
//  (2) They also doesn't allow you to return 'void' from a function.
//
// Workaround for (1): Declare a dummy type 'DefaultVoid' which we use
//   when we'd like to use 'void'. We convert it into 'void' and back
//   using the templates DefaultVoidToVoid<> and VoidToDefaultVoid<>.
// Workaround for (2): On VC6, the code for calling a void function is
//   identical to the code for calling a non-void function in which the
//   return value is never used, provided the return value is returned
//   in the EAX register, rather than on the stack. 
//   This is true for most fundamental types such as int, enum, void *.
//   Const void * is the safest option since it doesn't participate 
//   in any automatic conversions. But on a 16-bit compiler it might
//   cause extra code to be generated, so we disable it for all compilers
//   except for VC6 (and VC5).
#ifdef FASTDLGT_VC6
// VC6 workaround
typedef const void * DefaultVoid;
#else
// On any other compiler, just use a normal void.
typedef void DefaultVoid;
#endif
// Translate from 'DefaultVoid' to 'void'.
// Everything else is unchanged
template <class T>
struct DefaultVoidToVoid { typedef T type; };
template <>
struct DefaultVoidToVoid<DefaultVoid> {	typedef void type; };
// Translate from 'void' into 'DefaultVoid'
// Everything else is unchanged
template <class T>
struct VoidToDefaultVoid { typedef T type; };
template <>
struct VoidToDefaultVoid<void> { typedef DefaultVoid type; };
////////////////////////////////////////////////////////////////////////////////
//						Fast Delegates, part 1:
//
//		Conversion of member function pointer to a standard form
//
////////////////////////////////////////////////////////////////////////////////
// GenericClass is a fake class, ONLY used to provide a type.
// It is vitally important that it is never defined, so that the compiler doesn't
// think it can optimize the invocation. For example, Borland generates simpler
// code if it knows the class only uses single inheritance.
// Compilers using Microsoft's structure need to be treated as a special case.
#ifdef  FASTDLGT_MICROSOFT_MFP
#ifdef FASTDLGT_HASINHERITANCE_KEYWORDS
	// For Microsoft and Intel, we want to ensure that it's the most efficient type of MFP 
	// (4 bytes), even when the /vmg option is used. Declaring an empty class 
	// would give 16 byte pointers in this case....
	class __single_inheritance GenericClass;
#endif
	// ...but for Codeplay, an empty class *always* gives 4 byte pointers.
	// If compiled with the /clr option ("managed C++"), the JIT compiler thinks
	// it needs to load GenericClass before it can call any of its functions,
	// (compiles OK but crashes at runtime!), so we need to declare an 
	// empty class to make it happy.
	// Codeplay and VC4 can't cope with the unknown_inheritance case either.
	class GenericClass {};
#else
	class GenericClass;
#endif
// The size of a single inheritance member function pointer.
const int SINGLE_MEMFUNCPTR_SIZE = sizeof(void (GenericClass::*)());
//						SimplifyMemFunc< >::Convert()
//
//	A template function that converts an arbitrary member function pointer into the 
//	simplest possible form of member function pointer, using a supplied 'this' pointer.
//  According to the standard, this can be done legally with reinterpret_cast<>.
//	For (non-standard) compilers which use member function pointers which vary in size 
//  depending on the class, we need to use	knowledge of the internal structure of a 
//  member function pointer, as used by the compiler. Template specialization is used
//  to distinguish between the sizes. Because some compilers don't support partial 
//	template specialisation, I use full specialisation of a wrapper struct.
// general case -- don't know how to convert it. Force a compile failure
template <int N>
struct SimplifyMemFunc {
	template <class X, class XFuncType, class GenericMemFuncType>
	inline static GenericClass *Convert(X *pthis, XFuncType function_to_bind, 
		GenericMemFuncType &bound_func) { 
		// Unsupported member function type -- force a compile failure.
	    // (it's illegal to have a array with negative size).
		typedef char ERROR_Unsupported_member_function_pointer_on_this_compiler[N-100];
		return 0; 
	}
};
// For compilers where all member func ptrs are the same size, everything goes here.
// For non-standard compilers, only single_inheritance classes go here.
template <>
struct SimplifyMemFunc<SINGLE_MEMFUNCPTR_SIZE>  {	
	template <class X, class XFuncType, class GenericMemFuncType>
	inline static GenericClass *Convert(X *pthis, XFuncType function_to_bind, 
			GenericMemFuncType &bound_func) {
#if defined __DMC__  
		// Digital Mars doesn't allow you to cast between abitrary PMF's, 
		// even though the standard says you can. The 32-bit compiler lets you
		// static_cast through an int, but the DOS compiler doesn't.
		bound_func = horrible_cast<GenericMemFuncType>(function_to_bind);
#else 
        bound_func = reinterpret_cast<GenericMemFuncType>(function_to_bind);
#endif
        return reinterpret_cast<GenericClass *>(pthis);
	}
};
////////////////////////////////////////////////////////////////////////////////
//						Fast Delegates, part 1b:
//
//					Workarounds for Microsoft and Intel
//
////////////////////////////////////////////////////////////////////////////////
// Compilers with member function pointers which violate the standard (MSVC, Intel, Codeplay),
// need to be treated as a special case.
#ifdef FASTDLGT_MICROSOFT_MFP
// We use unions to perform horrible_casts. I would like to use #pragma pack(push, 1)
// at the start of each function for extra safety, but VC6 seems to ICE
// intermittently if you do this inside a template.
// __multiple_inheritance classes go here
// Nasty hack for Microsoft and Intel (IA32 and Itanium)
template<>
struct SimplifyMemFunc< SINGLE_MEMFUNCPTR_SIZE + sizeof(int) >  {
	template <class X, class XFuncType, class GenericMemFuncType>
	inline static GenericClass *Convert(X *pthis, XFuncType function_to_bind, 
		GenericMemFuncType &bound_func) { 
		// We need to use a horrible_cast to do this conversion.
		// In MSVC, a multiple inheritance member pointer is internally defined as:
        union {
			XFuncType func;
			struct {	 
				GenericMemFuncType funcaddress; // points to the actual member function
				int delta;	     // #BYTES to be added to the 'this' pointer
			}s;
        } u;
		// Check that the horrible_cast will work
		typedef int ERROR_CantUsehorrible_cast[sizeof(function_to_bind)==sizeof(u.s)? 1 : -1];
        u.func = function_to_bind;
		bound_func = u.s.funcaddress;
		return reinterpret_cast<GenericClass *>(reinterpret_cast<char *>(pthis) + u.s.delta); 
	}
};
// virtual inheritance is a real nuisance. It's inefficient and complicated.
// On MSVC and Intel, there isn't enough information in the pointer itself to
// enable conversion to a closure pointer. Earlier versions of this code didn't
// work for all cases, and generated a compile-time error instead.
// But a very clever hack invented by John M. Dlugosz solves this problem.
// My code is somewhat different to his: I have no asm code, and I make no 
// assumptions about the calling convention that is used.
// In VC++ and ICL, a virtual_inheritance member pointer 
// is internally defined as:
struct MicrosoftVirtualMFP {
	void (GenericClass::*codeptr)(); // points to the actual member function
	int delta;		// #bytes to be added to the 'this' pointer
	int vtable_index; // or 0 if no virtual inheritance
};
// The CRUCIAL feature of Microsoft/Intel MFPs which we exploit is that the
// m_codeptr member is *always* called, regardless of the values of the other
// members. (This is *not* true for other compilers, eg GCC, which obtain the
// function address from the vtable if a virtual function is being called).
// Dlugosz's trick is to make the codeptr point to a probe function which
// returns the 'this' pointer that was used.
// Define a generic class that uses virtual inheritance.
// It has a trival member function that returns the value of the 'this' pointer.
struct GenericVirtualClass : virtual public GenericClass
{
	typedef GenericVirtualClass * (GenericVirtualClass::*ProbePtrType)();
	GenericVirtualClass * GetThis() { return this; }
};
// __virtual_inheritance classes go here
template <>
struct SimplifyMemFunc<SINGLE_MEMFUNCPTR_SIZE + 2*sizeof(int) >
{
	template <class X, class XFuncType, class GenericMemFuncType>
	inline static GenericClass *Convert(X *pthis, XFuncType function_to_bind, 
		GenericMemFuncType &bound_func) {
		union {
			XFuncType func;
			GenericClass* (X::*ProbeFunc)();
			MicrosoftVirtualMFP s;
		} u;
		u.func = function_to_bind;
		bound_func = reinterpret_cast<GenericMemFuncType>(u.s.codeptr);
		union {
			GenericVirtualClass::ProbePtrType virtfunc;
			MicrosoftVirtualMFP s;
		} u2;
		// Check that the horrible_cast<>s will work
		typedef int ERROR_CantUsehorrible_cast[sizeof(function_to_bind)==sizeof(u.s)
			&& sizeof(function_to_bind)==sizeof(u.ProbeFunc)
			&& sizeof(u2.virtfunc)==sizeof(u2.s) ? 1 : -1];
   // Unfortunately, taking the address of a MF prevents it from being inlined, so 
   // this next line can't be completely optimised away by the compiler.
		u2.virtfunc = &GenericVirtualClass::GetThis;
		u.s.codeptr = u2.s.codeptr;
		return (pthis->*u.ProbeFunc)();
	}
};
#if (_MSC_VER <1300)
// Nasty hack for Microsoft Visual C++ 6.0
// unknown_inheritance classes go here
// There is a compiler bug in MSVC6 which generates incorrect code in this case!!
template <>
struct SimplifyMemFunc<SINGLE_MEMFUNCPTR_SIZE + 3*sizeof(int) >
{
	template <class X, class XFuncType, class GenericMemFuncType>
	inline static GenericClass *Convert(X *pthis, XFuncType function_to_bind, 
		GenericMemFuncType &bound_func) {
		// There is an apalling but obscure compiler bug in MSVC6 and earlier:
		// vtable_index and 'vtordisp' are always set to 0 in the 
		// unknown_inheritance case!
		// This means that an incorrect function could be called!!!
		// Compiling with the /vmg option leads to potentially incorrect code.
		// This is probably the reason that the IDE has a user interface for specifying
		// the /vmg option, but it is disabled -  you can only specify /vmg on 
		// the command line. In VC1.5 and earlier, the compiler would ICE if it ever
		// encountered this situation.
		// It is OK to use the /vmg option if /vmm or /vms is specified.
		// Fortunately, the wrong function is only called in very obscure cases.
		// It only occurs when a derived class overrides a virtual function declared 
		// in a virtual base class, and the member function 
		// points to the *Derived* version of that function. The problem can be
		// completely averted in 100% of cases by using the *Base class* for the 
		// member fpointer. Ie, if you use the base class as an interface, you'll
		// stay out of trouble.
		// Occasionally, you might want to point directly to a derived class function
		// that isn't an override of a base class. In this case, both vtable_index 
		// and 'vtordisp' are zero, but a virtual_inheritance pointer will be generated.
		// We can generate correct code in this case. To prevent an incorrect call from
		// ever being made, on MSVC6 we generate a warning, and call a function to 
		// make the program crash instantly. 
		typedef char ERROR_VC6CompilerBug[-100];
		return 0; 
	}
};
#else 
// Nasty hack for Microsoft and Intel (IA32 and Itanium)
// unknown_inheritance classes go here 
// This is probably the ugliest bit of code I've ever written. Look at the casts!
// There is a compiler bug in MSVC6 which prevents it from using this code.
template <>
struct SimplifyMemFunc<SINGLE_MEMFUNCPTR_SIZE + 3*sizeof(int) >
{
	template <class X, class XFuncType, class GenericMemFuncType>
	inline static GenericClass *Convert(X *pthis, XFuncType function_to_bind, 
			GenericMemFuncType &bound_func) {
		// The member function pointer is 16 bytes long. We can't use a normal cast, but
		// we can use a union to do the conversion.
		union {
			XFuncType func;
			// In VC++ and ICL, an unknown_inheritance member pointer 
			// is internally defined as:
			struct {
				GenericMemFuncType m_funcaddress; // points to the actual member function
				int delta;		// #bytes to be added to the 'this' pointer
				int vtordisp;		// #bytes to add to 'this' to find the vtable
				int vtable_index; // or 0 if no virtual inheritance
			} s;
		} u;
		// Check that the horrible_cast will work
		typedef int ERROR_CantUsehorrible_cast[sizeof(XFuncType)==sizeof(u.s)? 1 : -1];
		u.func = function_to_bind;
		bound_func = u.s.funcaddress;
		int virtual_delta = 0;
		if (u.s.vtable_index) { // Virtual inheritance is used
			// First, get to the vtable. 
			// It is 'vtordisp' bytes from the start of the class.
			const int * vtable = *reinterpret_cast<const int *const*>(
				reinterpret_cast<const char *>(pthis) + u.s.vtordisp );
			// 'vtable_index' tells us where in the table we should be looking.
			virtual_delta = u.s.vtordisp + *reinterpret_cast<const int *>( 
				reinterpret_cast<const char *>(vtable) + u.s.vtable_index);
		}
		// The int at 'virtual_delta' gives us the amount to add to 'this'.
        // Finally we can add the three components together. Phew!
        return reinterpret_cast<GenericClass *>(
			reinterpret_cast<char *>(pthis) + u.s.delta + virtual_delta);
	};
};
#endif // MSVC 7 and greater
#endif // MS/Intel hacks
}  // namespace detail
////////////////////////////////////////////////////////////////////////////////
//						Fast Delegates, part 2:
//
//	Define the delegate storage, and cope with static functions
//
////////////////////////////////////////////////////////////////////////////////
// DelegateMemento -- an opaque structure which can hold an arbitary delegate.
// It knows nothing about the calling convention or number of arguments used by
// the function pointed to.
// It supplies comparison operators so that it can be stored in STL collections.
// It cannot be set to anything other than null, nor invoked directly: 
//   it must be converted to a specific delegate.
// Implementation:
// There are two possible implementations: the Safe method and the Evil method.
//				DelegateMemento - Safe version
//
// This implementation is standard-compliant, but a bit tricky.
// A static function pointer is stored inside the class. 
// Here are the valid values:
// +-- Static pointer --+--pThis --+-- pMemFunc-+-- Meaning------+
// |   0				|  0       |   0        | Empty          |
// |   !=0              |(dontcare)|  Invoker   | Static function|
// |   0                |  !=0     |  !=0*      | Method call    |
// +--------------------+----------+------------+----------------+
//  * For Metrowerks, this can be 0. (first virtual function in a 
//       single_inheritance class).
// When stored stored inside a specific delegate, the 'dontcare' entries are replaced
// with a reference to the delegate itself. This complicates the = and == operators
// for the delegate class.
//				DelegateMemento - Evil version
//
// For compilers where data pointers are at least as big as code pointers, it is 
// possible to store the function pointer in the this pointer, using another 
// horrible_cast. In this case the DelegateMemento implementation is simple:
// +--pThis --+-- pMemFunc-+-- Meaning---------------------+
// |    0     |  0         | Empty                         |
// |  !=0     |  !=0*      | Static function or method call|
// +----------+------------+-------------------------------+
//  * For Metrowerks, this can be 0. (first virtual function in a 
//       single_inheritance class).
// Note that the Sun C++ and MSVC documentation explicitly state that they 
// support static_cast between void * and function pointers.
class DelegateMemento {
protected: 
	// the data is protected, not private, because many
	// compilers have problems with template friends.
	typedef void (detail::GenericClass::*GenericMemFuncType)(); // arbitrary MFP.
	detail::GenericClass *m_pthis;
	GenericMemFuncType m_pFunction;
#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
	typedef void (*GenericFuncPtr)(); // arbitrary code pointer
	GenericFuncPtr m_pStaticFunction;
#endif
public:
#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
	DelegateMemento() : m_pthis(0), m_pFunction(0), m_pStaticFunction(0) {};
	void clear() {
		m_pthis=0; m_pFunction=0; m_pStaticFunction=0;
	}
#else
	DelegateMemento() : m_pthis(0), m_pFunction(0) {};
	void clear() {	m_pthis=0; m_pFunction=0;	}
#endif
public:
#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
	inline bool IsEqual (const DelegateMemento &x) const{
	    // We have to cope with the static function pointers as a special case
		if (m_pFunction!=x.m_pFunction) return false;
		// the static function ptrs must either both be equal, or both be 0.
		if (m_pStaticFunction!=x.m_pStaticFunction) return false;
		if (m_pStaticFunction!=0) return m_pthis==x.m_pthis;
		else return true;
	}
#else // Evil Method
	inline bool IsEqual (const DelegateMemento &x) const{
		return m_pthis==x.m_pthis && m_pFunction==x.m_pFunction;
	}
#endif
	// Provide a strict weak ordering for DelegateMementos.
	inline bool IsLess(const DelegateMemento &right) const {
		// deal with static function pointers first
#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
		if (m_pStaticFunction !=0 || right.m_pStaticFunction!=0) 
				return m_pStaticFunction < right.m_pStaticFunction;
#endif
		if (m_pthis !=right.m_pthis) return m_pthis < right.m_pthis;
	// There are no ordering operators for member function pointers, 
	// but we can fake one by comparing each byte. The resulting ordering is
	// arbitrary (and compiler-dependent), but it permits storage in ordered STL containers.
		return memcmp(&m_pFunction, &right.m_pFunction, sizeof(m_pFunction)) < 0;
	}
	// BUGFIX (Mar 2005):
	// We can't just compare m_pFunction because on Metrowerks,
	// m_pFunction can be zero even if the delegate is not empty!
	inline bool operator ! () const		// Is it bound to anything?
	{ return m_pthis==0 && m_pFunction==0; }
	inline bool empty() const		// Is it bound to anything?
	{ return m_pthis==0 && m_pFunction==0; }
public:
	DelegateMemento & operator = (const DelegateMemento &right)  {
		SetMementoFrom(right); 
		return *this;
	}
	inline bool operator <(const DelegateMemento &right) {
		return IsLess(right);
	}
	inline bool operator >(const DelegateMemento &right) {
		return right.IsLess(*this);
	}
	DelegateMemento (const DelegateMemento &right)  : 
		m_pFunction(right.m_pFunction), m_pthis(right.m_pthis)
#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
		, m_pStaticFunction (right.m_pStaticFunction)
#endif
		{}
protected:
	void SetMementoFrom(const DelegateMemento &right)  {
		m_pFunction = right.m_pFunction;
		m_pthis = right.m_pthis;
#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
		m_pStaticFunction = right.m_pStaticFunction;
#endif
	}
};
//						ClosurePtr<>
//
// A private wrapper class that adds function signatures to DelegateMemento.
// It's the class that does most of the actual work.
// The signatures are specified by:
// GenericMemFunc: must be a type of GenericClass member function pointer. 
// StaticFuncPtr:  must be a type of function pointer with the same signature 
//                 as GenericMemFunc.
// UnvoidStaticFuncPtr: is the same as StaticFuncPtr, except on VC6
//                 where it never returns void (returns DefaultVoid instead).
// An outer class, FastDelegateN<>, handles the invoking and creates the
// necessary typedefs.
// This class does everything else.
namespace detail {
template < class GenericMemFunc, class StaticFuncPtr, class UnvoidStaticFuncPtr>
class ClosurePtr : public DelegateMemento {
public:
	// These functions are for setting the delegate to a member function.
	// Here's the clever bit: we convert an arbitrary member function into a 
	// standard form. XMemFunc should be a member function of class X, but I can't 
	// enforce that here. It needs to be enforced by the wrapper class.
	template < class X, class XMemFunc >
	inline void bindmemfunc(X *pthis, XMemFunc function_to_bind ) {
		m_pthis = SimplifyMemFunc< sizeof(function_to_bind) >
			::Convert(pthis, function_to_bind, m_pFunction);
#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
		m_pStaticFunction = 0;
#endif
	}
	// For const member functions, we only need a const class pointer.
	// Since we know that the member function is const, it's safe to 
	// remove the const qualifier from the 'this' pointer with a const_cast.
	// VC6 has problems if we just overload 'bindmemfunc', so we give it a different name.
	template < class X, class XMemFunc>
	inline void bindconstmemfunc(const X *pthis, XMemFunc function_to_bind) {
		m_pthis= SimplifyMemFunc< sizeof(function_to_bind) >
			::Convert(const_cast<X*>(pthis), function_to_bind, m_pFunction);
#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
		m_pStaticFunction = 0;
#endif
	}
#ifdef FASTDELEGATE_GCC_BUG_8271	// At present, GCC doesn't recognize constness of MFPs in templates
	template < class X, class XMemFunc>
	inline void bindmemfunc(const X *pthis, XMemFunc function_to_bind) {
		bindconstmemfunc(pthis, function_to_bind);
#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
		m_pStaticFunction = 0;
#endif
	}
#endif
	// These functions are required for invoking the stored function
	inline GenericClass *GetClosureThis() const { return m_pthis; }
	inline GenericMemFunc GetClosureMemPtr() const { return reinterpret_cast<GenericMemFunc>(m_pFunction); }
// There are a few ways of dealing with static function pointers.
// There's a standard-compliant, but tricky method.
// There's also a straightforward hack, that won't work on DOS compilers using the
// medium memory model. It's so evil that I can't recommend it, but I've
// implemented it anyway because it produces very nice asm code.
#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
//				ClosurePtr<> - Safe version
//
// This implementation is standard-compliant, but a bit tricky.
// I store the function pointer inside the class, and the delegate then
// points to itself. Whenever the delegate is copied, these self-references
// must be transformed, and this complicates the = and == operators.
public:
	// The next two functions are for operator ==, =, and the copy constructor.
	// We may need to convert the m_pthis pointers, so that
	// they remain as self-references.
	template< class DerivedClass >
	inline void CopyFrom (DerivedClass *pParent, const DelegateMemento &x) {
		SetMementoFrom(x);
		if (m_pStaticFunction!=0) {
			// transform self references...
			m_pthis=reinterpret_cast<GenericClass *>(pParent);
		}
	}
	// For static functions, the 'static_function_invoker' class in the parent 
	// will be called. The parent then needs to call GetStaticFunction() to find out 
	// the actual function to invoke.
	template < class DerivedClass, class ParentInvokerSig >
	inline void bindstaticfunc(DerivedClass *pParent, ParentInvokerSig static_function_invoker, 
				StaticFuncPtr function_to_bind ) {
		if (function_to_bind==0) { // cope with assignment to 0
			m_pFunction=0;
		} else { 
			bindmemfunc(pParent, static_function_invoker);
        }
		m_pStaticFunction=reinterpret_cast<GenericFuncPtr>(function_to_bind);
	}
	inline UnvoidStaticFuncPtr GetStaticFunction() const { 
		return reinterpret_cast<UnvoidStaticFuncPtr>(m_pStaticFunction); 
	}
#else
//				ClosurePtr<> - Evil version
//
// For compilers where data pointers are at least as big as code pointers, it is 
// possible to store the function pointer in the this pointer, using another 
// horrible_cast. Invocation isn't any faster, but it saves 4 bytes, and
// speeds up comparison and assignment. If C++ provided direct language support
// for delegates, they would produce asm code that was almost identical to this.
// Note that the Sun C++ and MSVC documentation explicitly state that they 
// support static_cast between void * and function pointers.
	template< class DerivedClass >
	inline void CopyFrom (DerivedClass *pParent, const DelegateMemento &right) {
		SetMementoFrom(right);
	}
	// For static functions, the 'static_function_invoker' class in the parent 
	// will be called. The parent then needs to call GetStaticFunction() to find out 
	// the actual function to invoke.
	// ******** EVIL, EVIL CODE! *******
	template < 	class DerivedClass, class ParentInvokerSig>
	inline void bindstaticfunc(DerivedClass *pParent, ParentInvokerSig static_function_invoker, 
				StaticFuncPtr function_to_bind) {
		if (function_to_bind==0) { // cope with assignment to 0
			m_pFunction=0;
		} else { 
		   // We'll be ignoring the 'this' pointer, but we need to make sure we pass
		   // a valid value to bindmemfunc().
			bindmemfunc(pParent, static_function_invoker);
        }
		// WARNING! Evil hack. We store the function in the 'this' pointer!
		// Ensure that there's a compilation failure if function pointers 
		// and data pointers have different sizes.
		// If you get this error, you need to #undef FASTDELEGATE_USESTATICFUNCTIONHACK.
		typedef int ERROR_CantUseEvilMethod[sizeof(GenericClass *)==sizeof(function_to_bind) ? 1 : -1];
		m_pthis = horrible_cast<GenericClass *>(function_to_bind);
		// MSVC, SunC++ and DMC accept the following (non-standard) code:
//		m_pthis = static_cast<GenericClass *>(static_cast<void *>(function_to_bind));
		// BCC32, Comeau and DMC accept this method. MSVC7.1 needs __int64 instead of long
//		m_pthis = reinterpret_cast<GenericClass *>(reinterpret_cast<long>(function_to_bind));
	}
	// ******** EVIL, EVIL CODE! *******
	// This function will be called with an invalid 'this' pointer!!
	// We're just returning the 'this' pointer, converted into
	// a function pointer!
	inline UnvoidStaticFuncPtr GetStaticFunction() const {
		// Ensure that there's a compilation failure if function pointers 
		// and data pointers have different sizes.
		// If you get this error, you need to #undef FASTDELEGATE_USESTATICFUNCTIONHACK.
		typedef int ERROR_CantUseEvilMethod[sizeof(UnvoidStaticFuncPtr)==sizeof(this) ? 1 : -1];
		return horrible_cast<UnvoidStaticFuncPtr>(this);
	}
#endif // !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
	// Does the closure contain this static function?
	inline bool IsEqualToStaticFuncPtr(StaticFuncPtr funcptr){
		if (funcptr==0) return empty(); 
	// For the Evil method, if it doesn't actually contain a static function, this will return an arbitrary
	// value that is not equal to any valid function pointer.
		else return funcptr==reinterpret_cast<StaticFuncPtr>(GetStaticFunction());
	}
};
} // namespace detail
////////////////////////////////////////////////////////////////////////////////
//						Fast Delegates, part 3:
//
//				Wrapper classes to ensure type safety
//
////////////////////////////////////////////////////////////////////////////////
// Once we have the member function conversion templates, it's easy to make the
// wrapper classes. So that they will work with as many compilers as possible, 
// the classes are of the form
//   FastDelegate3<int, char *, double>
// They can cope with any combination of parameters. The max number of parameters
// allowed is 8, but it is trivial to increase this limit.
// Note that we need to treat const member functions seperately.
// All this class does is to enforce type safety, and invoke the delegate with
// the correct list of parameters.
// Because of the weird rule about the class of derived member function pointers,
// you sometimes need to apply a downcast to the 'this' pointer.
// This is the reason for the use of "implicit_cast<X*>(pthis)" in the code below. 
// If CDerivedClass is derived from CBaseClass, but doesn't override SimpleVirtualFunction,
// without this trick you'd need to write:
//		MyDelegate(static_cast<CBaseClass *>(&d), &CDerivedClass::SimpleVirtualFunction);
// but with the trick you can write
//		MyDelegate(&d, &CDerivedClass::SimpleVirtualFunction);
// RetType is the type the compiler uses in compiling the template. For VC6,
// it cannot be void. DesiredRetType is the real type which is returned from
// all of the functions. It can be void.
// Implicit conversion to "bool" is achieved using the safe_bool idiom,
// using member data pointers (MDP). This allows "if (dg)..." syntax
// Because some compilers (eg codeplay) don't have a unique value for a zero
// MDP, an extra padding member is added to the SafeBool struct.
// Some compilers (eg VC6) won't implicitly convert from 0 to an MDP, so
// in that case the static function constructor is not made explicit; this
// allows "if (dg==0) ..." to compile.
//N=0
template<class RetType=detail::DefaultVoid>
class FastDelegate0 {
private:
	typedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;
	typedef DesiredRetType (*StaticFunctionPtr)();
	typedef RetType (*UnvoidStaticFunctionPtr)();
	typedef RetType (detail::GenericClass::*GenericMemFn)();
	typedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
	ClosureType m_Closure;
public:
	// Typedefs to aid generic programming
	typedef FastDelegate0 type;
	// Construction and comparison functions
	FastDelegate0() { clear(); }
	FastDelegate0(const FastDelegate0 &x) {
		m_Closure.CopyFrom(this, x.m_Closure); }
	void operator = (const FastDelegate0 &x)  {
		m_Closure.CopyFrom(this, x.m_Closure); }
	bool operator ==(const FastDelegate0 &x) const {
		return m_Closure.IsEqual(x.m_Closure);	}
	bool operator !=(const FastDelegate0 &x) const {
		return !m_Closure.IsEqual(x.m_Closure); }
	bool operator <(const FastDelegate0 &x) const {
		return m_Closure.IsLess(x.m_Closure);	}
	bool operator >(const FastDelegate0 &x) const {
		return x.m_Closure.IsLess(m_Closure);	}
	// Binding to non-const member functions
	template < class X, class Y >
	FastDelegate0(Y *pthis, DesiredRetType (X::* function_to_bind)() ) {
		m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }
	template < class X, class Y >
	inline void bind(Y *pthis, DesiredRetType (X::* function_to_bind)()) {
		m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);	}
	// Binding to const member functions.
	template < class X, class Y >
	FastDelegate0(const Y *pthis, DesiredRetType (X::* function_to_bind)() const) {
		m_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind);	}
	template < class X, class Y >
	inline void bind(const Y *pthis, DesiredRetType (X::* function_to_bind)() const) {
		m_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind);	}
	// Static functions. We convert them into a member function call.
	// This constructor also provides implicit conversion
	FastDelegate0(DesiredRetType (*function_to_bind)() ) {
		bind(function_to_bind);	}
	// for efficiency, prevent creation of a temporary
	void operator = (DesiredRetType (*function_to_bind)() ) {
		bind(function_to_bind);	}
	inline void bind(DesiredRetType (*function_to_bind)()) {
		m_Closure.bindstaticfunc(this, &FastDelegate0::InvokeStaticFunction, 
			function_to_bind); }
	// Invoke the delegate
	RetType operator() () const {
	return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(); }
	// Implicit conversion to "bool" using the safe_bool idiom
private:
	typedef struct SafeBoolStruct {
		int a_data_pointer_to_this_is_0_on_buggy_compilers;
		StaticFunctionPtr m_nonzero;
	} UselessTypedef;
    typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
public:
	operator unspecified_bool_type() const {
        return empty()? 0: &SafeBoolStruct::m_nonzero;
    }
	// necessary to allow ==0 to work despite the safe_bool idiom
	inline bool operator==(StaticFunctionPtr funcptr) {
		return m_Closure.IsEqualToStaticFuncPtr(funcptr);	}
	inline bool operator!=(StaticFunctionPtr funcptr) { 
		return !m_Closure.IsEqualToStaticFuncPtr(funcptr);    }
	inline bool operator ! () const	{	// Is it bound to anything?
			return !m_Closure; }
	inline bool empty() const	{
			return !m_Closure; }
	void clear() { m_Closure.clear();}
	// Conversion to and from the DelegateMemento storage class
	const DelegateMemento & GetMemento() { return m_Closure; }
	void SetMemento(const DelegateMemento &any) { m_Closure.CopyFrom(this, any); }
private:	// Invoker for static functions
	RetType InvokeStaticFunction() const {
	return (*(m_Closure.GetStaticFunction()))(); }
};
//N=1
template<class Param1, class RetType=detail::DefaultVoid>
class FastDelegate1 {
private:
	typedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;
	typedef DesiredRetType (*StaticFunctionPtr)(Param1 p1);
	typedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1);
	typedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1);
	typedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
	ClosureType m_Closure;
public:
	// Typedefs to aid generic programming
	typedef FastDelegate1 type;
	// Construction and comparison functions
	FastDelegate1() { clear(); }
	FastDelegate1(const FastDelegate1 &x) {
		m_Closure.CopyFrom(this, x.m_Closure); }
	void operator = (const FastDelegate1 &x)  {
		m_Closure.CopyFrom(this, x.m_Closure); }
	bool operator ==(const FastDelegate1 &x) const {
		return m_Closure.IsEqual(x.m_Closure);	}
	bool operator !=(const FastDelegate1 &x) const {
		return !m_Closure.IsEqual(x.m_Closure); }
	bool operator <(const FastDelegate1 &x) const {
		return m_Closure.IsLess(x.m_Closure);	}
	bool operator >(const FastDelegate1 &x) const {
		return x.m_Closure.IsLess(m_Closure);	}
	// Binding to non-const member functions
	template < class X, class Y >
	FastDelegate1(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1) ) {
		m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }
	template < class X, class Y >
	inline void bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1)) {
		m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);	}
	// Binding to const member functions.
	template < class X, class Y >
	FastDelegate1(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1) const) {
		m_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind);	}
	template < class X, class Y >
	inline void bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1) const) {
		m_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind);	}
	// Static functions. We convert them into a member function call.
	// This constructor also provides implicit conversion
	FastDelegate1(DesiredRetType (*function_to_bind)(Param1 p1) ) {
		bind(function_to_bind);	}
	// for efficiency, prevent creation of a temporary
	void operator = (DesiredRetType (*function_to_bind)(Param1 p1) ) {
		bind(function_to_bind);	}
	inline void bind(DesiredRetType (*function_to_bind)(Param1 p1)) {
		m_Closure.bindstaticfunc(this, &FastDelegate1::InvokeStaticFunction, 
			function_to_bind); }
	// Invoke the delegate
	RetType operator() (Param1 p1) const {
	return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1); }
	// Implicit conversion to "bool" using the safe_bool idiom
private:
	typedef struct SafeBoolStruct {
		int a_data_pointer_to_this_is_0_on_buggy_compilers;
		StaticFunctionPtr m_nonzero;
	} UselessTypedef;
    typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
public:
	operator unspecified_bool_type() const {
        return empty()? 0: &SafeBoolStruct::m_nonzero;
    }
	// necessary to allow ==0 to work despite the safe_bool idiom
	inline bool operator==(StaticFunctionPtr funcptr) {
		return m_Closure.IsEqualToStaticFuncPtr(funcptr);	}
	inline bool operator!=(StaticFunctionPtr funcptr) { 
		return !m_Closure.IsEqualToStaticFuncPtr(funcptr);    }
	inline bool operator ! () const	{	// Is it bound to anything?
			return !m_Closure; }
	inline bool empty() const	{
			return !m_Closure; }
	void clear() { m_Closure.clear();}
	// Conversion to and from the DelegateMemento storage class
	const DelegateMemento & GetMemento() { return m_Closure; }
	void SetMemento(const DelegateMemento &any) { m_Closure.CopyFrom(this, any); }
private:	// Invoker for static functions
	RetType InvokeStaticFunction(Param1 p1) const {
	return (*(m_Closure.GetStaticFunction()))(p1); }
};
//N=2
template<class Param1, class Param2, class RetType=detail::DefaultVoid>
class FastDelegate2 {
private:
	typedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;
	typedef DesiredRetType (*StaticFunctionPtr)(Param1 p1, Param2 p2);
	typedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2);
	typedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2);
	typedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
	ClosureType m_Closure;
public:
	// Typedefs to aid generic programming
	typedef FastDelegate2 type;
	// Construction and comparison functions
	FastDelegate2() { clear(); }
	FastDelegate2(const FastDelegate2 &x) {
		m_Closure.CopyFrom(this, x.m_Closure); }
	void operator = (const FastDelegate2 &x)  {
		m_Closure.CopyFrom(this, x.m_Closure); }
	bool operator ==(const FastDelegate2 &x) const {
		return m_Closure.IsEqual(x.m_Closure);	}
	bool operator !=(const FastDelegate2 &x) const {
		return !m_Closure.IsEqual(x.m_Closure); }
	bool operator <(const FastDelegate2 &x) const {
		return m_Closure.IsLess(x.m_Closure);	}
	bool operator >(const FastDelegate2 &x) const {
		return x.m_Closure.IsLess(m_Closure);	}
	// Binding to non-const member functions
	template < class X, class Y >
	FastDelegate2(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2) ) {
		m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }
	template < class X, class Y >
	inline void bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2)) {
		m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);	}
	// Binding to const member functions.
	template < class X, class Y >
	FastDelegate2(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2) const) {
		m_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind);	}
	template < class X, class Y >
	inline void bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2) const) {
		m_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind);	}
	// Static functions. We convert them into a member function call.
	// This constructor also provides implicit conversion
	FastDelegate2(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2) ) {
		bind(function_to_bind);	}
	// for efficiency, prevent creation of a temporary
	void operator = (DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2) ) {
		bind(function_to_bind);	}
	inline void bind(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2)) {
		m_Closure.bindstaticfunc(this, &FastDelegate2::InvokeStaticFunction, 
			function_to_bind); }
	// Invoke the delegate
	RetType operator() (Param1 p1, Param2 p2) const {
	return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2); }
	// Implicit conversion to "bool" using the safe_bool idiom
private:
	typedef struct SafeBoolStruct {
		int a_data_pointer_to_this_is_0_on_buggy_compilers;
		StaticFunctionPtr m_nonzero;
	} UselessTypedef;
    typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
public:
	operator unspecified_bool_type() const {
        return empty()? 0: &SafeBoolStruct::m_nonzero;
    }
	// necessary to allow ==0 to work despite the safe_bool idiom
	inline bool operator==(StaticFunctionPtr funcptr) {
		return m_Closure.IsEqualToStaticFuncPtr(funcptr);	}
	inline bool operator!=(StaticFunctionPtr funcptr) { 
		return !m_Closure.IsEqualToStaticFuncPtr(funcptr);    }
	inline bool operator ! () const	{	// Is it bound to anything?
			return !m_Closure; }
	inline bool empty() const	{
			return !m_Closure; }
	void clear() { m_Closure.clear();}
	// Conversion to and from the DelegateMemento storage class
	const DelegateMemento & GetMemento() { return m_Closure; }
	void SetMemento(const DelegateMemento &any) { m_Closure.CopyFrom(this, any); }
private:	// Invoker for static functions
	RetType InvokeStaticFunction(Param1 p1, Param2 p2) const {
	return (*(m_Closure.GetStaticFunction()))(p1, p2); }
};
//N=3
template<class Param1, class Param2, class Param3, class RetType=detail::DefaultVoid>
class FastDelegate3 {
private:
	typedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;
	typedef DesiredRetType (*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3);
	typedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3);
	typedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3);
	typedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
	ClosureType m_Closure;
public:
	// Typedefs to aid generic programming
	typedef FastDelegate3 type;
	// Construction and comparison functions
	FastDelegate3() { clear(); }
	FastDelegate3(const FastDelegate3 &x) {
		m_Closure.CopyFrom(this, x.m_Closure); }
	void operator = (const FastDelegate3 &x)  {
		m_Closure.CopyFrom(this, x.m_Closure); }
	bool operator ==(const FastDelegate3 &x) const {
		return m_Closure.IsEqual(x.m_Closure);	}
	bool operator !=(const FastDelegate3 &x) const {
		return !m_Closure.IsEqual(x.m_Closure); }
	bool operator <(const FastDelegate3 &x) const {
		return m_Closure.IsLess(x.m_Closure);	}
	bool operator >(const FastDelegate3 &x) const {
		return x.m_Closure.IsLess(m_Closure);	}
	// Binding to non-const member functions
	template < class X, class Y >
	FastDelegate3(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3) ) {
		m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }
	template < class X, class Y >
	inline void bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3)) {
		m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);	}
	// Binding to const member functions.
	template < class X, class Y >
	FastDelegate3(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3) const) {
		m_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind);	}
	template < class X, class Y >
	inline void bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3) const) {
		m_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind);	}
	// Static functions. We convert them into a member function call.
	// This constructor also provides implicit conversion
	FastDelegate3(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3) ) {
		bind(function_to_bind);	}
	// for efficiency, prevent creation of a temporary
	void operator = (DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3) ) {
		bind(function_to_bind);	}
	inline void bind(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3)) {
		m_Closure.bindstaticfunc(this, &FastDelegate3::InvokeStaticFunction, 
			function_to_bind); }
	// Invoke the delegate
	RetType operator() (Param1 p1, Param2 p2, Param3 p3) const {
	return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2, p3); }
	// Implicit conversion to "bool" using the safe_bool idiom
private:
	typedef struct SafeBoolStruct {
		int a_data_pointer_to_this_is_0_on_buggy_compilers;
		StaticFunctionPtr m_nonzero;
	} UselessTypedef;
    typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
public:
	operator unspecified_bool_type() const {
        return empty()? 0: &SafeBoolStruct::m_nonzero;
    }
	// necessary to allow ==0 to work despite the safe_bool idiom
	inline bool operator==(StaticFunctionPtr funcptr) {
		return m_Closure.IsEqualToStaticFuncPtr(funcptr);	}
	inline bool operator!=(StaticFunctionPtr funcptr) { 
		return !m_Closure.IsEqualToStaticFuncPtr(funcptr);    }
	inline bool operator ! () const	{	// Is it bound to anything?
			return !m_Closure; }
	inline bool empty() const	{
			return !m_Closure; }
	void clear() { m_Closure.clear();}
	// Conversion to and from the DelegateMemento storage class
	const DelegateMemento & GetMemento() { return m_Closure; }
	void SetMemento(const DelegateMemento &any) { m_Closure.CopyFrom(this, any); }
private:	// Invoker for static functions
	RetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3) const {
	return (*(m_Closure.GetStaticFunction()))(p1, p2, p3); }
};
//N=4
template<class Param1, class Param2, class Param3, class Param4, class RetType=detail::DefaultVoid>
class FastDelegate4 {
private:
	typedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;
	typedef DesiredRetType (*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4);
	typedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4);
	typedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4);
	typedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
	ClosureType m_Closure;
public:
	// Typedefs to aid generic programming
	typedef FastDelegate4 type;
	// Construction and comparison functions
	FastDelegate4() { clear(); }
	FastDelegate4(const FastDelegate4 &x) {
		m_Closure.CopyFrom(this, x.m_Closure); }
	void operator = (const FastDelegate4 &x)  {
		m_Closure.CopyFrom(this, x.m_Closure); }
	bool operator ==(const FastDelegate4 &x) const {
		return m_Closure.IsEqual(x.m_Closure);	}
	bool operator !=(const FastDelegate4 &x) const {
		return !m_Closure.IsEqual(x.m_Closure); }
	bool operator <(const FastDelegate4 &x) const {
		return m_Closure.IsLess(x.m_Closure);	}
	bool operator >(const FastDelegate4 &x) const {
		return x.m_Closure.IsLess(m_Closure);	}
	// Binding to non-const member functions
	template < class X, class Y >
	FastDelegate4(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4) ) {
		m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }
	template < class X, class Y >
	inline void bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4)) {
		m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);	}
	// Binding to const member functions.
	template < class X, class Y >
	FastDelegate4(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4) const) {
		m_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind);	}
	template < class X, class Y >
	inline void bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4) const) {
		m_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind);	}
	// Static functions. We convert them into a member function call.
	// This constructor also provides implicit conversion
	FastDelegate4(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4) ) {
		bind(function_to_bind);	}
	// for efficiency, prevent creation of a temporary
	void operator = (DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4) ) {
		bind(function_to_bind);	}
	inline void bind(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4)) {
		m_Closure.bindstaticfunc(this, &FastDelegate4::InvokeStaticFunction, 
			function_to_bind); }
	// Invoke the delegate
	RetType operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4) const {
	return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4); }
	// Implicit conversion to "bool" using the safe_bool idiom
private:
	typedef struct SafeBoolStruct {
		int a_data_pointer_to_this_is_0_on_buggy_compilers;
		StaticFunctionPtr m_nonzero;
	} UselessTypedef;
    typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
public:
	operator unspecified_bool_type() const {
        return empty()? 0: &SafeBoolStruct::m_nonzero;
    }
	// necessary to allow ==0 to work despite the safe_bool idiom
	inline bool operator==(StaticFunctionPtr funcptr) {
		return m_Closure.IsEqualToStaticFuncPtr(funcptr);	}
	inline bool operator!=(StaticFunctionPtr funcptr) { 
		return !m_Closure.IsEqualToStaticFuncPtr(funcptr);    }
	inline bool operator ! () const	{	// Is it bound to anything?
			return !m_Closure; }
	inline bool empty() const	{
			return !m_Closure; }
	void clear() { m_Closure.clear();}
	// Conversion to and from the DelegateMemento storage class
	const DelegateMemento & GetMemento() { return m_Closure; }
	void SetMemento(const DelegateMemento &any) { m_Closure.CopyFrom(this, any); }
private:	// Invoker for static functions
	RetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4) const {
	return (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4); }
};
//N=5
template<class Param1, class Param2, class Param3, class Param4, class Param5, class RetType=detail::DefaultVoid>
class FastDelegate5 {
private:
	typedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;
	typedef DesiredRetType (*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5);
	typedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5);
	typedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5);
	typedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
	ClosureType m_Closure;
public:
	// Typedefs to aid generic programming
	typedef FastDelegate5 type;
	// Construction and comparison functions
	FastDelegate5() { clear(); }
	FastDelegate5(const FastDelegate5 &x) {
		m_Closure.CopyFrom(this, x.m_Closure); }
	void operator = (const FastDelegate5 &x)  {
		m_Closure.CopyFrom(this, x.m_Closure); }
	bool operator ==(const FastDelegate5 &x) const {
		return m_Closure.IsEqual(x.m_Closure);	}
	bool operator !=(const FastDelegate5 &x) const {
		return !m_Closure.IsEqual(x.m_Closure); }
	bool operator <(const FastDelegate5 &x) const {
		return m_Closure.IsLess(x.m_Closure);	}
	bool operator >(const FastDelegate5 &x) const {
		return x.m_Closure.IsLess(m_Closure);	}
	// Binding to non-const member functions
	template < class X, class Y >
	FastDelegate5(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) ) {
		m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }
	template < class X, class Y >
	inline void bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5)) {
		m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);	}
	// Binding to const member functions.
	template < class X, class Y >
	FastDelegate5(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const) {
		m_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind);	}
	template < class X, class Y >
	inline void bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const) {
		m_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind);	}
	// Static functions. We convert them into a member function call.
	// This constructor also provides implicit conversion
	FastDelegate5(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) ) {
		bind(function_to_bind);	}
	// for efficiency, prevent creation of a temporary
	void operator = (DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) ) {
		bind(function_to_bind);	}
	inline void bind(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5)) {
		m_Closure.bindstaticfunc(this, &FastDelegate5::InvokeStaticFunction, 
			function_to_bind); }
	// Invoke the delegate
	RetType operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const {
	return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4, p5); }
	// Implicit conversion to "bool" using the safe_bool idiom
private:
	typedef struct SafeBoolStruct {
		int a_data_pointer_to_this_is_0_on_buggy_compilers;
		StaticFunctionPtr m_nonzero;
	} UselessTypedef;
    typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
public:
	operator unspecified_bool_type() const {
        return empty()? 0: &SafeBoolStruct::m_nonzero;
    }
	// necessary to allow ==0 to work despite the safe_bool idiom
	inline bool operator==(StaticFunctionPtr funcptr) {
		return m_Closure.IsEqualToStaticFuncPtr(funcptr);	}
	inline bool operator!=(StaticFunctionPtr funcptr) { 
		return !m_Closure.IsEqualToStaticFuncPtr(funcptr);    }
	inline bool operator ! () const	{	// Is it bound to anything?
			return !m_Closure; }
	inline bool empty() const	{
			return !m_Closure; }
	void clear() { m_Closure.clear();}
	// Conversion to and from the DelegateMemento storage class
	const DelegateMemento & GetMemento() { return m_Closure; }
	void SetMemento(const DelegateMemento &any) { m_Closure.CopyFrom(this, any); }
private:	// Invoker for static functions
	RetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const {
	return (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4, p5); }
};
//N=6
template<class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class RetType=detail::DefaultVoid>
class FastDelegate6 {
private:
	typedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;
	typedef DesiredRetType (*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6);
	typedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6);
	typedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6);
	typedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
	ClosureType m_Closure;
public:
	// Typedefs to aid generic programming
	typedef FastDelegate6 type;
	// Construction and comparison functions
	FastDelegate6() { clear(); }
	FastDelegate6(const FastDelegate6 &x) {
		m_Closure.CopyFrom(this, x.m_Closure); }
	void operator = (const FastDelegate6 &x)  {
		m_Closure.CopyFrom(this, x.m_Closure); }
	bool operator ==(const FastDelegate6 &x) const {
		return m_Closure.IsEqual(x.m_Closure);	}
	bool operator !=(const FastDelegate6 &x) const {
		return !m_Closure.IsEqual(x.m_Closure); }
	bool operator <(const FastDelegate6 &x) const {
		return m_Closure.IsLess(x.m_Closure);	}
	bool operator >(const FastDelegate6 &x) const {
		return x.m_Closure.IsLess(m_Closure);	}
	// Binding to non-const member functions
	template < class X, class Y >
	FastDelegate6(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) ) {
		m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }
	template < class X, class Y >
	inline void bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6)) {
		m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);	}
	// Binding to const member functions.
	template < class X, class Y >
	FastDelegate6(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const) {
		m_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind);	}
	template < class X, class Y >
	inline void bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const) {
		m_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind);	}
	// Static functions. We convert them into a member function call.
	// This constructor also provides implicit conversion
	FastDelegate6(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) ) {
		bind(function_to_bind);	}
	// for efficiency, prevent creation of a temporary
	void operator = (DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) ) {
		bind(function_to_bind);	}
	inline void bind(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6)) {
		m_Closure.bindstaticfunc(this, &FastDelegate6::InvokeStaticFunction, 
			function_to_bind); }
	// Invoke the delegate
	RetType operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const {
	return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4, p5, p6); }
	// Implicit conversion to "bool" using the safe_bool idiom
private:
	typedef struct SafeBoolStruct {
		int a_data_pointer_to_this_is_0_on_buggy_compilers;
		StaticFunctionPtr m_nonzero;
	} UselessTypedef;
    typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
public:
	operator unspecified_bool_type() const {
        return empty()? 0: &SafeBoolStruct::m_nonzero;
    }
	// necessary to allow ==0 to work despite the safe_bool idiom
	inline bool operator==(StaticFunctionPtr funcptr) {
		return m_Closure.IsEqualToStaticFuncPtr(funcptr);	}
	inline bool operator!=(StaticFunctionPtr funcptr) { 
		return !m_Closure.IsEqualToStaticFuncPtr(funcptr);    }
	inline bool operator ! () const	{	// Is it bound to anything?
			return !m_Closure; }
	inline bool empty() const	{
			return !m_Closure; }
	void clear() { m_Closure.clear();}
	// Conversion to and from the DelegateMemento storage class
	const DelegateMemento & GetMemento() { return m_Closure; }
	void SetMemento(const DelegateMemento &any) { m_Closure.CopyFrom(this, any); }
private:	// Invoker for static functions
	RetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const {
	return (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4, p5, p6); }
};
//N=7
template<class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class RetType=detail::DefaultVoid>
class FastDelegate7 {
private:
	typedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;
	typedef DesiredRetType (*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7);
	typedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7);
	typedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7);
	typedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
	ClosureType m_Closure;
public:
	// Typedefs to aid generic programming
	typedef FastDelegate7 type;
	// Construction and comparison functions
	FastDelegate7() { clear(); }
	FastDelegate7(const FastDelegate7 &x) {
		m_Closure.CopyFrom(this, x.m_Closure); }
	void operator = (const FastDelegate7 &x)  {
		m_Closure.CopyFrom(this, x.m_Closure); }
	bool operator ==(const FastDelegate7 &x) const {
		return m_Closure.IsEqual(x.m_Closure);	}
	bool operator !=(const FastDelegate7 &x) const {
		return !m_Closure.IsEqual(x.m_Closure); }
	bool operator <(const FastDelegate7 &x) const {
		return m_Closure.IsLess(x.m_Closure);	}
	bool operator >(const FastDelegate7 &x) const {
		return x.m_Closure.IsLess(m_Closure);	}
	// Binding to non-const member functions
	template < class X, class Y >
	FastDelegate7(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) ) {
		m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }
	template < class X, class Y >
	inline void bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7)) {
		m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);	}
	// Binding to const member functions.
	template < class X, class Y >
	FastDelegate7(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const) {
		m_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind);	}
	template < class X, class Y >
	inline void bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const) {
		m_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind);	}
	// Static functions. We convert them into a member function call.
	// This constructor also provides implicit conversion
	FastDelegate7(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) ) {
		bind(function_to_bind);	}
	// for efficiency, prevent creation of a temporary
	void operator = (DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) ) {
		bind(function_to_bind);	}
	inline void bind(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7)) {
		m_Closure.bindstaticfunc(this, &FastDelegate7::InvokeStaticFunction, 
			function_to_bind); }
	// Invoke the delegate
	RetType operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const {
	return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4, p5, p6, p7); }
	// Implicit conversion to "bool" using the safe_bool idiom
private:
	typedef struct SafeBoolStruct {
		int a_data_pointer_to_this_is_0_on_buggy_compilers;
		StaticFunctionPtr m_nonzero;
	} UselessTypedef;
    typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
public:
	operator unspecified_bool_type() const {
        return empty()? 0: &SafeBoolStruct::m_nonzero;
    }
	// necessary to allow ==0 to work despite the safe_bool idiom
	inline bool operator==(StaticFunctionPtr funcptr) {
		return m_Closure.IsEqualToStaticFuncPtr(funcptr);	}
	inline bool operator!=(StaticFunctionPtr funcptr) { 
		return !m_Closure.IsEqualToStaticFuncPtr(funcptr);    }
	inline bool operator ! () const	{	// Is it bound to anything?
			return !m_Closure; }
	inline bool empty() const	{
			return !m_Closure; }
	void clear() { m_Closure.clear();}
	// Conversion to and from the DelegateMemento storage class
	const DelegateMemento & GetMemento() { return m_Closure; }
	void SetMemento(const DelegateMemento &any) { m_Closure.CopyFrom(this, any); }
private:	// Invoker for static functions
	RetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const {
	return (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4, p5, p6, p7); }
};
//N=8
template<class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class RetType=detail::DefaultVoid>
class FastDelegate8 {
private:
	typedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;
	typedef DesiredRetType (*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8);
	typedef RetType (*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8);
	typedef RetType (detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8);
	typedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
	ClosureType m_Closure;
public:
	// Typedefs to aid generic programming
	typedef FastDelegate8 type;
	// Construction and comparison functions
	FastDelegate8() { clear(); }
	FastDelegate8(const FastDelegate8 &x) {
		m_Closure.CopyFrom(this, x.m_Closure); }
	void operator = (const FastDelegate8 &x)  {
		m_Closure.CopyFrom(this, x.m_Closure); }
	bool operator ==(const FastDelegate8 &x) const {
		return m_Closure.IsEqual(x.m_Closure);	}
	bool operator !=(const FastDelegate8 &x) const {
		return !m_Closure.IsEqual(x.m_Closure); }
	bool operator <(const FastDelegate8 &x) const {
		return m_Closure.IsLess(x.m_Closure);	}
	bool operator >(const FastDelegate8 &x) const {
		return x.m_Closure.IsLess(m_Closure);	}
	// Binding to non-const member functions
	template < class X, class Y >
	FastDelegate8(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) ) {
		m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind); }
	template < class X, class Y >
	inline void bind(Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8)) {
		m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);	}
	// Binding to const member functions.
	template < class X, class Y >
	FastDelegate8(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const) {
		m_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind);	}
	template < class X, class Y >
	inline void bind(const Y *pthis, DesiredRetType (X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const) {
		m_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind);	}
	// Static functions. We convert them into a member function call.
	// This constructor also provides implicit conversion
	FastDelegate8(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) ) {
		bind(function_to_bind);	}
	// for efficiency, prevent creation of a temporary
	void operator = (DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) ) {
		bind(function_to_bind);	}
	inline void bind(DesiredRetType (*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8)) {
		m_Closure.bindstaticfunc(this, &FastDelegate8::InvokeStaticFunction, 
			function_to_bind); }
	// Invoke the delegate
	RetType operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const {
	return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4, p5, p6, p7, p8); }
	// Implicit conversion to "bool" using the safe_bool idiom
private:
	typedef struct SafeBoolStruct {
		int a_data_pointer_to_this_is_0_on_buggy_compilers;
		StaticFunctionPtr m_nonzero;
	} UselessTypedef;
    typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
public:
	operator unspecified_bool_type() const {
        return empty()? 0: &SafeBoolStruct::m_nonzero;
    }
	// necessary to allow ==0 to work despite the safe_bool idiom
	inline bool operator==(StaticFunctionPtr funcptr) {
		return m_Closure.IsEqualToStaticFuncPtr(funcptr);	}
	inline bool operator!=(StaticFunctionPtr funcptr) { 
		return !m_Closure.IsEqualToStaticFuncPtr(funcptr);    }
	inline bool operator ! () const	{	// Is it bound to anything?
			return !m_Closure; }
	inline bool empty() const	{
			return !m_Closure; }
	void clear() { m_Closure.clear();}
	// Conversion to and from the DelegateMemento storage class
	const DelegateMemento & GetMemento() { return m_Closure; }
	void SetMemento(const DelegateMemento &any) { m_Closure.CopyFrom(this, any); }
private:	// Invoker for static functions
	RetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const {
	return (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4, p5, p6, p7, p8); }
};
////////////////////////////////////////////////////////////////////////////////
//						Fast Delegates, part 4:
// 
//				FastDelegate<> class (Original author: Jody Hagins)
//	Allows boost::function style syntax like:
//			FastDelegate< double (int, long) >
// instead of:
//			FastDelegate2< int, long, double >
//
////////////////////////////////////////////////////////////////////////////////
#ifdef FASTDELEGATE_ALLOW_FUNCTION_TYPE_SYNTAX
// Declare FastDelegate as a class template.  It will be specialized
// later for all number of arguments.
template <typename Signature>
class FastDelegate;
//N=0
// Specialization to allow use of
// FastDelegate< R (  ) >
// instead of 
// FastDelegate0 < R >
template<typename R>
class FastDelegate< R (  ) >
  // Inherit from FastDelegate0 so that it can be treated just like a FastDelegate0
  : public FastDelegate0 < R >
{
public:
  // Make using the base type a bit easier via typedef.
  typedef FastDelegate0 < R > BaseType;
  // Allow users access to the specific type of this delegate.
  typedef FastDelegate SelfType;
  // Mimic the base class constructors.
  FastDelegate() : BaseType() { }
  template < class X, class Y >
  FastDelegate(Y * pthis, 
    R (X::* function_to_bind)(  ))
    : BaseType(pthis, function_to_bind)  { }
  template < class X, class Y >
  FastDelegate(const Y *pthis,
      R (X::* function_to_bind)(  ) const)
    : BaseType(pthis, function_to_bind)
  {  }
  FastDelegate(R (*function_to_bind)(  ))
    : BaseType(function_to_bind)  { }
  void operator = (const BaseType &x)  {	  
		*static_cast<BaseType*>(this) = x; }
};
//N=1
// Specialization to allow use of
// FastDelegate< R ( Param1 ) >
// instead of 
// FastDelegate1 < Param1, R >
template<typename R, class Param1>
class FastDelegate< R ( Param1 ) >
  // Inherit from FastDelegate1 so that it can be treated just like a FastDelegate1
  : public FastDelegate1 < Param1, R >
{
public:
  // Make using the base type a bit easier via typedef.
  typedef FastDelegate1 < Param1, R > BaseType;
  // Allow users access to the specific type of this delegate.
  typedef FastDelegate SelfType;
  // Mimic the base class constructors.
  FastDelegate() : BaseType() { }
  template < class X, class Y >
  FastDelegate(Y * pthis, 
    R (X::* function_to_bind)( Param1 p1 ))
    : BaseType(pthis, function_to_bind)  { }
  template < class X, class Y >
  FastDelegate(const Y *pthis,
      R (X::* function_to_bind)( Param1 p1 ) const)
    : BaseType(pthis, function_to_bind)
  {  }
  FastDelegate(R (*function_to_bind)( Param1 p1 ))
    : BaseType(function_to_bind)  { }
  void operator = (const BaseType &x)  {	  
		*static_cast<BaseType*>(this) = x; }
};
//N=2
// Specialization to allow use of
// FastDelegate< R ( Param1, Param2 ) >
// instead of 
// FastDelegate2 < Param1, Param2, R >
template<typename R, class Param1, class Param2>
class FastDelegate< R ( Param1, Param2 ) >
  // Inherit from FastDelegate2 so that it can be treated just like a FastDelegate2
  : public FastDelegate2 < Param1, Param2, R >
{
public:
  // Make using the base type a bit easier via typedef.
  typedef FastDelegate2 < Param1, Param2, R > BaseType;
  // Allow users access to the specific type of this delegate.
  typedef FastDelegate SelfType;
  // Mimic the base class constructors.
  FastDelegate() : BaseType() { }
  template < class X, class Y >
  FastDelegate(Y * pthis, 
    R (X::* function_to_bind)( Param1 p1, Param2 p2 ))
    : BaseType(pthis, function_to_bind)  { }
  template < class X, class Y >
  FastDelegate(const Y *pthis,
      R (X::* function_to_bind)( Param1 p1, Param2 p2 ) const)
    : BaseType(pthis, function_to_bind)
  {  }
  FastDelegate(R (*function_to_bind)( Param1 p1, Param2 p2 ))
    : BaseType(function_to_bind)  { }
  void operator = (const BaseType &x)  {	  
		*static_cast<BaseType*>(this) = x; }
};
//N=3
// Specialization to allow use of
// FastDelegate< R ( Param1, Param2, Param3 ) >
// instead of 
// FastDelegate3 < Param1, Param2, Param3, R >
template<typename R, class Param1, class Param2, class Param3>
class FastDelegate< R ( Param1, Param2, Param3 ) >
  // Inherit from FastDelegate3 so that it can be treated just like a FastDelegate3
  : public FastDelegate3 < Param1, Param2, Param3, R >
{
public:
  // Make using the base type a bit easier via typedef.
  typedef FastDelegate3 < Param1, Param2, Param3, R > BaseType;
  // Allow users access to the specific type of this delegate.
  typedef FastDelegate SelfType;
  // Mimic the base class constructors.
  FastDelegate() : BaseType() { }
  template < class X, class Y >
  FastDelegate(Y * pthis, 
    R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3 ))
    : BaseType(pthis, function_to_bind)  { }
  template < class X, class Y >
  FastDelegate(const Y *pthis,
      R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3 ) const)
    : BaseType(pthis, function_to_bind)
  {  }
  FastDelegate(R (*function_to_bind)( Param1 p1, Param2 p2, Param3 p3 ))
    : BaseType(function_to_bind)  { }
  void operator = (const BaseType &x)  {	  
		*static_cast<BaseType*>(this) = x; }
};
//N=4
// Specialization to allow use of
// FastDelegate< R ( Param1, Param2, Param3, Param4 ) >
// instead of 
// FastDelegate4 < Param1, Param2, Param3, Param4, R >
template<typename R, class Param1, class Param2, class Param3, class Param4>
class FastDelegate< R ( Param1, Param2, Param3, Param4 ) >
  // Inherit from FastDelegate4 so that it can be treated just like a FastDelegate4
  : public FastDelegate4 < Param1, Param2, Param3, Param4, R >
{
public:
  // Make using the base type a bit easier via typedef.
  typedef FastDelegate4 < Param1, Param2, Param3, Param4, R > BaseType;
  // Allow users access to the specific type of this delegate.
  typedef FastDelegate SelfType;
  // Mimic the base class constructors.
  FastDelegate() : BaseType() { }
  template < class X, class Y >
  FastDelegate(Y * pthis, 
    R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4 ))
    : BaseType(pthis, function_to_bind)  { }
  template < class X, class Y >
  FastDelegate(const Y *pthis,
      R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4 ) const)
    : BaseType(pthis, function_to_bind)
  {  }
  FastDelegate(R (*function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4 ))
    : BaseType(function_to_bind)  { }
  void operator = (const BaseType &x)  {	  
		*static_cast<BaseType*>(this) = x; }
};
//N=5
// Specialization to allow use of
// FastDelegate< R ( Param1, Param2, Param3, Param4, Param5 ) >
// instead of 
// FastDelegate5 < Param1, Param2, Param3, Param4, Param5, R >
template<typename R, class Param1, class Param2, class Param3, class Param4, class Param5>
class FastDelegate< R ( Param1, Param2, Param3, Param4, Param5 ) >
  // Inherit from FastDelegate5 so that it can be treated just like a FastDelegate5
  : public FastDelegate5 < Param1, Param2, Param3, Param4, Param5, R >
{
public:
  // Make using the base type a bit easier via typedef.
  typedef FastDelegate5 < Param1, Param2, Param3, Param4, Param5, R > BaseType;
  // Allow users access to the specific type of this delegate.
  typedef FastDelegate SelfType;
  // Mimic the base class constructors.
  FastDelegate() : BaseType() { }
  template < class X, class Y >
  FastDelegate(Y * pthis, 
    R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5 ))
    : BaseType(pthis, function_to_bind)  { }
  template < class X, class Y >
  FastDelegate(const Y *pthis,
      R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5 ) const)
    : BaseType(pthis, function_to_bind)
  {  }
  FastDelegate(R (*function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5 ))
    : BaseType(function_to_bind)  { }
  void operator = (const BaseType &x)  {	  
		*static_cast<BaseType*>(this) = x; }
};
//N=6
// Specialization to allow use of
// FastDelegate< R ( Param1, Param2, Param3, Param4, Param5, Param6 ) >
// instead of 
// FastDelegate6 < Param1, Param2, Param3, Param4, Param5, Param6, R >
template<typename R, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6>
class FastDelegate< R ( Param1, Param2, Param3, Param4, Param5, Param6 ) >
  // Inherit from FastDelegate6 so that it can be treated just like a FastDelegate6
  : public FastDelegate6 < Param1, Param2, Param3, Param4, Param5, Param6, R >
{
public:
  // Make using the base type a bit easier via typedef.
  typedef FastDelegate6 < Param1, Param2, Param3, Param4, Param5, Param6, R > BaseType;
  // Allow users access to the specific type of this delegate.
  typedef FastDelegate SelfType;
  // Mimic the base class constructors.
  FastDelegate() : BaseType() { }
  template < class X, class Y >
  FastDelegate(Y * pthis, 
    R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6 ))
    : BaseType(pthis, function_to_bind)  { }
  template < class X, class Y >
  FastDelegate(const Y *pthis,
      R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6 ) const)
    : BaseType(pthis, function_to_bind)
  {  }
  FastDelegate(R (*function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6 ))
    : BaseType(function_to_bind)  { }
  void operator = (const BaseType &x)  {	  
		*static_cast<BaseType*>(this) = x; }
};
//N=7
// Specialization to allow use of
// FastDelegate< R ( Param1, Param2, Param3, Param4, Param5, Param6, Param7 ) >
// instead of 
// FastDelegate7 < Param1, Param2, Param3, Param4, Param5, Param6, Param7, R >
template<typename R, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7>
class FastDelegate< R ( Param1, Param2, Param3, Param4, Param5, Param6, Param7 ) >
  // Inherit from FastDelegate7 so that it can be treated just like a FastDelegate7
  : public FastDelegate7 < Param1, Param2, Param3, Param4, Param5, Param6, Param7, R >
{
public:
  // Make using the base type a bit easier via typedef.
  typedef FastDelegate7 < Param1, Param2, Param3, Param4, Param5, Param6, Param7, R > BaseType;
  // Allow users access to the specific type of this delegate.
  typedef FastDelegate SelfType;
  // Mimic the base class constructors.
  FastDelegate() : BaseType() { }
  template < class X, class Y >
  FastDelegate(Y * pthis, 
    R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7 ))
    : BaseType(pthis, function_to_bind)  { }
  template < class X, class Y >
  FastDelegate(const Y *pthis,
      R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7 ) const)
    : BaseType(pthis, function_to_bind)
  {  }
  FastDelegate(R (*function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7 ))
    : BaseType(function_to_bind)  { }
  void operator = (const BaseType &x)  {	  
		*static_cast<BaseType*>(this) = x; }
};
//N=8
// Specialization to allow use of
// FastDelegate< R ( Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8 ) >
// instead of 
// FastDelegate8 < Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, R >
template<typename R, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8>
class FastDelegate< R ( Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8 ) >
  // Inherit from FastDelegate8 so that it can be treated just like a FastDelegate8
  : public FastDelegate8 < Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, R >
{
public:
  // Make using the base type a bit easier via typedef.
  typedef FastDelegate8 < Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, R > BaseType;
  // Allow users access to the specific type of this delegate.
  typedef FastDelegate SelfType;
  // Mimic the base class constructors.
  FastDelegate() : BaseType() { }
  template < class X, class Y >
  FastDelegate(Y * pthis, 
    R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8 ))
    : BaseType(pthis, function_to_bind)  { }
  template < class X, class Y >
  FastDelegate(const Y *pthis,
      R (X::* function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8 ) const)
    : BaseType(pthis, function_to_bind)
  {  }
  FastDelegate(R (*function_to_bind)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8 ))
    : BaseType(function_to_bind)  { }
  void operator = (const BaseType &x)  {	  
		*static_cast<BaseType*>(this) = x; }
};
#endif //FASTDELEGATE_ALLOW_FUNCTION_TYPE_SYNTAX
////////////////////////////////////////////////////////////////////////////////
//						Fast Delegates, part 5:
//
//				MakeDelegate() helper function
//
//			MakeDelegate(&x, &X::func) returns a fastdelegate of the type
//			necessary for calling x.func() with the correct number of arguments.
//			This makes it possible to eliminate many typedefs from user code.
//
////////////////////////////////////////////////////////////////////////////////
// Also declare overloads of a MakeDelegate() global function to 
// reduce the need for typedefs.
// We need seperate overloads for const and non-const member functions.
// Also, because of the weird rule about the class of derived member function pointers,
// implicit downcasts may need to be applied later to the 'this' pointer.
// That's why two classes (X and Y) appear in the definitions. Y must be implicitly
// castable to X.
// Workaround for VC6. VC6 needs void return types converted into DefaultVoid.
// GCC 3.2 and later won't compile this unless it's preceded by 'typename',
// but VC6 doesn't allow 'typename' in this context.
// So, I have to use a macro.
#ifdef FASTDLGT_VC6
#define FASTDLGT_RETTYPE detail::VoidToDefaultVoid<RetType>::type
#else 
#define FASTDLGT_RETTYPE RetType
#endif
//N=0
template <class X, class Y, class RetType>
FastDelegate0<FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType (X::*func)()) { 
	return FastDelegate0<FASTDLGT_RETTYPE>(x, func);
}
template <class X, class Y, class RetType>
FastDelegate0<FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType (X::*func)() const) { 
	return FastDelegate0<FASTDLGT_RETTYPE>(x, func);
}
//N=1
template <class X, class Y, class Param1, class RetType>
FastDelegate1<Param1, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1)) { 
	return FastDelegate1<Param1, FASTDLGT_RETTYPE>(x, func);
}
template <class X, class Y, class Param1, class RetType>
FastDelegate1<Param1, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1) const) { 
	return FastDelegate1<Param1, FASTDLGT_RETTYPE>(x, func);
}
//N=2
template <class X, class Y, class Param1, class Param2, class RetType>
FastDelegate2<Param1, Param2, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2)) { 
	return FastDelegate2<Param1, Param2, FASTDLGT_RETTYPE>(x, func);
}
template <class X, class Y, class Param1, class Param2, class RetType>
FastDelegate2<Param1, Param2, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2) const) { 
	return FastDelegate2<Param1, Param2, FASTDLGT_RETTYPE>(x, func);
}
//N=3
template <class X, class Y, class Param1, class Param2, class Param3, class RetType>
FastDelegate3<Param1, Param2, Param3, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3)) { 
	return FastDelegate3<Param1, Param2, Param3, FASTDLGT_RETTYPE>(x, func);
}
template <class X, class Y, class Param1, class Param2, class Param3, class RetType>
FastDelegate3<Param1, Param2, Param3, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3) const) { 
	return FastDelegate3<Param1, Param2, Param3, FASTDLGT_RETTYPE>(x, func);
}
//N=4
template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class RetType>
FastDelegate4<Param1, Param2, Param3, Param4, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4)) { 
	return FastDelegate4<Param1, Param2, Param3, Param4, FASTDLGT_RETTYPE>(x, func);
}
template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class RetType>
FastDelegate4<Param1, Param2, Param3, Param4, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4) const) { 
	return FastDelegate4<Param1, Param2, Param3, Param4, FASTDLGT_RETTYPE>(x, func);
}
//N=5
template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class RetType>
FastDelegate5<Param1, Param2, Param3, Param4, Param5, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5)) { 
	return FastDelegate5<Param1, Param2, Param3, Param4, Param5, FASTDLGT_RETTYPE>(x, func);
}
template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class RetType>
FastDelegate5<Param1, Param2, Param3, Param4, Param5, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const) { 
	return FastDelegate5<Param1, Param2, Param3, Param4, Param5, FASTDLGT_RETTYPE>(x, func);
}
//N=6
template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class RetType>
FastDelegate6<Param1, Param2, Param3, Param4, Param5, Param6, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6)) { 
	return FastDelegate6<Param1, Param2, Param3, Param4, Param5, Param6, FASTDLGT_RETTYPE>(x, func);
}
template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class RetType>
FastDelegate6<Param1, Param2, Param3, Param4, Param5, Param6, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const) { 
	return FastDelegate6<Param1, Param2, Param3, Param4, Param5, Param6, FASTDLGT_RETTYPE>(x, func);
}
//N=7
template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class RetType>
FastDelegate7<Param1, Param2, Param3, Param4, Param5, Param6, Param7, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7)) { 
	return FastDelegate7<Param1, Param2, Param3, Param4, Param5, Param6, Param7, FASTDLGT_RETTYPE>(x, func);
}
template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class RetType>
FastDelegate7<Param1, Param2, Param3, Param4, Param5, Param6, Param7, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const) { 
	return FastDelegate7<Param1, Param2, Param3, Param4, Param5, Param6, Param7, FASTDLGT_RETTYPE>(x, func);
}
//N=8
template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class RetType>
FastDelegate8<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8)) { 
	return FastDelegate8<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, FASTDLGT_RETTYPE>(x, func);
}
template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class RetType>
FastDelegate8<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType (X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const) { 
	return FastDelegate8<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, FASTDLGT_RETTYPE>(x, func);
}
 // clean up after ourselves...
#undef FASTDLGT_RETTYPE
} // namespace fastdelegate
#endif // !defined(FASTDELEGATE_H)
///////////////////////////////// [FastDelegate.h] END
#define delegate fastdelegate::FastDelegate
///////////////////////////////// [citkt_delegate.h] END
///////////////////////////////// [citkt_MemoryBlock.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITKT_MEMORYBLOCK_H_INCLUDED
#define CITKT_MEMORYBLOCK_H_INCLUDED
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
///////////////////////////////////////////////////////////////////////////////
// Allocation function (passed to methods that need to allocate memory for the caller)
typedef void* (CDECL *allocfunc_t)(size_t);
///////////////////////////////////////////////////////////////////////////////
// Basic memory block structure
template<class T>
union MemoryBlockT
{
	struct {
		size_t	size;
		T*		ptr;
	};
	uint64		array;				// D compatible 64-bit array variable
	MemoryBlockT() : ptr((T*)NULL), size(0) {}
	MemoryBlockT( T* p, size_t s ) : ptr(p), size(s) {}
	MemoryBlockT( size_t s, T* p ) : ptr(p), size(s) {}
	operator T* () const		{ return ptr; }
	operator size_t () const	{ return size; }
};
///////////////////////////////////////////////////////////////////////////////
typedef MemoryBlockT<void>		memoryblock_t;
typedef const memoryblock_t&	cmemoryblock_t;
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// Resizable memory block. Works much like a memory mapped file
class DMemoryBlock
{
public:
	// Constructor
	DMemoryBlock();
	// Destructor, frees all cached items
	~DMemoryBlock();
	void		Free();
	void		Empty();
	void		SeekTo( size_t );
	void		SeekBy( size_t );
	void		SeekEnd( size_t );
	size_t		GetPos() const { return cursor - memory.ptr; }
	size_t		GetSize() const { return size; }
	void*		GetData() const { return memory.ptr; }
	bool		EndOfData() const { return cursor>=(memory.ptr+size); }
	// Returns the number of bytes actually copied, <= 'data_size'
	size_t		GetBytes( void* data, size_t data_size );
	// Returns a pointer to a block of 'data_size' bytes
	// 'data_size' will be changed if less data was available
	void*		GetBytes( size_t &data_size );
	// Adds the number of bytes to the memory block
	void		PutBytes( const void* data, size_t data_size );
	// Returns a pointer to a block of 'data_size' bytes
	void*		PutBytes( size_t data_size );
private:
	MemoryBlockT<byte>	memory;
	byte*			cursor;
	size_t			size;
	void		Grow( size_t );
	// Hidden members, not implemented (to avoid generated copy):
	DMemoryBlock( const DMemoryBlock& );						// TODO
	void operator = ( const DMemoryBlock& );					// TODO
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_MEMORYBLOCK_H_INCLUDED
///////////////////////////////// [citkt_MemoryBlock.h] END
///////////////////////////////// [citkt_ArrayPtr.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
//		Container, uitgevoerd als resizing array
//
#ifndef	CITKT_ARRAYPTR_H_INCLUDED
#define	CITKT_ARRAYPTR_H_INCLUDED
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////// [citkt_Array.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
//		Container, resizing array
//
#ifndef	CITKT_ARRAY_H_INCLUDED
#define	CITKT_ARRAY_H_INCLUDED
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////// [citkt_Assert.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_ASSERT_H_INCLUDED
#define CITK_ASSERT_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//! Very simple assertion function. Must be implemented in each module.
extern void CDECL citk_assert( cstr_t );
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#ifdef _SAFEMODE
#undef assert
// _SAFEMODE
#define CITK_ASSERT(a,b)	if(!(a)) citk_assert(b)
#define assert(a)			(!(a)?citk_assert(_T("Assertion failed: ") _T(#a) _T(", file ") _T(__FILE__) _T(", line ") _T(_S(__LINE__)) ),false:true)
#else // _SAFEMODE
// not _SAFEMODE
#define CITK_ASSERT(a,b) {}
#include <assert.h>			// CRT
#endif // !_SAFEMODE
///////////////////////////////////////////////////////////////////////////////
//! Static assertion (compile time; usually used for checking type sizes)
#define citk_static_assert(_x)	typedef int __static_assert[(_x) ? 1 : -1]
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_ASSERT_H_INCLUDED
///////////////////////////////// [citkt_Assert.h] END
///////////////////////////////// [citkt_TypeName.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
//		Container, resizing array
//
#ifndef	CITKT_TYPENAME_H_INCLUDED
#define	CITKT_TYPENAME_H_INCLUDED
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
#ifndef NO_TYPEID
#include <typeinfo.h>			// for class type_info
#endif 
///////////////////////////////// [citkt_UTF8.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef	CITKT_UTF8_H_INCLUDED
#define	CITKT_UTF8_H_INCLUDED
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//int		wctoutf8( wchar_t current );
size_t		wcstoutf8_size( const wchar_t* source );
size_t		wcstoutf8( char* dest, const wchar_t* source, size_t count );
wchar_t		utf8towc( unsigned int  );
size_t		utf8towcs_size( const char* );
size_t		utf8towcs( wchar_t*, const char*, size_t count );
char*		utf8set( char *buf, unsigned int c );
char*		utf8get( const char *b, unsigned int *c );
const char*	utf8chr( const char *s, unsigned int c );
///////////////////////////////////////////////////////////////////////
#include <malloc.h>			// for alloca used by U2W and W2U
inline wchar_t* __U2WHelper( wchar_t *w, const char *u )
{
	// The UTF8 string is zero terminated and the destination is big enough
	utf8towcs( w, u, ~0 );		
	return w;
}
inline char* __W2UHelper( char *u, const wchar_t *w )
{
	// The wide string is zero terminated and the destination is big enough
	wcstoutf8( u, w, ~0 );
	return u;
}
//! Macro to convert UTF8 to wide (allocates buffer on the stack)
#define _U2W(x) \
	((x)?\
		(__U2WHelper( (wchar_t*)alloca(strlen(x)*2+2), x)):\
		(NULL))
//! Macro to convert wide to UTF8 (allocates buffer on the stack)
#define _W2U(x) \
	((x)?\
		(__W2UHelper( (char*)alloca(wcslen(x)*3+1), x)):\
		(NULL))
///////////////////////////////////////////////////////////////////////
#ifndef _UNICODE
// citk is using UTF8. Use the macros to convert to/from wide char string.
# define W2U(x) _W2U(x)
# define U2W(x) _U2W(x)
#else
// citk is not using any incompatible encoding. No conversion necessary. 
# define W2U(x) (x)
# define U2W(x) (x)
#endif
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
#endif // !CITKT_UTF8_H_INCLUDED
///////////////////////////////// [citkt_UTF8.h] END
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
///////////////////////////////////////////////////////////////////////
template <class T>
struct type_name
{
#ifdef NO_TYPEID
	operator const char* () const { return "no typeid"; }
#else
	operator const char* () const { return typeid(T).name(); }
#endif
};
#ifdef NO_TYPEID
type_name<int>::operator const char* () const { return "int"; }
// TODO: add other popular types here
#endif
///////////////////////////////////////////////////////////////////////
#ifdef _UNICODE
# define TYPE_NAME(T) _U2W(typeid(T).name())	// convert to wide
#else
# define TYPE_NAME(T) typeid(T).name()			// leave as MBCS
#endif
#define THIS_NAME	TYPE_NAME(*this)			// name of current class
//! Very fancy assertion macro that displays the name of the class
#define THIS_ASSERT(a,b) CITK_ASSERT(a,CONCAT(THIS_NAME,b))
///////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_TYPENAME_H_INCLUDED
///////////////////////////////// [citkt_TypeName.h] END
///////////////////////////////// [citkt_String.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITKT_STRING_INCLUDED
#define CITKT_STRING_INCLUDED
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citkt_StringStuff.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#pragma once
//#include "citkt_tchar.h"
#ifdef __GNUC__
# define stricmp strcasecmp
# define wcsicmp wcscasecmp
# define strnicmp strncasecmp
# define wcsnicmp wcsncasecmp
// Microsoft's CRT already implements these
char_t*	_tcsrev( char_t* );
char_t*	_tcsupr( char_t* );
char_t*	_tcslwr( char_t* );
int putws( const wchar_t* );
#endif //__GNUC__
namespace citkTypes {
/////////////////////////////////////////////////////////////////////////////
// Constant functions	
long	str_ToInt( cstr_t buf, long i =0 );			// converts hex & dec
double	str_ToFloat( cstr_t buf, double def =0.0 );
bool	str_Prefix( cstr_t buf, cstr_t prefix );
bool	str_IsLike( cstr_t buf, cstr_t pattern, dchar any=_T('*'), dchar one=_T('?'));
uint	str_Count( cstr_t buf, cstr_t find );		// returns number of occurrences
size_t	str_SizeOf( cstr_t str );					// returns size in bytes
cstr_t	str_UpTo( cstr_t in, dchar, char_t* out );	// returns ptr to next word
uint	str_CountChar(cstr_t buf, dchar ch );
hash_t	str_Hash(cstr_t);
int		str_Compare(cstr_t,cstr_t);
int		str_CompareIC(cstr_t,cstr_t);
// Non-constant functions that will only shorten the string
long	str_DelInt( char_t* buf, long i =0 );		// converts hex & dec
double	str_DelFloat( char_t* buf, double d =0.0 );
uint	str_DelWord( char_t* buf, char_t* word );
bool	str_DelPrefix( char_t* buf, cstr_t s );
char_t*	str_Delete( char_t* buf, uint index, uint count =1 );		// count = # of deleted bytes
uint	str_Replace( char_t* buf, dchar find, dchar repl );
char_t*	str_TrimLeft( char_t* buf );
char_t*	str_TrimRight( char_t* buf );
// CAUTION: non-constant functions that result in a longer string
uint	str_Replace( char_t* buf, cstr_t find, cstr_t repl );
char_t* str_Insert( char_t* buf, cstr_t s, uint index );			// index = no. of bytes
char_t* str_InsertChar( char_t* buf, dchar c, uint index );		// index = no. of bytes
/////////////////////////////////////////////////////////////////////////////
}//namespace citkTypes
///////////////////////////////// [citkt_StringStuff.h] END
#ifdef USE_IOSTREAM
# include <iostream>
#endif // USE_IOSTREAM
#include <stdio.h>
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
/////////////////////////////////////////////////////////////////////////////
enum {
	STRING_SIZE = 256          // "Should be enough for anyone"
};
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class String
{
public:
	// Default constructor:
	String() { CharBuf[0] = 0; }													// empty (default)
	// Constructors:
//	String( cstr_t c )						{ Set(c); }								// from C string
	String( const char *o )					{ Set(o); }								// from C string
	String( const wchar_t *o )				{ Set(o); }								// from C string
#ifdef _NATIVE_WCHAR_T_DEFINED			// need overloads for unsigned short  
	String( const unsigned short *o)		{ Set(o); }
#endif
	String( const String &s )				{ _tcscpy( CharBuf, s.c_str() ); }		// copy constructor
	String( cstr_t a, cstr_t b )			{ Set(a,b); }							// concatenate strings
	String( cstr_t c, int i )				{ Set(c,i); }							// string + length
#ifndef _BIG_ENDIAN
	explicit String( const char_t c )		{ *((int*)CharBuf) = (int)c; }			// single char
#else
	explicit String( const char_t c )		{ CharBuf[0] = c; CharBuf[1] = 0; }		// single char
#endif
	explicit String( const int i )			{ _stprintf( CharBuf, _T("%d"), i ); }	// from int
	explicit String( const long i )			{ _stprintf( CharBuf, _T("%ld"), i ); }	// from long
	explicit String( const float f )		{ _stprintf( CharBuf, _T("%#g"), f ); }	// from float
	explicit String( const double d )		{ _stprintf( CharBuf, _T("%#lg"), d ); }// from double
	explicit String( const unsigned int i )	{ _stprintf( CharBuf, _T("%u"), i ); }	// from uint
	explicit String( const unsigned long i ){ _stprintf( CharBuf, _T("%lu"), i ); }	// from ulong
#if defined(_SAFEMODE) && defined(_DEBUG)
	// WARNING: using new String[] in a project compiled without _SAFEMODE but calling
	//  delete[] in a project compiled with, will cause exceptions because the former
	//  will not have initialised the allocated object count at Data[-1]!
	// Destructor (only in safemode)
	~String()							{ CharBuf[0] = _T('~'); }
#endif
	// Type cast
	operator char_t* ()					{ return CharBuf; }
	operator cstr_t () const			{ return CharBuf; }
//	operator int () const { return (int)ToInt(); }
//	operator long () const { return ToInt(); }
//	operator float () const { return (float)ToFloat(); }
//	operator double () const { return ToFloat(); }
	// Assignment Operators:
	String&		operator = ( cstr_t c ) { return Set(c); }
	String&		operator = ( const String &s ) { _tcscpy( CharBuf, s.c_str() ); return *this; }
	// Const-Operators:
	String		operator + ( const String &s ) const	{ return String( c_str(), s.c_str() ); }
	String		operator + ( cstr_t c ) const { return c?String( c_str(), c ):*this; }
	// General Operators:
	String&		operator += ( cstr_t c )		{ return Append(c); }
	String&		operator += ( const String &s ) { return Append(s.c_str()); }
#ifdef _SAFEMODE
	char_t&		operator [] ( const int i ) { 
					assert( _smaller(i,STRING_SIZE) );
					return CharBuf[i]; }
	char_t		operator [] ( const int i ) const { 
					assert( _smaller(i,STRING_SIZE) );
					return CharBuf[i]; }
#else
	char_t&		operator [] ( const int i ) { return CharBuf[i]; }
	char_t		operator [] ( const int i ) const { return CharBuf[i]; }
#endif
	// Comparison (these methods accept NULL for "")
	int			CompareIC( cstr_t s ) const { return s?_tcsicmp( c_str(), s ):CharBuf[0]; }	// case-insensitive
	int			Compare( cstr_t s ) const { return s?_tcscmp( c_str(), s ):CharBuf[0]; }
	bool		EqualsIC( cstr_t s ) const { return CompareIC(s)==0; }	// case-insensitive
	bool		Equals( cstr_t s ) const { return Compare(s)==0; }
	bool		operator ! () const { return IsEmpty(); }
	bool		operator == ( cstr_t s ) const { return Compare(s)==0; }
	bool		operator <  ( cstr_t s ) const { return Compare(s)<0; }
	bool		operator <= ( cstr_t s ) const { return Compare(s)<=0; }
	bool		operator >  ( cstr_t s ) const { return Compare(s)>0; }
	bool		operator >= ( cstr_t s ) const { return Compare(s)>=0; }
	bool		operator != ( cstr_t s ) const { return Compare(s)!=0; }
	bool		operator == ( const String &s ) const { return Compare(s)==0; }
	bool		operator <  ( const String &s ) const { return Compare(s)<0; }
	bool		operator <= ( const String &s ) const { return Compare(s)<=0; }
	bool		operator >  ( const String &s ) const { return Compare(s)>0; }
	bool		operator >= ( const String &s ) const { return Compare(s)>=0; }
	bool		operator != ( const String &s ) const { return Compare(s)!=0; }
	// Various functions:
	static inline int	MaxLength() { return STRING_SIZE; }
	cstr_t		c_str() const { return CharBuf; }
	int			Length() const { return (int)_tcslen(c_str()); } 
	bool		IsEmpty() const { return CharBuf[0]==0; }
	String&		Insert( cstr_t s, const int index =0 ) { str_Insert(CharBuf,s,index); return *this; } 
	String&		InsertChar( const int c, const int index =0 ) { str_InsertChar(CharBuf,c,index); return *this; }
	String&		Delete( const int index, const int count =1 ) { str_Delete(CharBuf,index,count);  return *this; }
	String&		Set( const char *str );						// accepts NULL for ""
	String&		Set( const wchar_t *str );					// accepts NULL for ""
#ifdef _NATIVE_WCHAR_T_DEFINED			// need overloads for unsigned short  
	String&		Set( const unsigned short *str );
#endif
//	String&		Set( cstr_t str );							// accepts NULL for ""
	String&		Set( cstr_t s1, cstr_t s2 );				// accepts NULL for ""
	String&		Set( char_t c ) { CharBuf[0]=c; CharBuf[1]=0; return *this; }
	String&		Set( cstr_t str, int len );					// accepts NULL for ""
	String&		Append( cstr_t );							// accepts NULL for ""
	String&		Append( char_t c ) { int i=Length(); CharBuf[i++]=c; assert(i<STRING_SIZE); CharBuf[i]=0; return *this; }
	String&		SetAt( const int pos, cstr_t str );			// accepts NULL for ""
	String&		SetAt( const int pos, char_t c );			// MFC compatible
	String&		SetLength( const int len );
	String&		Crop( const int len );						// decrease length by ..
	String&		Clear() { CharBuf[0]=0; return (*this); }
	bool		Contains( cstr_t s ) const { return _tcsstr(c_str(),s)!=NULL; }
	int			Pos( cstr_t ) const;
	int			PosOfAny( cstr_t tokens ) const;
	int			Pos( char_t c ) const;
	int			PosR( char_t c ) const;
	char_t		Char( const int i ) const { return _smaller(i,Length())?CharBuf[i]:0; }
	char_t		CharR( const int i =0 ) const { int l=Length(); return _smaller(i,l)?CharBuf[l-i-1]:0; }
	char_t		Peek() const { int l=Length(); return l?CharBuf[l-1]:0; }
	char_t		Pop() { int l=Length(); if (!l) return 0; char_t c=CharBuf[--l]; CharBuf[l]=0; return c; }
//	String&		Reverse() { _tcsrev( CharBuf ); return (*this); }
	String&		ToUpper() { _tcsupr( CharBuf ); return (*this); }
	String&		ToLower() { _tcslwr( CharBuf ); return (*this); }
	String		Clone() const { return String(*this); }
	String		UpperCase() const { return Clone().ToUpper(); }
	String		LowerCase() const { return Clone().ToLower(); }
	int			Replace( cstr_t find, cstr_t repl ) { return str_Replace(CharBuf,find,repl); }
	int			Replace( int find, int repl ) { return str_Replace(CharBuf,find,repl); }
	String&		Trim() { return TrimLeft().TrimRight(); }
	String&		TrimLeft()  { str_TrimLeft(CharBuf); return *this; }
	String&		TrimRight() { str_TrimRight(CharBuf); return *this; }
	String		Trimmed() const { return Clone().Trim(); }
	String&		RightJustify( int len, char_t =_T(' ') );
	String&		LeftJustify( int len, char_t =_T(' ') );
	String		Left( const int c ) const { return String(CharBuf,c); }
	String		Right( const int c ) const { int l=Length(); return String( CharBuf+l-_limit(c,0,l) ); }
	String		SubString( const int i, const int c ) const { assert(_smaller(i,STRING_SIZE)); return String(CharBuf+i,c); };
	String		Skip( const int i ) const { return SubString(i,STRING_SIZE); }
	bool		Prefix( cstr_t s ) const { return str_Prefix(CharBuf,s); }		// detect prefix
	bool		DelPrefix( cstr_t s ) { return str_DelPrefix(CharBuf,s); }		// detect & delete prefix
	long		DelInt( long def =0 ) { return str_DelInt(CharBuf,def); }		// detect & delete integer
	double		DelFloat( double def =0.0 ) { return str_DelFloat(CharBuf,def); }// detect & delete floating point
	String		DelWord() { String s; str_DelWord(CharBuf,s); return s; }		// detect & delete word
	long		ToInt( long def =0 ) const { return str_ToInt(CharBuf,def); }	// convert to int (hex & dec)
	double		ToFloat( double def =0.0 ) const { return str_ToFloat(CharBuf,def); }// convert to floating point
	long		HexToInt( long def =0 ) const;		// convert hex to int
	String&		Hex( const long i );				// from int -> Hex
	int	CDECL	Printf( cstr_t, ... );				// same as _stprintf(...)
	bool		IsLike ( cstr_t pPattern ) const { return str_IsLike(CharBuf,pPattern); }
	// Friend-Functions:
	friend String operator + ( cstr_t, const String& );
#ifdef USE_IOSTREAM
	friend ostream& operator << ( ostream&, const String& );
	friend istream& operator >> ( istream&, String& );
#endif // USE_IOSTREAM
private:
	char_t	CharBuf[STRING_SIZE];
};
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
inline String& String::SetLength( const int len ) 
{ 
	CharBuf[ _limit( len, 0, STRING_SIZE-1 ) ] = 0; 
	return (*this); 
}
/////////////////////////////////////////////////////////////////////////////
inline String& String::Crop( const int len )
{
	SetLength( Length() - len );
	return (*this); 
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
inline int String::Pos( cstr_t s ) const 
{ 
	cstr_t p = _tcsstr( c_str(), s );
	return (p?p-CharBuf:-1); 
}
/////////////////////////////////////////////////////////////////////////////
inline int String::PosOfAny( cstr_t tokens ) const 
{ 
	int i = (int)_tcscspn( c_str(), tokens ); 
	return CharBuf[i]?i:-1; 
}
/////////////////////////////////////////////////////////////////////////////
inline int String::Pos( char_t c ) const 
{
	cstr_t p = _tcschr( c_str(), (int)c );
	return (p?p-CharBuf:-1); 
}
/////////////////////////////////////////////////////////////////////////////
inline int String::PosR( char_t c ) const 
{
	cstr_t p = _tcsrchr( c_str(), (int)c );
	return (p?p-CharBuf:-1); 
}
/////////////////////////////////////////////////////////////////////////////
inline String& String::SetAt( const int pos, char_t c )			// MFC compatible
{
	assert( _smaller(pos,STRING_SIZE) );
	CharBuf[pos] = c;
	return *this;
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Friends:
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
inline String operator + ( cstr_t s, const String &t ) 
{
	return String( s, t.c_str() ); 
}
/////////////////////////////////////////////////////////////////////////////
#define HEXSTRING(val)		String().Hex((long)(val))		// convert a value into hex string
#define INTSTRING(val)		String((long)(val))				// convert a value into int string
#define UINTSTRING(val)		String((unsigned long)(val))	// convert a value into int string
#define FLOATSTRING(val)	String((float)(val))			// convert a value into float string
#define CONCAT(s1,s2)		String(s1,s2)					// concatenate two strings (fast)
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_STRING_INCLUDED
///////////////////////////////// [citkt_String.h] END
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
/*
template <class T>
class ArrayNewDelete
{
public:
	static T*	_new( uint c ) { return new T[c]; }
	static void	_delete( T* d ) { delete [] d; }
	static T*	_resize( T* d, uint c ) { return (T*)::malloc(sizeof(T)*c); }
};
template <class T>
class ArrayMallocFree
{
public:
	static T*	_new( uint c ) { return (T*)::malloc(sizeof(T)*c); }
	static void	_delete( T* d ) { ::free(d); }
	static T*	_resize( T* d, uint c ) { return (T*)::realloc(d,sizeof(T)*c); }
};
*/
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
enum {
	NewDelete =0,
	MallocFree =1
};
///////////////////////////////////////////////////////////////////////
template <class T, int A =NewDelete >					// use new/delete by default
class Array
{
public:
	enum {
		DELTA_DOUBLE	= 0,					// future
		DEFAULT_DELTA	= 16,
		INVALID_ITEM	= -1					// returned by Array*::Find
	};
	// Default constructor
	Array()									{ _Init(); }
	// Copy constructor
	Array( const Array<T,A> &av )			{ _Init(); AddFrom(av); }
	// Constructors:
	explicit Array( uint ni )				{ _Init(); Reserve(ni); NumItems=ni; }
	template <int AA>
	Array( const Array<T,AA> &av )			{ _Init(); AddFrom(av); }
	Array( const T* ar, uint count )		{ _Init(); AddFrom(ar,count); }
	// Destructor:
	~Array();
	// LIFO / Stack methods
	T&			Push()				{ return Add(); }
	T&			Peek() const		{ assert(NumItems); return Data[NumItems-1]; }	// CAREFULL
	T			Pop()				{ assert(NumItems); return Data[--NumItems]; }	// CAREFULL
	// Methods:
	T&			Add();
	T&			SetNo( uint at );			// checks the input and grows
	T&			Insert( uint at );			// SLOW (checks input)
	bool		RemoveNo( uint );			// can change the order
	void		RemoveAll();					// frees allocated memory
	bool		RemoveOrdered( uint );		// SLOW (checks input)
	T			GetNo( uint ) const;		// asserts if invalid index
	bool		SwapNo( uint, uint );	// checks input
	bool		MoveToHead( uint i )		{ return SwapNo(i,0); }
	bool		MoveToTail( uint i )		{ return SwapNo(i,NumItems-1); }
	T*			Grow( uint delta );			// grow for new items
	void		Reserve( uint );			// pre-allocates memory
	void		Optimize();						// makes MaxItems == NumItems
	uint 		SetCount( uint n )		{ if (n>MaxItems) Reserve(n); return NumItems=n; }
	void		Empty()						{ NumItems=0; }
	bool		IsEmpty() const				{ return NumItems==0; }
	int			Count() const				{ return NumItems; }
	void		SetDelta( uint d )			{ assert(d||MaxItems); Delta=d; }
	void		SetSmartDelta( uint r )		{ Reserve(r); SetDelta(DELTA_DOUBLE); }
	T*			GetData() const				{ return Data; }
	T*			DetachData();					// must be freed with _delete
	void		AttachData( T* p, uint );	// must be allocated using _new
	void		AttachData( Array<T,A> &a ) { uint l=a.Count(); AttachData( a.DetachData(), l ); }
	uint		GetDataSize() const			{ return NumItems*sizeof(T); }
	uint		GetMem() const				{ return MaxItems*sizeof(T); }
	uint		CopyTo( T* ptr, uint maxelems ) const;
	void		Fill( const T& f )			{ for (size_t t=0; t<NumItems; ++t) Data[t]=f; }
	void		AddFrom( const T*, uint );
	template <int AA>
	void		AddFrom( const Array<T,AA> &ar )		{ AddFrom( ar.GetData(), ar.Count() ); }
	void		CopyFrom( const T* p, uint c )	{ Empty(); AddFrom(p,c); }
	template <int AA>
	void		CopyFrom( const Array<T,AA> &ar )	{ Empty(); AddFrom(ar); }
	bool		ContainsNo( uint i ) const		{ return _smaller(i,NumItems); }
	void		QuickSort( comparefunc_t ct ) {
		assert(A!=NewDelete);			// only allowed on malloc/free-arrays
		if (NumItems>1) qsort( (void*)Data, NumItems, sizeof(T), ct ); }
	T*			Lock() { /*Locked++;*/ return Data; }				// obsolete
	void		Unlock() { /*if (Locked>0) Locked--;*/ }			// obsolete
	// Overloaded operators:
	
	void	operator = ( const Array<T,A> &av )			{ CopyFrom(av); }
	template <int AA>
	void	operator = ( const Array<T,AA> &av )		{ CopyFrom(av); }
			operator uint () const				{ return NumItems; }
			operator T* () const					{ return Data; }
	T		operator () ( uint i ) const			{ return GetNo(i); }
	T&		operator [] ( int i ) {
		THIS_ASSERT( _smaller(i,NumItems), _T(" invalid item") );
		return Data[i]; }										
	T&		operator [] ( int i ) const {
		THIS_ASSERT( _smaller(i,NumItems), _T(" invalid item (const)") );
		return Data[i]; }										
	T&		operator [] ( size_t i ) {
		THIS_ASSERT( i<NumItems, _T(" invalid item") );
		return Data[i]; }										
	T&		operator [] ( size_t i ) const {
		THIS_ASSERT( i<NumItems, _T(" invalid item (const)") );
		return Data[i]; }										
	// Advanced methods:
	bool		_Contains( const T* p ) const	{ return p>=Data && p<(Data+MaxItems); }
	bool		_Contains( const T& p ) const	{ return &p>=Data && &p<(Data+MaxItems); }
	static T*	_new( uint c );			//{ return A::_new(c); }
	static void	_delete( T *d );				//{ A::_delete(d); }
protected:
	T*		Data;
	uint	NumItems;
	uint	MaxItems;
	uint	Delta;
//	uint		Locked;								// obsolete
	
	void	_Init() { Data = NULL; /*Locked =*/ NumItems = MaxItems = 0; Delta = DEFAULT_DELTA; }
	void	_Realloc( uint );					// creates array for new length
	void	_Larger()	{ Grow(Delta); }		// obsolete
	void	_RemoveNo(uint);					// no check, changes the order
};
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T, int A>
inline Array<T,A>::~Array()
{
//	THIS_ASSERT( !Locked, "::~Array() : Array is still locked" );
	_delete( Data );					// (calls dtors)
#ifdef _SAFEMODE
	Data = (T*)(size_t)0xDEADBEEF;		// trigger exceptions when accessed
//	NumItems = 0;						// NO: let them try to access Data
#endif
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T, int A>
void Array<T,A>::_Realloc( uint new_length )
{
	THIS_ASSERT( new_length>0, _T("::_Realloc(): obsolete call to _Resize") );
//	THIS_ASSERT( !Locked, _T("::_Update() : Array is still locked") );
	THIS_ASSERT( new_length >= NumItems, _T("::_Realloc() : new_length < NumItems") );
	THIS_ASSERT( new_length < 0x10000000, _T("::_Realloc() : new_length out of range") );
	// FIXME: could use partial specialization (VC .NET)
	if (A==MallocFree)
	{
		// We can use realloc to resize the block; will copy the contents too.
		Data = (T*)::realloc(Data,new_length*sizeof(T));
	}
	else if (A==NewDelete)
	{
		// FIXME: though very general, this method calls ctor/=/dtor many times!
		T *New = _new(new_length);			// New array (calls ctors)
		if (Data)
		{
			for (uint t=0; t<NumItems; t++)	// Copy the items
				New[t] = Data[t];			// operator =
			_delete(Data);					// (calls dtors)
		}
		Data = New;
	}
	else
		assert(0);
	MaxItems = new_length;
}
///////////////////////////////////////////////////////////////////////
template <class T, int A>
T* Array<T,A>::Grow( uint delta )
{
	if (MaxItems > (delta<<6))
	{
		// only show the assertion message if we're not supposed to double
		THIS_ASSERT( !Delta, _T(" Performance warning: increase Delta") );
		delta = MaxItems;		// increase, so we don't assert again
	}
	uint old_length = MaxItems;
	_Realloc( MaxItems+delta );
	// must now have room for at least 1 item
	assert( NumItems < MaxItems );
	assert( old_length < MaxItems );
	return Data+old_length;
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T, int A>
inline T& Array<T,A>::Add()
{
	if (NumItems >= MaxItems)
		_Larger();
	return Data[NumItems++];
}
///////////////////////////////////////////////////////////////////////
template <class T, int A>
T& Array<T,A>::SetNo( uint i )
{
	THIS_ASSERT( i>=0, CONCAT(THIS_NAME,_T("::SetNo, Index out of range")) );
	if (i>=MaxItems)
		Reserve(i+Delta);
	if (i>=NumItems)
		NumItems = i+1;
	return Data[i];
}
///////////////////////////////////////////////////////////////////////
template <class T, int A>
T& Array<T,A>::Insert( uint i )
{
	// Make sure 0<=i<NumItems
	if (!ContainsNo(i))
		return SetNo(i);
	// FIXME: we copy the items twice; could be done in a single pass
	if (NumItems >= MaxItems)
		_Larger();
	// Copy the items, start with the last one
	for (uint t=NumItems; t>i; --t)
		Data[t] = Data[t-1];			// (calls operator =)
	NumItems++;
	return Data[i];
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T, int A>
inline void Array<T,A>::_RemoveNo( uint i )
{
	if (--NumItems != i)
		Data[i] = Data[NumItems];		// (calls operator =)
}
///////////////////////////////////////////////////////////////////////
template <class T, int A>
bool Array<T,A>::RemoveNo( uint i )
{
	if (!ContainsNo(i))
		return false;
	_RemoveNo(i);
	return true;
}
///////////////////////////////////////////////////////////////////////
template <class T, int A>
bool Array<T,A>::RemoveOrdered( uint i )
{
	if (!ContainsNo(i))
		return false;
	NumItems--;
	for (uint t=i; t<NumItems; t++)
		Data[t] = Data[t+1];			// (calls operator =)
	return true;
}
///////////////////////////////////////////////////////////////////////
template <class T, int A>
void Array<T,A>::RemoveAll()
{
//	THIS_ASSERT( !Locked, _T("::RemoveAll() called on locked array") );
//	if (!Locked)
	{
		_delete( Data );				// (calls dtors)
		Data = NULL;
		MaxItems = 0;
	}
	NumItems = 0;
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T, int A>
inline T Array<T,A>::GetNo( uint i ) const
{
	THIS_ASSERT( _smaller(i,NumItems), _T("::GetNo() : i>=0 && i<NumItems") );
	return Data[i];
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T, int A>
bool Array<T,A>::SwapNo( uint i1, uint i2 )
{
	if (!ContainsNo(i1) || !ContainsNo(i2))
		return false;
	T p = Data[i1];						// (calls copy ctor)	
	Data[i1] = Data[i2];				// (calls operator =)
	Data[i2] = p;						// (calls operator =)
	return true;						// (calls dtor)
}
///////////////////////////////////////////////////////////////////////
template <class T, int A>
void Array<T,A>::Reserve( uint i )
{
//	if (i < NumItems || i==MaxItems)
	if (i > MaxItems)
		_Realloc(i);
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T, int A>
uint Array<T,A>::CopyTo( T* data, uint count ) const
{
	if (!data || !count)
		return NumItems;
	if (count>NumItems)
		count = NumItems;
	for (uint t=0; t<count; t++)
		data[t] = data[t];				// (calls operator =)
	return count;
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T, int A>
void Array<T,A>::AddFrom( const T* data, uint count )
{
	if (count<=0)
		return;
	// The provided pointer may not be pointing into our array
	THIS_ASSERT( !_Contains(data), _T(" reference might be inaccessible when array grows") );
	uint ni = NumItems;
	SetCount( NumItems + count );
//	memcpy( (void*)&Data[ni], (void*)data, sizeof(T)*count );
	// Don't use memcpy since some items might use the copy constructor:
	for (uint t=0; t<count; t++)
		Data[ni+t] = data[t];			// (calls operator =)
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
	
template <class T, int A>
inline T* Array<T,A>::DetachData()				
{ 
	T* p = Data; 
	Data = NULL; 
	NumItems = MaxItems = 0; 
	return p; 
}
///////////////////////////////////////////////////////////////////////
template <class T, int A>
void Array<T,A>::AttachData( T* p, uint i ) 
{ 
	// The provided pointer may not be pointing into our array
	THIS_ASSERT( !_Contains(p), _T(" reference might be inaccessible when array grows") );
	RemoveAll(); 
	Data = p; 
	if (!p) i=0;
	NumItems = MaxItems = i;
}
///////////////////////////////////////////////////////////////////////
template <class T, int A>
void Array<T,A>::Optimize() 
{ 
	if (MaxItems > NumItems)
	{
		if (NumItems==0)
			RemoveAll();
		else
			_Realloc(NumItems);
	}
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T, int A>
inline T* Array<T,A>::_new( uint c )	
{ 
	// FIXME: could use partial specialization (VC .NET)
	if (A==MallocFree)
		return (T*)::malloc(sizeof(T)*c);
	else if (A==NewDelete)
		return new T[c]; 
	else
		assert(0);
}
///////////////////////////////////////////////////////////////////////
template <class T, int A>
inline void	Array<T,A>::_delete( T *d )		
{ 
	// FIXME: could use partial specialization (VC .NET)
	if (A==MallocFree)
		free(d);
	else if (A==NewDelete)
		delete [] d; 
	else
		assert(0);
}
///////////////////////////////////////////////////////////////////////
#define foreach(I,A)	\
	for(size_t I=0,__L=citkTypes::length(A); I<__L; assert(__L==citkTypes::length(A)), ++I)
template <typename T, int A>
inline size_t length( const Array<T,A> &a ) { return a.Count(); }
template <typename T, int S>
inline size_t length( T (&a)[S] ) { return S; }
///////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_ARRAY_H_INCLUDED
///////////////////////////////// [citkt_Array.h] END
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T>
class ArrayPtr : public Array<T*,1>					// use malloc/free/realloc
{
public:
	typedef T*		PT;								// pointer to pointer typedef
	// Default constructor
	ArrayPtr() {}
	// Constructors:
	ArrayPtr( uint init ) : Array<T*,1>(init) {}
	ArrayPtr( const Array<T*,0> &ar ) : Array<T*,1>(ar) {}
	ArrayPtr( const Array<T*,1> &ar ) : Array<T*,1>(ar) {}
	ArrayPtr( const PT *data, uint data_size ) : Array<T*,1>(data,data_size) {}
	// LIFO / Stack methods
	uint		Push( PT const a )				{ return Add(a); }
	PT			Peek() const					{ assert(NumItems); return NumItems>0?Data[NumItems-1]:NULL; }
	PT			Pop()							{ assert(NumItems); return NumItems>0?Data[--NumItems]:NULL; }
	// Normal methods:
	uint		Add( PT const );					// overloaded, returns index
	bool		AddUnique( PT const );				// first does Find, then Add
	PT			AddNew()						{ PT n=new T; Add(n); return n; }
	PT			SetNew( uint i )				{ PT n=new T; SetNo(i,n); return n; }
	bool		Remove( PT const );					// can change the order
	PT			RemoveNo( uint );					// can change the order
	PT			RemoveOrdered( uint );			// maintains the order
	uint		RemoveEvery( PT const );			// remove all occurences; order unchanged
	bool		Delete( PT p )					{ return Remove(p)?delete p,true:false; }
	bool		DeleteNo( uint i )				{ PT p = RemoveNo(i); delete p; return p!=NULL; }
	bool		DeleteOrdered( uint i )			{ PT p = RemoveOrdered(i); delete p; return p!=NULL; }
	void		DeleteAll();						// also calls 'delete'
	bool		AddUniqueID( PT, int& );			// sets ptr at first NULL
	bool		RemoveUniqueID( PT, int& );			// sets NULL at index
	// Search methods:
	int			FindFrom( PT const, uint ) const;
	int			Find( PT const d ) const		{ return FindFrom(d,0); }
	uint		FindAndReplaceFrom( PT const, PT const, uint );
	uint		FindAndReplace( PT const d, PT const r ) { return FindAndReplaceFrom(d,r,0); }
	uint		CountFrom( PT const, uint ) const;
//	uint		Count( PT const d ) const { return CountFrom(d,0); }
	bool		Contains( PT const d ) const	{ return Find(d)!=INVALID_ITEM; }
	// Overloaded methods:
	PT			SetNo( uint i, PT const p );	// fills up with NULL
	PT			Insert( uint i, PT const p );	// fills up with NULL
	bool		MoveToTail( PT const p )		{ return Array<T*,1>::MoveToTail( Find(p) ); }
	bool		MoveToHead( PT const p )		{ return Array<T*,1>::MoveToHead( Find(p) ); }
	PT			GetNo( uint i ) const			{ return ContainsNo(i)?Data[i]:NULL; }
	PT		operator () ( uint i ) const		{ return GetNo(i); }
};
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T>
uint ArrayPtr<T>::Add( T* const d )
{
	if (NumItems >= MaxItems)
		_Larger();
	Data[NumItems] = d;
	return NumItems++;
}
///////////////////////////////////////////////////////////////////////
template <class T>
bool ArrayPtr<T>::AddUnique( T* const d )
{
	int i = Find(d);
	return i==INVALID_ITEM?(Add(d),true):false;
}
///////////////////////////////////////////////////////////////////////
template <class T>
T* ArrayPtr<T>::SetNo( uint i, PT const d )
{
	uint ni = NumItems;
	Array<T*,1>::SetNo(i) = d;
	while (ni<i)						// fill up with NULL
		Data[ni++] = NULL;
	return d;
}
///////////////////////////////////////////////////////////////////////
template <class T>
T* ArrayPtr<T>::Insert( uint i, PT const d )
{
	uint ni = NumItems;
	Array<T*,1>::Insert(i) = d;
	while (ni<i)						// fill up with NULL
		Data[ni++] = NULL;
	return d;
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T>
bool ArrayPtr<T>::Remove( T* const d )
{
	for (uint t=0; t<NumItems; t++)
		if (Data[t]==d)
		{
			_RemoveNo(t);
			return true;
		}
	return false;
}
///////////////////////////////////////////////////////////////////////
template <class T>
T* ArrayPtr<T>::RemoveOrdered( uint i )
{
	if (!ContainsNo(i))
		return NULL;
	PT d = Data[i];
	NumItems--;
	for (uint t=i; t<NumItems; t++)
		Data[t] = Data[t+1];
#ifdef ARRAY_AUTO_SMALLER
	if (MaxItems > NumItems+Delta)		// >=
		_Smaller();
#endif // ARRAY_AUTO_SMALLER
	return d;
}
///////////////////////////////////////////////////////////////////////
template <class T>
uint ArrayPtr<T>::RemoveEvery( T* const d )
{
	uint count=0;
	for (uint t=0; t<NumItems; t++)	// remove obsolete entries
	{
		if (Data[t]!=d)
		{
			if (count!=t)
				Data[count] = Data[t];
			count++;
		}
	}
	uint diff = NumItems - count;	// number of removed items
	NumItems = count;
	return diff; 
}
///////////////////////////////////////////////////////////////////////
template <class T>
T* ArrayPtr<T>::RemoveNo( uint i )
{
	if (!ContainsNo(i))
		return NULL;
	PT d = Data[i];
	_RemoveNo(i);
	return d;
}
///////////////////////////////////////////////////////////////////////
template <class T> 
void ArrayPtr<T>::DeleteAll() 
{ 
	uint oldnum = Count();
	PT *olddata = DetachData();			// detach the data (dtors interfere)
	for (uint t=0; t<oldnum; ++t)
		delete olddata[t];				// delete object [t]
	_delete( olddata );					// delete the array
}
	
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T>
int ArrayPtr<T>::FindFrom( PT const d, uint t ) const
{
	for (; t<NumItems; t++)
		if (Data[t]==d)
			return t;
	return INVALID_ITEM;
}
///////////////////////////////////////////////////////////////////////
template <class T>
uint ArrayPtr<T>::FindAndReplaceFrom( PT const p1, PT const p2, uint f )
{
	if (p1==p2)
		return 0;
	uint c=0;
	int i = f;
	while (1)
	{
		i = FindFrom(p1,i);
		if (i==INVALID_ITEM)
			break;
		c++;
		Data[i++] = p2;
	}
	return c;
}
///////////////////////////////////////////////////////////////////////
template <class T>
uint ArrayPtr<T>::CountFrom( PT const p, uint f ) const
{
	uint c=0;
	int i = FindFrom(p,f);
	while (i!=INVALID_ITEM)
	{
		c++;
		i = FindFrom(p,i+1);
	}
	return c;
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
template <class T>
bool ArrayPtr<T>::AddUniqueID( PT obj, int &ID )
{
	if (ID!=INVALID_ITEM)
	{
		THIS_ASSERT(GetNo(ID)==obj,_T("::AddUniqueID: Invalid ID"));
		return false;
	}
	uint iter = 0;
	// Search for first empty ID
	for (; iter<NumItems; iter++)
		if (!Data[iter])
			break;
	// Add to list
	SetNo(iter,obj);
	// Set ID
	ID = iter;
	return true;
}
///////////////////////////////////////////////////////////////////////////////
template <class T>
bool ArrayPtr<T>::RemoveUniqueID( PT obj, int &ID )
{
	if (ID==INVALID_ITEM)
		return false;
	// Cross check with list
	if (GetNo(ID)!=obj)
	{
		THIS_ASSERT(0,_T("::RemoveUniqueID: Invalid ID"));
		return false;
	}
	// Remove from list
	SetNo( ID, NULL );
	// Remove ID
	ID = INVALID_ITEM;
	return true;
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_ARRAYPTR_H_INCLUDED
///////////////////////////////// [citkt_ArrayPtr.h] END
///////////////////////////////// [citkt_DynString.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITKT_DYNSTRING_H_INCLUDED
#define CITKT_DYNSTRING_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
///////////////////////////////////////////////////////////////////////////////
class DynString
{
public:
	static inline cstr_t	T( cstr_t p ) { return p?p:_T(""); }
	// Default constructor
	DynString() : pChar(NULL) { }
	DynString( const char *p );								// accepts NULL for ""
	DynString( const wchar_t* );							// accepts NULL for ""
#ifdef _NATIVE_WCHAR_T_DEFINED			// need overloads for unsigned short  
	DynString( const unsigned short* );						// accepts NULL for ""
#endif
	DynString( const String &s )		{ pChar=NULL; if (s[0]) pChar = _tcsdup(s.c_str()); }
	DynString( const DynString &s )		{ pChar=NULL; if (s.pChar) pChar = _tcsdup(s.pChar); }
	DynString( cstr_t c, const int i );						// accepts NULL for ""
	// Concatenation constructors
	DynString( cstr_t, cstr_t );							// accepts NULL for ""
	DynString( cstr_t, cstr_t, cstr_t );					// accepts NULL for ""
	// Destructor
	~DynString() { if (pChar) free(pChar); }
	// Set
	DynString&	Set( const String &s )		{ free(pChar); pChar=NULL; if (s[0]) pChar = _tcsdup(s.c_str()); return (*this); }
	DynString&	Set( const char* );							// accepts NULL for ""
	DynString&	Set( const wchar_t* );						// accepts NULL for ""
#ifdef _NATIVE_WCHAR_T_DEFINED			// need overloads for unsigned short  
	DynString&	Set( const unsigned short* );				// accepts NULL for ""
#endif
	DynString&	Set( cstr_t, cstr_t );						// accepts NULL for ""
	DynString&	Set( cstr_t, const int len );				// accepts NULL for ""
	DynString&	Append( cstr_t );							// accepts NULL for ""
	DynString&	SetAt( const int pos, cstr_t c );			// accepts NULL for ""
	DynString&	SetAt( const int pos, char_t c );			// MFC compatible
	DynString&	Clear()						{ free(pChar); pChar=NULL; return (*this); }
	DynString&	SetLength( const int i )	{ Realloc(i)[i] = 0; return (*this); }
//	DynString&	Skip( const int i )			{ assert(i<=Length()); return pChar?Set(pChar+i):*this; }
	// Memory management functions
	char_t*		Realloc( const int size );
	char_t*		Alloc( const int size );
	char_t*		Detach();
	DynString&	Attach( char_t* p );						// will be free()'ed
	DynString&	Attach( DynString& );						// steals the data
	cstr_t		c_str() const { return T(pChar); }
	operator const char_t* () const { return pChar; }		// can return NULL
	// Operators
	DynString	operator + ( cstr_t s ) const { return DynString(c_str(),T(s)); }
	DynString	operator + ( const String &s ) const { return DynString(c_str(),s.c_str()); }
	DynString	operator + ( const DynString &d ) const { return DynString(c_str(),d.c_str()); }
	DynString&	operator += ( cstr_t s ) { return Append(s); }
	DynString&	operator = ( const char* a )		{ return Set(a); }
	DynString&	operator = ( const wchar_t* w )		{ return Set(w); }
	DynString&	operator = ( const DynString &s )	{ return Set(s); }
	DynString&	operator = ( const String &s )		{ return Set(s); }
	// Comparison (these methods accept NULL for "")
	int			CompareIC( cstr_t s ) const { return _tcsicmp( c_str(), T(s) ); }	// Case-Insensitive
	int			Compare( cstr_t s ) const { return _tcscmp( c_str(), T(s) ); }
	bool		Equals( cstr_t s ) const { return Compare(s)==0; }
	bool		EqualsIC( cstr_t s ) const { return CompareIC(s)==0; }
	
	bool		operator ! () const { return IsEmpty(); }
	bool		operator == ( cstr_t s ) const { return Compare(s)==0; }
	bool		operator <  ( cstr_t s ) const { return Compare(s)<0; }
	bool		operator <= ( cstr_t s ) const { return Compare(s)<=0; }
	bool		operator >  ( cstr_t s ) const { return Compare(s)>0; }
	bool		operator >= ( cstr_t s ) const { return Compare(s)>=0; }
	bool		operator != ( cstr_t s ) const { return Compare(s)!=0; }
	// Query
	bool		IsLike( cstr_t pPattern ) const { return str_IsLike(c_str(),pPattern); }
	bool		IsEmpty() const				{ return !pChar || !pChar[0]; }
	int			Length() const				{ return pChar?_tcslen(pChar):0; }
	inline int	MaxLength()					{ return Length(); }
	char_t		Char( const int i ) const;				// return int if UTF8?
	char_t		CharR( const int i =0 ) const;			// return int if UTF8?
	char_t		Peek() const;							// return int if UTF8?
	DynString	Left( const int c ) const		{ return DynString(c_str(),c); }
	DynString	Skip( const int c ) const		{ assert(c>=0&&c<=Length()); return DynString(pChar+c); }
	DynString	Right( const int c ) const;
	bool		Contains( cstr_t s ) const		{ return _tcsstr(c_str(),s)!=NULL; }
	int			Pos( cstr_t ) const;
	int			PosOfAny( cstr_t tokens ) const;
	int			Pos( int c ) const;
	int			PosR( int c ) const;
	DynString	Clone() const					{ return DynString(*this); }
	DynString	UpperCase() const				{ return Clone().ToUpper(); }
	DynString	LowerCase() const				{ return Clone().ToLower(); }
	DynString	Trimmed() const					{ return Clone().Trim(); }
	DynString	SubString( int i, int c ) const { assert(i>=0); return DynString(pChar+i,c); };
	long		ToInt( long def =0 ) const		{ return str_ToInt(c_str(),def); }	// Convert to int (hex & dec)
	double		ToFloat( double def =0.0 ) const{ return str_ToFloat(c_str(),def); }
	bool		Prefix( cstr_t s ) const		{ return str_Prefix(c_str(),s); }		// Detect prefix
	// Modification 
//	DynString&	Reverse()			{ if (pChar) _tcsrev( pChar ); return (*this); }
	DynString&	ToUpper()			{ if (pChar) _tcsupr( pChar ); return (*this); }
	DynString&	ToLower()			{ if (pChar) _tcslwr( pChar ); return (*this); }
	DynString&	Crop( int len )		{ return SetLength(Length()-len); }		// Decrease length by ..
	DynString&	Delete( int index, int count =1 ) { if (pChar) str_Delete(pChar,index,count);  return *this; }
	int			Replace( cstr_t find, cstr_t repl );		// SLOW
	int			Replace( int find, char_t repl ) { return pChar?str_Replace(pChar,find,repl):0; }
	DynString&	Trim()			{ return TrimLeft().TrimRight(); }
	DynString&	TrimLeft()		{ if (pChar) str_TrimLeft(pChar); return *this; }
	DynString&	TrimRight()		{ if (pChar) str_TrimRight(pChar); return *this; }
	bool		DelPrefix( cstr_t s )		{ return pChar?str_DelPrefix(pChar,s):false; }	// Detect & delete prefix
	long		DelInt( long def =0 )		{ return pChar?str_DelInt(pChar,def):def; }		// Detect & delete integer
	double		DelFloat( double def =0.0 ) { return pChar?str_DelFloat(pChar,def):def; }	// Detect & delete floating point
	String		DelWord()					{ String s; if (pChar) str_DelWord(pChar,s); return s; }// Detect & delete word
	char_t		Pop();									// return int if UTF8?
private:
	char_t		*pChar;
};
///////////////////////////////////////////////////////////////////////////////
inline char_t DynString::Char( const int i ) const 
{ 
	return _smaller(i,Length())?pChar[i]:0; 
}
///////////////////////////////////////////////////////////////////////////////
inline char_t DynString::CharR( const int i ) const 
{ 
	int l=Length(); 
	return _smaller(i,l)?pChar[l-i-1]:0; 
}
///////////////////////////////////////////////////////////////////////////////
inline char_t DynString::Peek() const 
{ 
	int l=Length(); 
	return l?pChar[l-1]:0; 
}
///////////////////////////////////////////////////////////////////////////////
inline char_t DynString::Pop() 
{ 
	int l = Length(); 
	if (!l) 
		return 0; 
	char_t c = pChar[--l]; 
	pChar[l]=0; 
	return c; 
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
inline char_t* DynString::Realloc( const int i )	
{ 
	assert( i>0 );
	pChar = (char_t*)realloc( pChar, (i+1)*sizeof(char_t) ); 
	pChar[i] = 0;				// terminate
	return pChar;
}
///////////////////////////////////////////////////////////////////////////////
inline char_t* DynString::Alloc( const int i )		
{ 
	assert( i>0 );
	free(pChar); 
	pChar = (char_t*)malloc( (i+1)*sizeof(char_t) ); 
	pChar[i] = 0;				// terminate
	return pChar;
}
///////////////////////////////////////////////////////////////////////////////
inline char_t* DynString::Detach()			
{ 
	char_t *p=pChar; 
	pChar=NULL; 
	return p; 
}
///////////////////////////////////////////////////////////////////////////////
inline DynString& DynString::Attach( char_t* p )	
{ 
	free(pChar); 
	pChar=p; 
	return (*this); 
}
///////////////////////////////////////////////////////////////////////////////
inline DynString& DynString::Attach( DynString &s )	
{ 
	Attach( s.Detach() );
	return (*this); 
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
inline DynString& DynString::SetAt( const int pos, char_t c )// MFC compatible
{
	if (_smaller(pos,Length()))
		pChar[pos] = c;
	return *this;
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
inline DynString operator + ( cstr_t s, const DynString &t ) 
{
	return DynString( s, t.c_str() ); 
}
///////////////////////////////////////////////////////////////////////////////
inline DynString operator + ( const String &s, const DynString &t ) 
{
	return DynString( s.c_str(), t.c_str() ); 
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#undef CONCAT										// from citkt_String.h
#define CONCAT(s1,s2)		DynString(s1,s2)		// concatenate two strings (fast)
#define CONCAT3(s1,s2,s3)	DynString(s1,s2,s3)		// concatenate three strings (fast)
///////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_DYNSTRING_H_INCLUDED
///////////////////////////////// [citkt_DynString.h] END
///////////////////////////////// [citkt_UniqueID.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
#ifndef CITKT_UNIQUEID_H_INCLUDED
#define CITKT_UNIQUEID_H_INCLUDED
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citkt_HashTable.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#ifndef CITKT_HASHTABLE_H_INCLUDED
#define CITKT_HASHTABLE_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
///////////////////////////////////////////////////////////////////////////////
typedef ulong_ptr hash_t;
typedef void* hashptr_t;
///////////////////////////////////////////////////////////////////////////////
class DHashTableHelper
{
public:
	// Get the array index for a specific hash-value
	inline int		GetHash( const hash_t hv ) const { hash_t mul=hv*MagicNumber; return mul>>__shift; }
	// Inspect number of items in this container
	inline bool		IsEmpty() const { return NumItems==0; }
	inline int		Count() const { return NumItems; }
	// Number of allocated slots.
	// Use together with operator [] to iterate all items.
	inline int		MaxCount() const { return MaxItems; }
	// Gets the maximum deviation (the bigger, the slower)
	inline int		GetDistance() const { return Distance; }
	// Set the factor for allocation (determines when to grow the array)
	inline int		SetFactor( const int f ) { return __factor = f>0?f:1; }
protected:
	// Some constants
	enum {
		HASHTABLE_FACTOR = 1,					// 50% density
		HASHTABLE_INIT_SIZE = 32
	};
	struct _hashslot_t
	{
		hash_t		hash;
		hashptr_t	ptr;
	};
	typedef _hashslot_t* phashslot_t;
	DHashTableHelper( hashptr_t invalid_ptr ) : _free_ptr(invalid_ptr),
		 Distance(0), NumItems(0), MaxItems(0), __factor(HASHTABLE_FACTOR) { }
	DHashTableHelper( hashptr_t invalid_ptr, phashslot_t &Data ) : _free_ptr(invalid_ptr),
		 __factor(HASHTABLE_FACTOR) { _Reserve(Data=NULL,HASHTABLE_INIT_SIZE); }
	int				NumItems, MaxItems, Distance;
	int				__shift, __mask, __factor;
	hashptr_t		_free_ptr;	// a ptr-value that's never valid
	hashptr_t		_Remove( phashslot_t, const hash_t );
	void			_Empty( phashslot_t );
	void			_Add( phashslot_t&, const hash_t, hashptr_t );
	hashptr_t		_SetNo( phashslot_t&, const hash_t, hashptr_t );// returns old ptr
	hashptr_t		_Find( phashslot_t, const hash_t ) const;
	hashptr_t		_FindNext( phashslot_t, const hash_t, int& ) const;
	bool			_SetInvalid( phashslot_t, hashptr_t );
	void			_Reserve( phashslot_t&, const int );
	void			_Grow( phashslot_t& );
	hashptr_t		_RemoveIndex( phashslot_t, const int i );	// by index
	bool			_RemovePtr( phashslot_t, hashptr_t );		// by ptr
private:
	static const hash_t	MagicNumber;								// ((sqrt(5)-1)/2)<<32
	void			__Add( phashslot_t, const hash_t, hashptr_t );
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
template <class T, class _V=hash_t>
class DHashTable : public DHashTableHelper
{
public:
	// Default constructor
	DHashTable( T* invalid_ptr =NULL ) : DHashTableHelper(invalid_ptr), Data(NULL) { }
	// Copy constructor
	DHashTable( const DHashTable<T,_V>& );
	// Destructor
	~DHashTable() { delete [] Data; }
	// Add a value-object pair.
	// If this hash-value is already present, it will be overwritten.
	// Returns the previous pointer associated with the hash-value.
	T*			SetNo( const _V h, T* o )				{ return (T*)_SetNo(_Data,(hash_t)h,o); }
	// Adds a hashed-pair (regardless or the presence of hash-value)
	void		Add( const _V h, T* o )					{ _Add(_Data,(hash_t)h,o); }
	// Finds an object identified by the hash-value.
	// Returns '_free_ptr' (NULL) if not found.
	T*			Find( const _V h ) const				{ return (T*)_Find(_Data,(hash_t)h); }
	T*			GetNo( const _V h) const				{ return Find((hash_t)h); }
	bool		Contains( const _V h ) const			{ return _Find(_Data,(hash_t)h)!=_free_ptr; }
	// Remove a hashed-pair.
	// Returns the associated object or '_free_ptr' if not found.
	T*			Remove( const _V h )					{ return (T*)_Remove(_Data,(hash_t)h); }
	// Reserve space for specified numfer of items (discards contents)
	void		Reserve( const int i )					{ _Reserve(_Data,i); }
	
	// Mark all slots as free (does not free memory)
	void		Empty()									{ _Empty(_Data); }	
	// Removes all pairs and frees all memory
	void		RemoveAll();
	// Like Remove/RemoveAll but also 'delete' any objects
	bool		Delete( const _V h );
	void		DeleteAll();		// empty + 'delete' objects
	// Set the ptr-value used to identify free slots (NULL)
	bool		SetInvalid( T* invalid )				{ _SetInvalid(_Data,invalid); }
	T*			GetInvalid() const						{ return (T*)_free_ptr; }
	//! Grow the array by a factor 2. (SLOW)
	// Example: while (hash.GetDistance()>8) hash.Grow();
	void		Grow()									{ _Grow(_Data); }
	//! Iteration (like old hash table)
	T*			First( hash_t &iter ) const				{ return Next( iter=0 ); }
	T*			Next( hash_t &iter ) const;
	//! Iteration through multiple items with same value (_free_ptr if done).
	T*			FindNext( const _V v, int &i ) const	{ return (T*)_FindNext(_Data,v,i); }
	//! Direct array access (ArrayPtr compatible; INPUT NOT CHECKED)
	T*			operator [] ( const int i ) const		{ return Data[i].ptr; }
	_V			operator () ( const int i ) const		{ return Data[i].hash; }
	//! Remove a hashed pair by index into array (NOT by hash)
	T*			RemoveIndex( const int i )				{ return (T*)_RemoveIndex(_Data,i); }
	//! Remove a hashed pair by pointer value (SLOW)
	bool		RemovePtr( T* ptr )						{ return _RemovePtr(_Data,ptr); }
private:
	struct hashslot_t
	{
		_V		hash;
		T*		ptr;
	};
	union {
		hashslot_t*		Data;
		_hashslot_t*	_Data;			// same struct, but with void*
	};
	// static assertion to make sure the size of the structure is valid
	static_assert( sizeof(_V)==sizeof(hash_t) );
	// Forbidden operator = (implement and change this comment if you need it)
	void		operator = ( const DHashTable<T,_V>& );
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
template <class T, class _V>
DHashTable<T,_V>::DHashTable( const DHashTable<T,_V> &copy ) : DHashTableHelper(copy)
{
	Data = NULL;
	if (MaxItems)
	{
		// Copy slots
		Data = new hashslot_t[MaxItems];
		memcpy( Data, copy.Data, sizeof(hashslot_t)*MaxItems );
	}
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
template <class T, class _V>
bool DHashTable<T,_V>::Delete( const _V hv )
{
	T* c = Remove((hash_t)hv);
	if (c==(T*)_free_ptr)
		return false;
	delete c;
	return true;
}
///////////////////////////////////////////////////////////////////////////////
template <class T, class _V>
void DHashTable<T,_V>::RemoveAll()
{
	delete [] Data;
	Data = NULL;
	MaxItems = NumItems = Distance = 0;
}
///////////////////////////////////////////////////////////////////////////////
template <class T, class _V>
void DHashTable<T,_V>::DeleteAll()
{
	for (int t=0;t<MaxItems;t++)
		if (Data[t].ptr != (T*)_free_ptr)
			delete Data[t].ptr;
	RemoveAll();
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
template <class T, class _V>
T* DHashTable<T,_V>::Next( hash_t &iter ) const
{
	// Find next non-free slot
	for (;(int)iter<MaxItems;iter++)
		if (Data[iter].ptr != (T*)_free_ptr)
			return Data[iter++].ptr;
	return (T*)_free_ptr;
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_HASHTABLE_H_INCLUDED
///////////////////////////////// [citkt_HashTable.h] END
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class DUniqueID
{
public:
	//! Static (invalid) ID
	static const DUniqueID	Null;
	//! Default constructor (defaults to Null)
	DUniqueID()										{ Clear(); }
//	DUniqueID( const DUniqueID& );			// generated by compiler
	// Operators:
	bool operator == ( const DUniqueID& r ) const	{ return Equals(r); }
	bool operator != ( const DUniqueID& r ) const	{ return !Equals(r); }
		 operator bool () const						{ return IsValid(); }
	bool operator ! () const						{ return !IsValid(); }
	// Methods:
	DUniqueID&	Create();					// platform dependent
	DUniqueID&	Clear()								{ memset(uuid,0,sizeof uuid); return *this; }
	bool		Equals( const DUniqueID& r ) const	{ return memcmp(uuid,r.uuid,sizeof uuid)==0; } 
	bool		IsValid() const						{ return !Equals(Null);	}
	hash_t		GetHash() const;
	String		ToString() const;
	bool		FromString( cstr_t );
	void*		GetData() const						{ return (void*)uuid; }
	int			GetDataSize() const					{ return sizeof(uuid); }
private:
	unsigned char	uuid[16];
};
/////////////////////////////////////////////////////////////////////////////
typedef DUniqueID			uid_t;
typedef const DUniqueID&	cuid_t;
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_UNIQUEID_H_INCLUDED
///////////////////////////////// [citkt_UniqueID.h] END
namespace citkTypes {
////////////////////////////////////////////////////////////////////////////////
// generic hash class (for basic types)
template <typename KEY>
struct DefHasher
{
	static hash_t	hash( const KEY &key )					{ return (hash_t)key; }
	static int		compare( const KEY& k1, const KEY& k2 )	{ return memcmp(&k1,&k2,sizeof(KEY));}
};
template<>
struct DefHasher<cstr_t>
{
	static hash_t	hash( cstr_t key )			{ return str_Hash(key); }
	static int		compare( cstr_t k1, cstr_t k2 )		{ return _tcscmp(k1,k2); }
};
template<>
struct DefHasher<DUniqueID>
{
	static hash_t	hash( const DUniqueID &key )	{ return key.GetHash(); }
	static int		compare( const DUniqueID &k1, const DUniqueID &k2 )	{ return memcmp(&k1,&k2,sizeof(DUniqueID)); }
};
template<>
struct DefHasher<String>
{
	static hash_t	hash( const String &key )		{ return str_Hash(key); }
	static int		compare( const String &k1, const String &k2 )	{ return _tcscmp(k1,k2); }
};
template<>
struct DefHasher<DynString>
{
	static hash_t	hash( const DynString &key )	{ return str_Hash(key); }
	static int		compare( const DynString &k1, const DynString &k2 )	{ return _tcscmp(k1.c_str(),k2.c_str()); }
};
////////////////////////////////////////////////////////////////////////////////
//! Associated array template class; T is the value, KEY is the key
template <typename T, typename KEY, typename H =DefHasher<KEY> >
class AArray
{
	static uint _calclog( int x ) { uint l=INIT_SIZE_LOG2; while((AUTOGROW_FACTOR<<l) < x) ++l; return l; }
public:
	// Some constants
	enum {
		ZERO = 0,
		GROWBY_LOG2 = 2,
		AUTOGROW_FACTOR = 4,					// == numitems / Count
		INIT_SIZE_LOG2 = 5,						// 32*4
		MAGICNUMBER = 0x9E3779B9				// ((sqrt(5)-1)/2)<<32
	};
	// By default you can put (1<<INIT_SIZE_LOG2)*AUTOGROW_FACTOR numitems in the hash without resize
	AArray() : pairs(1<<INIT_SIZE_LOG2), _shift(32-INIT_SIZE_LOG2), numitems(0), _hashcollisions(0) { 
		if (!ZERO) pairs.Fill(null);  
	}
	explicit AArray(uint len) : _shift(32-_calclog(len)), pairs(1<<(32-_shift)), numitems(0), _hashcollisions(0) { 
		if (!ZERO) pairs.Fill(null);  
	}
	// copy-constructor
	explicit AArray( const AArray<T,KEY,H> &aa ) : _shift(aa._shift), pairs(1<<(32-_shift)), numitems(0), _hashcollisions(0) {
		if (!ZERO) pairs.Fill(null);  
		AddFrom(aa);
	}
	// destructor
	~AArray() { Empty(); }
	bool	Contains( const KEY& k ) const {
		bucket_t **pp = _FindBucket(k);
		return *pp != null;
	}
	T*		In( const KEY& k ) const {
		bucket_t **pp = _FindBucket(k);
		return *pp?&(*pp)->value:null;
	}
	T&		Add( const KEY& k ) { 
		T* ptr;
		Add(k,&ptr);
		return *ptr;
	}
	bool	Add( const KEY& k, T** ppv ) { 
		hash_t h = H::hash(k);
		bucket_t **pp = _FindBucket(k,h);
		bucket_t *p = *pp;
		if (!p) {
			*pp = p = new bucket_t(h,k);
			++numitems;
			// resize and rehash when too many
			if (AUTOGROW_FACTOR*length(pairs) < numitems)
				_Reserve( GROWBY_LOG2+32-_shift );
			*ppv = &p->value;
			return true;
		}
		else {
			*ppv = &p->value;
			return false;
		}
	}
	void	Empty() {
		foreach(p,pairs)
			if (pairs[p]) {
				// TODO: could use destruction by rotation (faster)
				_recurse_foreach(pairs[p], _foreach_d(this,&AArray::_delete) );
				pairs[p] = null;
			}
		// TODO: minimize the pairs array?
		_hashcollisions = numitems = 0;
	}
	bool	Remove( const KEY& k ) {
		bucket_t** pp = _FindBucket(k);
		if (*pp)
		{
			_Remove( pp );
			return true;
		}
		else
			return false;
	}
	bool	Remove( const KEY& k, T& oldval ) {
		bucket_t** pp = _FindBucket(k);
		if (*pp) {
			oldval = (*pp)->value;
			_Remove( pp );
			return true;
		}
		else
			return false;
	}
	T& operator [] (const KEY &k)				{ return Add(k); }
	const T& operator [] (const KEY &k) const	{ T* p=In(k); assert(p); return *p; }
	void operator = ( const AArray<T,KEY,H> &aa ) { CopyFrom(aa); }
	typedef delegate<bool(const KEY&)> foreachkey_d;
	bool ForEachKey( foreachkey_d dg ) const {
		foreach(p,pairs)
			if (pairs[p])
				if (!recurse_foreachkey(pairs[p],dg))
					return false;
		return true;
	}
	typedef delegate<bool(T&)> foreachvalue_d;
	bool ForEachValue( foreachvalue_d dg ) const {
		foreach(p,pairs)
			if (pairs[p])
				if (!recurse_foreachvalue(pairs[p],dg))
					return false;
		return true;
	}
	typedef delegate<bool(T&,const KEY&)> foreach_d;
	bool ForEach( foreach_d dg ) const {
		foreach(p,pairs)
			if (pairs[p])
				if (!recurse_foreach(pairs[p],dg))
					return false;
		return true;
	}
	uint	Count() const { return numitems; }
	bool	IsEmpty() const { return numitems==0; }
	void	Reserve( uint len ) {
		uint log2 = _calclog(len);
		if ((1<<log2) != pairs.Count())
			_Reserve( log2 );
	}
	void CopyFrom( const AArray<T,KEY,H> &aa ) {
		Empty();
		AddFrom(aa);
	}
	void AddFrom( const AArray<T,KEY,H> &aa ) {
		uint countbefore = numitems;
		// Reserve room for the extra items
		Reserve( countbefore+aa.Count() );
		aa._foreach( _foreach_d(this,&AArray::_copy) );
		assert( (countbefore+aa.Count()) == numitems );
	}
	template <int A>
	void AddKeysTo( Array<const KEY*,A> &ids ) const {
		if (numitems == 0) return;
		uint c = ids.Count();
		ids.SetCount( numitems+c );
		_keysp<A> o( &ids[c] );
		ForEach( foreach_d(&o,&_keysp<A>::append) );
	}
	template <int A>
	void AddKeysTo( Array<KEY,A> &ids ) const {
		if (numitems == 0) return;
		uint c = ids.Count();
		ids.SetCount( numitems+c );
		_keys<A> o( &ids[c] );
		ForEach( foreach_d(&o,&_keys<A>::append) );
	}
/*
	_dynarray<const KEY*>	GetKeysPtr() const { 
		_keysp k(numitems);
		_foreach( pairs, _foreach_d(&k,&_keysp::append) );
		assert(k.numitems==numitems);
		return k.keyptrs;
	}
	_dynarray<KEY>	GetKeys() const { 
		_keys k(numitems);
		_foreach( pairs, _foreach_d(&k,&_keys::append) );
		assert(k.numitems==numitems);
		return k.keys;
	}
	_dynarray<T*>	GetValuesPtr() const { 
		_valuesp v(numitems);
		_foreach( pairs, _foreach_d(&v,&_valuesp::append) );
		assert(v.numitems==numitems);
		return v.valuesp;
	}
	_dynarray<T>	GetValues() const { 
		_values v(numitems);
		_foreach( pairs, _foreach_d(&v,&_values::append) );
		assert(v.numitems==numitems);
		return v.values;
	}
*/
	// DHashTable<> compatiblity
	T*		GetPtr( const KEY &k ) const { return In(k); }
	void	Set( const KEY &k, const T& v ) { Add(k) = v; }
protected:
	uint	_shift, numitems;
	mutable	uint	_hashcollisions;			// for stats only
	uint	_IndexOfHash( hash_t hv ) const { hash_t mul=hv*MAGICNUMBER; return mul>>_shift; }
	struct bucket_t {
		bucket_t(hash_t h, const KEY &k ) : hash(h), key(k) { child[0]=child[1]=null; }
		bucket_t(hash_t h, const KEY &k, const T& v ) : hash(h), key(k), value(v) { child[0]=child[1]=null; }
		bucket_t*	child[2];
		hash_t		hash;
		KEY			key;							// optional
		T			value;
	};
	typedef delegate<bool(bucket_t*)> _foreach_d;
	bool _copy( bucket_t *cp ) {
		bucket_t **pp = _FindBucket(cp->key,cp->hash);
		assert(pp && !*pp);
		*pp = new bucket_t(cp->hash,cp->key,cp->value);
		++numitems;
		// should never have to grow during a copy operation (reserved before)
		assert(AUTOGROW_FACTOR*length(pairs) >= numitems);
		return true;
	}
	bool _delete(bucket_t *p) { 
		delete p; 
		return true;
	}
	bool _rehash(bucket_t* op) {
		assert(op);
		bucket_t **pp = _FindBucket( op->key, op->hash );
		assert(pp);
		*pp = op;
		op->child[0] = op->child[1] = null;
		return true;
	}
/*
	struct _valuesp {
		dynarray<T*> valuesp;
		uint numitems;
		_valuesp(uint s) : valuesp(s), numitems(0) {}
		bool append(bucket_t*p) {
			valuesp[numitems++] = &p->value;
			return true;
		}
	};
	struct _values {
		dynarray<T> values;
		uint numitems;
		_values(uint s) : values(s), numitems(0) {}
		bool append(bucket_t*p) {
			values[numitems++] = p->value;
			return true;
		}
	};
*/
	template <int A>
	struct _keysp {
		const KEY** keyptrs;
		_keysp(const KEY** s) : keyptrs(s) {}
		bool append(T&, const KEY& key) {
			*keyptrs++ = &key;
			return true;
		}
	};
	template <int A>
	struct _keys {
		KEY* keys;
		_keys(KEY* s) : keys(s) {}
		bool append(T&, const KEY& key) {
			*keys++ = key;
			return true;
		}
	};
	static bool _recurse_foreach( bucket_t *p, _foreach_d dg ) {
		assert(p);
		bucket_t* pleft  = p->child[0];
		bucket_t* pright = p->child[1];
		if (!dg(p))
			return false;
		if (pleft)
			if (!_recurse_foreach(pleft,dg))
				return false;
		if (pright)
			if (!_recurse_foreach(pright,dg))
				return false;
		return true;
	}
	static bool recurse_foreachkey( bucket_t *p, foreachkey_d dg ) {
		assert(p);
		bucket_t* pleft  = p->child[0];
		bucket_t* pright = p->child[1];
		if (!dg(p->key))
			return false;
		if (pleft)
			if (!recurse_foreachkey(pleft,dg))
				return false;
		if (pright)
			if (!recurse_foreachkey(pright,dg))
				return false;
		return true;
	}
	static bool recurse_foreachvalue( bucket_t *p, foreachvalue_d dg ) {
		assert(p);
		bucket_t* pleft  = p->child[0];
		bucket_t* pright = p->child[1];
		if (!dg(p->value))
			return false;
		if (pleft)
			if (!recurse_foreachvalue(pleft,dg))
				return false;
		if (pright)
			if (!recurse_foreachvalue(pright,dg))
				return false;
		return true;
	}
	static bool recurse_foreach( bucket_t *p, foreach_d dg ) {
		assert(p);
		bucket_t* pleft  = p->child[0];
		bucket_t* pright = p->child[1];
		if (!dg(p->value,p->key))
			return false;
		if (pleft)
			if (!recurse_foreach(pleft,dg))
				return false;
		if (pright)
			if (!recurse_foreach(pright,dg))
				return false;
		return true;
	}
	bool _foreach( _foreach_d dg ) const {
		foreach(p,pairs)
			if (pairs[p])
				if (!_recurse_foreach(pairs[p],dg))
					return false;
		return true;
	}
	ArrayPtr<bucket_t>	pairs;
	void _Reserve( uint log2 ) {
		assert(log2>=INIT_SIZE_LOG2 && log2<32);
		assert( (1<<log2) != pairs.Count() );
		uint oldnodes = numitems;
		ArrayPtr<bucket_t> oldpairs;
		oldpairs.AttachData( pairs );
		_shift = 32 - log2;
		pairs.SetCount( 1<<log2 );
//		pairs.set_Length( 1<<log2 );
		if (!ZERO) pairs.Fill(null);
		foreach(p,oldpairs)
			if (oldpairs[p])
				_recurse_foreach( oldpairs[p], _foreach_d(this,&AArray::_rehash) );
		assert( oldnodes==numitems );
	}
	void	_Remove( bucket_t **pp ) 
	{
		assert(pp && *pp);
		bucket_t* pleft  = (*pp)->child[0];
		bucket_t* pright = (*pp)->child[1];
		delete *pp;
		*pp = null;
		--numitems;
		if (pleft)
			*pp = pleft;
		if (pright) {
			if (pleft) {
				// pright should be on the child[1]; find a free spot
				pp = &pleft->child[1];
				while (*pp)
					pp = &((*pp)->child[1]);
			}
			*pp = pright;
		}
	}
	bucket_t**	_FindBucket( const KEY& k ) const {
		hash_t h = H::hash(k);
		return _FindBucket(k,h);
	}
	bucket_t**	_FindBucket( const KEY& k, hash_t h ) const {
		uint i = _IndexOfHash(h);
//		assert( pairs.ContainsNo(i) );
		bucket_t** pp = &pairs[i];
		while (*pp) {
			int cmp = (*pp)->hash < h;
			if ((*pp)->hash == h) {
				// the hashes match; now compare the actual keys (optional)
				cmp = H::compare( (*pp)->key, k );
				if (cmp == 0)
					break;
				cmp = (cmp < 0);
				++_hashcollisions;
			}
			assert( cmp==0 || cmp==1 );
			pp = &(*pp)->child[cmp];
		}
		assert(pp);
		return pp;
	}
/*
	static void	recurse_RemoveAll( bucket_t *p ) {
		if (p->child[0])
			recurse_RemoveAll(p->child[0]);
		if (p->child[1])
			recurse_RemoveAll(p->child[1]);
		delete p;
	}
*/
	static void _assert( bucket_t *p1, bucket_t *p2 ) {
		assert(p1 != p2 );
		int64 diff = p1->hash - p2->hash;
		if (diff==0)
			assert( compare(p1->key,p2->key)>0 );
		else
			assert( diff > 0 );
	}
	static uint recurse_assert( bucket_t *p ) {
		uint i=1;
		assert(p);
		if (p->child[0]) {
			_assert( p, p->child[0] );
			i += recurse_assert(p->child[0]);
		}
		if (p->child[1]) {
			_assert( p->child[1], p );
			i += recurse_assert(p->child[1]);
		}
		return i;
	}
};
////////////////////////////////////////////////////////////////////////////////
}//namespace citkTypes
///////////////////////////////// [citkt_AArray.h] END
///////////////////////////////// [citkt_Array2D.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
//		Container, uitgevoerd als resizing array
//
#ifndef	CITKT_ARRAY2D_H_INCLUDED
#define	CITKT_ARRAY2D_H_INCLUDED
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
///////////////////////////////////////////////////////////////////////
template <class T>
class Array2D
{
public:
	// Constructors:
	Array2D();
	Array2D( uint, uint );
	Array2D( uint, uint, const T );
	Array2D( uint, uint, T* const );
	Array2D( const Array2D<T>& );
	// Destructor:
	~Array2D();
	// Methods:
	void		Fill( const T );
	bool		Create( uint, uint );
	bool		Create( uint, uint, const T );
	bool		Create( const Array2D<T>& );
	bool		Attach( uint, uint, T* const );
	bool		Attach( Array2D<T>& );						// detaches the other
	void		Free();
	T			GetSafe( uint, uint ) const;			// checks the input
	T			SetSafe( uint, uint, T const );			// checks the input
	T&			GetRef( uint x, uint y ) {			 return Lines[y][x]; }
	T			Get( uint x, uint y ) const			{ return Lines[y][x]; }
	T			Set( uint x, uint y, T const c )	{ return Lines[y][x]=c; }
	T&			GetRefC( uint x )						{ return Data[x]; }
	T			GetC( uint x ) const					{ return Data[x]; }
	T			SetC( uint x, T const c )				{ return Data[x]=c; }
	T*			Detach();
	T*			GetData() const							{ return Data; }
	T**			GetLines() const						{ return Lines; }
	uint		GetSizeX() const						{ return X; }
	uint		GetSizeY() const						{ return Y; }
	void		Resize( uint, uint );
	void		Resize( uint, uint, const T fill_em_up );
	uint		GetCount() const						{ return X*Y; }
	uint		GetStride() const						{ return sizeof(T)*X; }
	uint		GetDataSize() const						{ return GetStride()*Y; }
	bool		IsEmpty() const							{ return Data==NULL; }
	bool		Contains( uint x, uint y ) const	{ return x<X && y<Y; }
	T			operator () ( uint x, uint y ) const {  return Get(x,y); }
	operator T* () const { return Data; }
	T*			operator [] ( int x ) const				{ return Lines[x]; }	// CAREFULL
private:
	uint	X, Y;
	T*		Data;
	T**		Lines;
	void		_Attach( uint, uint, T* const );
};
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T>
Array2D<T>::Array2D()
{
	X=Y=0;
	Data = NULL;
	Lines = NULL;
}
///////////////////////////////////////////////////////////////////////
template <class T>
Array2D<T>::Array2D( uint x, uint y )
{
	Data = NULL;
	Lines = NULL;
	Create( x, y );
}
///////////////////////////////////////////////////////////////////////
template <class T>
Array2D<T>::Array2D( uint x, uint y, const T c )
{
	Data = NULL;
	Lines = NULL;
	Create( x, y, c );
}
///////////////////////////////////////////////////////////////////////
template <class T>
Array2D<T>::Array2D( uint x, uint y, T* const dat )
{
	Data = NULL;
	Lines = NULL;
	Attach( x, y, dat );
}
///////////////////////////////////////////////////////////////////////
template <class T>
Array2D<T>::Array2D( const Array2D<T> &ar )
{
	Data = NULL;
	Lines = NULL;
	Create( ar );
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T>
Array2D<T>::~Array2D()
{
	Free();
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T>
void Array2D<T>::_Attach( uint x, uint y, T* const dat )
{
	// Private call: We can assume x>0, y>0 and dat!=NULL
	X = x;
	Y = y;
	Data = dat;
	Lines = new T*[ Y ];
	T* ptr = Data;
	for (uint q=0; q<Y; q++)
	{
		Lines[q] = ptr;
		ptr += X;
	}
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T>
bool Array2D<T>::Create( uint x, uint y )
{
	Free();
	if (x<=0 || y<=0)
		return false;
	T* dat = new T[ x * y ];
	_Attach ( x, y, dat );
	return true;
}
///////////////////////////////////////////////////////////////////////
template <class T>
bool Array2D<T>::Create( uint x, uint y, const T c )
{
	if (!Create( x, y ))
		return false;
	Fill( c );
	return true;
}
///////////////////////////////////////////////////////////////////////
template <class T>
bool Array2D<T>::Create( const Array2D<T> &ar )
{
	if (!Create( ar.GetSizeX(), ar.GetSizeY() ))
		return false;
	memcpy( (void*)Data, (void*)ar.GetData(), ar.GetDataSize() );
	return true;
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T>
bool Array2D<T>::Attach( uint x, uint y, T* const dat )
{
	Free();
	if (x<=0 || y<=0 || !dat)
		return false;
	_Attach ( x, y, dat );
	return true;
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T>
bool Array2D<T>::Attach( Array2D<T> &other )
{
	Free();
	if (other.IsEmpty())
		return false;
	// Save x and y first, Detach will set them to 0
	uint x = other.GetSizeX();
	uint y = other.GetSizeY();
	_Attach ( x, y, other.Detach() );
	return true;
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T>
void Array2D<T>::Free()
{
	delete [] Lines;
	Lines = NULL;
	delete [] Data;
	Data = NULL;
	X = 0;
	Y = 0;
}	
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T>
void Array2D<T>::Fill( const T c )
{
	for (uint t=0;t<GetCount();t++)
		Data[t] = c;
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T>
T* Array2D<T>::Detach()
{
	T *dat = Data;
	Data = NULL;
	Free();
	return dat;
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T>
T Array2D<T>::GetSafe( uint x, uint y ) const
{
	if (Contains(x,y))
		return Lines[y][x];
	return T();
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T>
T Array2D<T>::SetSafe( uint x, uint y, T const c )
{
	if (Contains(x,y))
		Lines[y][x] = c;
	return c;
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T>
void Array2D<T>::Resize( uint x, uint y )
{
	if (x==X && y==Y)
		return;
	if (x<=0 || y<=0)
	{
		Free();
		return;
	}
	if (X<=0 || Y<=0)
	{
		Create( x, y );
		return;
	}
	T** lin = Lines;
	Lines = NULL;
	uint _x = _min(x,X);		//	must be done before Detach()!
	uint _Y = _min(y,Y);
	T* dat = Detach();
	
	Create( x, y );
	for (uint yy=0;yy<_Y;yy++)
		for (uint xx=0;xx<_x;xx++)
			Lines[yy][xx] = lin[yy][xx];
	delete [] lin;
	delete [] dat;
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T>
void Array2D<T>::Resize( uint x, uint y, const T fill_em_up )
{
	if (x==X && y==Y)
		return;
	if (x<=0 || y<=0)
	{
		Free();
		return;
	}
	if (X<=0 || Y<=0)
	{
		Create( x, y, fill_em_up );
		return;
	}
	T** lin = Lines;
	Lines = NULL;
	uint _x = _min(x,X);		//	must be done before detach
	uint _Y = _min(y,Y);
	T* dat = Detach();
	
	Create( x, y, fill_em_up );
	for (uint yy=0;yy<_Y;yy++)
		for (uint xx=0;xx<_x;xx++)
			Lines[yy][xx] = lin[yy][xx];
	delete [] lin;
	delete [] dat;
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_ARRAY2D_H_INCLUDED
///////////////////////////////// [citkt_Array2D.h] END
///////////////////////////////// [citkt_ArrayVal.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
//		Container, uitgevoerd als resizing array
//
#ifndef	CITKT_ARRAYVAL_H_INCLUDED
#define	CITKT_ARRAYVAL_H_INCLUDED
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T, int A =0>				// use new/delete by default
class ArrayVal : public Array<T,A>
{
public:
	// Default constructor
	ArrayVal() {}
	// Constructors:
	explicit ArrayVal( uint ni ) : Array<T,A>(ni) {}
	ArrayVal( const Array<T,0> &av ) : Array<T,A>(av) {}
	ArrayVal( const Array<T,1> &av ) : Array<T,A>(av) {}
	ArrayVal( const T* ar, uint count ) : Array<T,A>(ar,count) {}
	// For some reason, the compiler can't find the overloaded methods, redo
	T&			Add()							{ return Array<T,A>::Add(); }
	T&			Push()							{ return Array<T,A>::Add(); }
	T&			SetNo( uint i )					{ return Array<T,A>::SetNo(i); }
	T&			Insert( uint i )				{ return Array<T,A>::Insert(i); }
	// Overloaded methods (using T::operator =):
	uint		Add( T const& );					// returns index of new item
	uint		Push( T const &v )				{ return Add(v); }
	T&			SetNo( uint i, T const &v );
	T&			Insert( uint i, T const &v );
	// Search methods (using T::operator ==):
	int			FindFrom( T const&, uint ) const;
	int			Find( T const &v ) const		{ return FindFrom(v,0); }
	bool		Remove( T const& );					// can change the order
	bool		Contains( T const &d ) const	{ return Find(d)!=INVALID_ITEM; }
	// Commented (caused ambiguity for integer template type)
//	bool		MoveToTail( T const &v ) { return MoveToTail( Find(v) ); }
//	bool		MoveToHead( T const &v ) { return MoveToHead( Find(v) ); }
};
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T, int A>
uint ArrayVal<T,A>::Add( T const &d )
{
	// The provided reference may not be pointing into our array
	THIS_ASSERT( !_Contains(d), _T(": reference might be inaccessible when array grows") );
	if (NumItems >= MaxItems)
		_Larger();
	Data[NumItems] = d;					// (calls operator =)
	return NumItems++;
}
///////////////////////////////////////////////////////////////////////
template <class T, int A>
inline T& ArrayVal<T,A>::SetNo( uint i, T const &v )	
{ 
	// The provided reference may not be pointing into our array
	THIS_ASSERT( !_Contains(v), _T(": reference might be inaccessible when array grows") );
	return Array<T,A>::SetNo(i) = v;		// (calls operator =)
}
///////////////////////////////////////////////////////////////////////
template <class T, int A>
inline T& ArrayVal<T,A>::Insert( uint i, T const &v )	
{ 
	// The provided reference may not be pointing into our array
	THIS_ASSERT( !_Contains(v), _T(": reference might be inaccessible when array grows") );
	return Array<T,A>::Insert(i) = v;		// (calls operator =)
}
///////////////////////////////////////////////////////////////////////
template <class T, int A>
int ArrayVal<T,A>::FindFrom( T const &d, uint f ) const
{
	for (uint t=f; t<NumItems; t++)
		if (Data[t]==d)					// (calls operator ==)
			return t;
	return INVALID_ITEM;
}
///////////////////////////////////////////////////////////////////////
template <class T, int A>
bool ArrayVal<T,A>::Remove( T const &d )
{
	for (uint t=0; t<NumItems; t++)
		if (Data[t]==d)					// (calls operator ==)
		{
			_RemoveNo(t);
			return true;
		}
	return false;
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_ARRAYVAL_H_INCLUDED
///////////////////////////////// [citkt_ArrayVal.h] END
///////////////////////////////// [citkt_Base64.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
#ifndef CITKT_BASE64_H_INCLUDED
#define CITKT_BASE64_H_INCLUDED
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class DBase64
{
public:
	static uint	EncodedLength(uint blocklen);
	static uint	DecodedLength(uint base64len);
	//returns length of dest ('\0' is not inserted)
	static uint	Encode( const byte *block, uint blocklen, char_t *dest );
	//returns length of dest
	static uint	Decode( cstr_t base64, uint base64len, byte *dest );
	//test function
	static void unittest(); 
};
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_BASE64_H_INCLUDED
///////////////////////////////// [citkt_Base64.h] END
///////////////////////////////// [citkt_BezierCurve.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITKT_BEZIERCURVE_H_INCLUDED
#define CITKT_BEZIERCURVE_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
/*/////////////////////////////////////////////////////////////////////////////
	
	This object computes the coordinates of a bezier curve from coordinate
	cp0 to cp3 and tangent to the vector (cp1 - cp0) at cp0 and tangent to
	vector (cp3 - cp2) at cp3.
	Coordinates are retrieved by setting the bezier parameter t, 0<=0<=1,
	with t=0 resulting in cp0 and t=1 resulting in cp3.
	The object has three constructors, an empty one, one specifying the
	four control points and one specifying the start and end points, and
	the direction and length of the tangent vectors.
	Retrieving curve coordinates can be done for every coordinate in 
	separation using GetX(t), GetY(t) and GetZ(t). It is also possible 
	to retrieve a vector to a curve coordinate using GetPosition(t).
	The tangent for the curve can be retrieved using GetDirection(t).
	The t parameter is optional. If no parameter is passed the last known 
	t value will be	used. t can be set using SetT(t).
/////////////////////////////////////////////////////////////////////////////*/
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citkt_Vector3.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
//
//  vector3.hpp	3D Vector Math Class/Template
//
//	Revision log:
//		03/03/06 11:38		L. Lunesu (reverted to old cross product)
//		98/11/06 23:26		L. Lunesu
//		98/05/10 15:40		L. Lunesu
//		99/05/04 10:48		L. Lunesu (template)
//		99/16/04  9:41		L. Lunesu (5 mul cross product)
//		99/27/06  9:41		L. Lunesu (faster division)
//
#ifndef CITKT_VECTOR3_H_INCLUDED
#define CITKT_VECTOR3_H_INCLUDED
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#ifdef USE_IOSTREAM
# include <iostream>
#endif // USE_IOSTREAM
///////////////////////////////// [citkt_FastFunc.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITKT_FASTFUNC_H_INCLUDED
#define CITKT_FASTFUNC_H_INCLUDED
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// (added for Linux)
#include <math.h>
//#include <string.h>		//??
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
///////////////////////////////////////////////////////////////////////////////
#define __dtoi __ftoi			// now overloaded
///////////////////////////////////////////////////////////////////////////////
inline int __ftoi( float f ) 
{ 
	double d = f + (3i64<<51);
	return (int&)d;
}
inline int __ftoi( double d )
{ 
	d += (3i64<<51);
	return (int&)d;
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// The __ftoi and __dtoi from above actually do rounding
#define round(a)			__ftoi(a)
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#if defined(_MSC_VER) && !defined(CITK_NO_INLINE_ASM)
inline void __cdecl __fsincos( const float _a, float *_s, float *_c )
{
	// TODO: check pairing
	__asm {
		push		ecx
        fld         dword ptr [_a]
		mov 		ecx, dword ptr[_c]
        fsincos
        fstp        dword ptr [ecx]
		mov 		ecx, dword ptr[_s]
        fstp        dword ptr [ecx]
		pop			ecx
	}
}
inline void __cdecl __fsincos( const double _a, double *_s, double *_c )
{
	// TODO: check pairing
	__asm {
		push		ecx
        fld         qword ptr [_a]
		mov 		ecx, dword ptr[_c]
        fsincos
        fstp        qword ptr [ecx]
		mov 		ecx, dword ptr[_s]
        fstp        qword ptr [ecx]
		pop			ecx
	}
}
inline __int64 __cdecl __imul( int a, int b )
{
	__asm {
		mov eax, dword ptr [a]
		imul dword ptr [b]
	}
}
#else // _MSC_VER
inline void __fsincos( const float _a, float *_s, float *_c )
{
	*_s = (float)sin((double)_a);
	*_c = (float)cos((double)_a);
}
inline void __fsincos( const double _a, double *_s, double *_c )
{
	*_s = sin(_a);
	*_c = cos(_a);
}
inline int64 void __imul( int a, int b )
{
	return int64(a)*b;				// far from optimal
}
#endif // !_MSC_VER
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#ifdef _MSC_VER
//! Return a non-zero value if 'a' has its sign bit set
inline int citk_signbit( const float a )
{
	return ((int&)a)>>31;
}
//! Return a non-zero value if 'a' has its sign bit set
inline int citk_signbit( const double a )
{
	return ((int*)&a)[1]>>31;
}
inline float citk_copysign( float a, float sign )
{
	long &signb = (long&)sign;
	signb &= 1UL<<31;			// keep the sign bit
	signb |= (long&)a;			// merge the exponent and mantissa
	return sign; 
}
inline double citk_copysign( double a, double sign )
{
	__int64 &signb = (__int64&)sign;
	signb &= 1Ui64<<63;			// keep the sign bit
	signb |= (__int64&)a;		// merge the exponent and mantissa
	return sign; 
}
#endif
///////////////////////////////////////////////////////////////////////////////
//! Return the exponent (log2)
inline int _fexp( const float &a )
{
	return ((int&)a) & (0xFF<<23);			// mantissa has 23 bits, exponent 8
}
//! Return the exponent (log2)
inline int _fexp( const double &a )
{
	return ((int*)&a)[1] & (0x7FF<<20);		// mantissa has 52 bits, exponent 11
}
#undef _feqz								// from citkt_General.h
inline bool _feqz( const float &a )
{
	// compare the exponent
	return _fexp(a) <= 0x37000000;
}
inline bool _feqz( const double &a )
{
	// compare the exponent
	return _fexp(a) <= 0x3EE00000;
}
/////////////////////////////////////////////////////////////////////////////
/*
#undef _fsgn								// from citkt_General.h
template <class T>
inline T _fsgn( const float a, const T neg =-1, const T pos =1 )
{
	const T fsgn_constants[2] = {neg,pos};
	// Our signbit returns -1 for negative, 0 for positive
	return fsgn_constants[signbit(a)+1];
}
template <class T>
inline T _fsgn( const double a, const T neg =-1, const T pos =1 )
{
	const T fsgn_constants[2] = {neg,pos};
	// Our signbit returns -1 for negative, 0 for positive
	return fsgn_constants[signbit(a)+1];
}
*/
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_FASTFUNC_H_INCLUDED
///////////////////////////////// [citkt_FastFunc.h] END
#include <float.h>		// _finite
//#include <stdlib.h>
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//! Safe acos that will clip the input to -1..1
inline double safeacos(double d)
{
	if (d <= -1.0)
		return M_PI;			// asin(-1) = 180deg
	else if (d >= 1.0)
		return 0.0;				// acos(1) = 0deg
	else
		return acos( d );
}
/////////////////////////////////////////////////////////////////////////////
inline float safeacos(float f)
{
	if (f <= -1.0f)
		return M_PI;			// asin(-1) = 180deg
	else if (f >= 1.0f)
		return 0.0f;				// acos(1) = 0deg
	else
		return acos( f );
}
/////////////////////////////////////////////////////////////////////////////
//! Safe asin that will clip the input to -1..1
static inline float safeasin( float f )
{
	if (f <= -1.0f)
		return (float__t)-M_HPI;			// asin(-1) = -90deg
	else if (f >=  1.0f)
		return (float__t)M_HPI;				// asin(1) = 90deg
	else
		return asin( f );
}
/////////////////////////////////////////////////////////////////////////////
static inline double safeasin( double d )
{
	if (d <= -1.0)
		return -0.5 * M_PI;			// asin(-1) = -90deg
	else if (d >= 1.0)
		return 0.5 * M_PI;			// asin(1) = 90deg
	else
		return asin( d );
}
/////////////////////////////////////////////////////////////////////////////
class Quaternion;										// forward
class Matrix33;											// forward
class Vector3;
typedef Vector3 Normal3;
/////////////////////////////////////////////////////////////////////////////
/*
enum axis_t
{
	NaD = -1,		// not a direction
	PX,
	NX,
	PY,
	NY,
	PZ,
	NZ
};
*/
/////////////////////////////////////////////////////////////////////////////
class Vector3
{
public:
	static const Vector3	Z;
	float__t		x, y, z;
	// Constructors:
#ifdef _DEBUG
	inline Vector3() { }	// not needed in debug mode, already done by compiler
#else
	inline Vector3() { _set_nan(x); _set_nan(y); _set_nan(z); }	// will probably be optimized out
#endif
	inline Vector3( const float a[3] ) : x((float__t)a[0]), y((float__t)a[1]), z((float__t)a[2]) {}
	inline Vector3( const double a[3] ) : x((float__t)a[0]), y((float__t)a[1]), z((float__t)a[2]) {}
	inline Vector3( cfloat__t a, cfloat__t b, cfloat__t c ) : x(a), y(b), z(c) {}
//	inline Vector3( const Vector3& v ) : x(v.x), y(v.y), z(v.z) {}
	// Operators:
//	inline Vector3&		operator  = ( const Vector3& v ) { return Set(v); }
	inline Vector3&		operator += ( const Vector3& );
	inline Vector3&		operator -= ( const Vector3& );
	inline Vector3&		operator %= ( const Vector3& );			// cross-Product
	inline Vector3&		operator *= ( const Vector3& );			// scaling
	inline Vector3&		operator /= ( const Vector3& );			// scaling
	inline Vector3&		operator *= ( cfloat__t );				// scalar
	inline Vector3&		operator /= ( cfloat__t );				// scalar
	// const-Operators:
	inline Vector3		operator + ( const Vector3& ) const;
	inline Vector3		operator - ( const Vector3& ) const;
	inline Vector3		operator % ( const Vector3& v ) const { return Cross(v); }
	inline Vector3		operator * ( const Vector3& ) const;	// scaling
	inline Vector3		operator / ( const Vector3& ) const;	// scaling
	inline Vector3		operator * ( cfloat__t ) const;			// scalar (!)
	inline Vector3		operator / ( cfloat__t ) const;			// scalar
	inline double		operator ^ ( const Vector3& v ) const { return Dot(v); }
	inline Vector3		operator + () const;
	inline Vector3		operator - () const;					// flip
	inline float__t&	operator [] ( const int );				// array access [0..2]
	inline float__t		operator [] ( const int ) const;		// array access [0..2]
	// These four functions are defined in Matrix33.cpp:
	Vector3&			operator *= ( const Matrix33 & );		// transformation
	Vector3&			operator /= ( const Matrix33 & );		// back-Transformation
	Vector3				operator * ( const Matrix33 & ) const;	// transformation
	Vector3				operator / ( const Matrix33 & ) const;	// back-Transformation
	// These four functions are defined in Quaternion.cpp:
	Vector3&			operator *= ( const Quaternion & );		// transformation
	Vector3&			operator /= ( const Quaternion & );		// back-Transformation
	Vector3				operator * ( const Quaternion & ) const;// transformation
	Vector3				operator / ( const Quaternion & ) const;// back-Transformation
	// Functions:
	inline float__t		SqrLength() const;						// |v|^2
	inline float__t		Length() const;							// |v|
	inline double		Angle( const Vector3& ) const;
	inline Vector3		Diff( const Vector3& p ) const { return Vector3(x-p.x,y-p.y,z-p.z); }
	inline float__t		Distance( Vector3 const &v ) const { return Diff(v).Length(); }
	inline Vector3		Lerp( const Vector3& vec, cfloat__t t ) const { return (*this) + t*(vec - (*this)); }
	inline Vector3		Copy() const { return Vector3(*this); }
	inline Vector3&		Normalize();							// (v/=|v|)
	inline Vector3&		Flip();									// (v=-v)
	inline Normal3		Normalized() const { return Copy().Normalize(); }
	inline Vector3		Flipped() const { return Copy().Flip(); }
	inline double		Dot( const Vector3& v ) const;
	inline Vector3		Cross( const Vector3& v ) const;
	// Initialisation:
	inline Vector3&		Set( cfloat__t, cfloat__t, cfloat__t );
	inline Vector3&		Set( const float [3] );
	inline Vector3&		Set( const double [3] );
	inline Vector3&		Set( const Vector3& );
	inline Vector3&		Random();
	inline Vector3&		Zero() { x=y=z=0.0f; return *this; }
	inline bool			IsNormal() const { return _feq(SqrLength(),1.0f); }
	inline bool			IsZero() const { return _feqz(x)&&_feqz(y)&&_feqz(z); }
	inline bool			IsFinite() const { return _finite(x)&&_finite(y)&&_finite(z); }
	inline float__t		Max() const { return _max3(x,y,z); }
	inline float__t		Min() const { return _min3(x,y,z); }
	inline float__t		AbsSum() const { return _fabs(x)+_fabs(y)+_fabs(z); }
	inline bool			IsEqual( const Vector3& v ) const { return _feq(x,v.x)&&_feq(y,v.y)&&_feq(z,v.z); }
	inline bool			IsPerpendicular( const Vector3& v ) const { return _feqz( Dot(v) ); }
	inline bool			IsParallel( const Vector3& v ) const { float__t d = Dot(v); return d*d + EPSILON >= SqrLength()*v.SqrLength(); }
	//! Returns an axis identifier (or NaD if none was found)
//	axis_t				IsAxis() const;
	// Friend Functions:
	friend	Vector3 operator * ( cfloat__t, const Vector3& );
#ifdef USE_IOSTREAM
	friend ostream & operator << ( ostream &, const Vector3& );
#endif // USE_IOSTREAM
};
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
inline Vector3& Vector3::Set( cfloat__t a, cfloat__t b, cfloat__t c )
{
	x = a;
	y = b;
	z = c;
	return *this;
}
/////////////////////////////////////////////////////////////////////////////
inline Vector3& Vector3::Set( const float a[3] )
{
//	memcpy( (void*)&x, (void*)a, sizeof(float)*3 );			// faster?
	x = (float__t)a[0];
	y = (float__t)a[1];
	z = (float__t)a[2];
	return *this;
}
/////////////////////////////////////////////////////////////////////////////
inline Vector3& Vector3::Set( const double a[3] )
{
	x = (float__t)a[0];
	y = (float__t)a[1];
	z = (float__t)a[2];
	return *this;
}
/////////////////////////////////////////////////////////////////////////////
inline Vector3& Vector3::Set( const Vector3& v )
{
//	memcpy( (void*)&x, (void*)&v.x, sizeof(float__t)*3 );		// faster?
	x = v.x;
	y = v.y;
	z = v.z;
	return *this;
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
inline Vector3& Vector3::Random()
{
	z = _frnd(2.0f) - 1.0f;
	double r = _fsqrt(1.0f - z * z);
	float__t st, ct;
	__fsincos( _frnd(M_2PI), &st, &ct );
	x = (float__t)(r * st);
	y = (float__t)(r * ct);
	return *this;
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/*
inline Vector3& Vector3::operator = ( const Vector3& v )
{
	x = v.x;
	y = v.y;
	z = v.z;
	return (*this);
}
*/
/////////////////////////////////////////////////////////////////////////////
inline Vector3& Vector3::operator += ( const Vector3& v )
{
	x += v.x;
	y += v.y;
	z += v.z;
	return (*this);
}
/////////////////////////////////////////////////////////////////////////////
inline Vector3& Vector3::operator -= ( const Vector3& v )
{
	x -= v.x;
	y -= v.y;
	z -= v.z;
	return (*this);
}
/////////////////////////////////////////////////////////////////////////////
inline Vector3& Vector3::operator %= ( const Vector3& v )	// cross-product
{
	// Conservative algo: 6 muls, 3 'adds'
	const float__t _x=x, _y=y;
	x = v.y *  z - v.z * _y;
	y = v.z * _x - v.x *  z;
	z = v.x * _y - v.y * _x;
	return *this;
}
/////////////////////////////////////////////////////////////////////////////
inline Vector3& Vector3::operator *= ( const Vector3& v )
{
	x *= v.x;
	y *= v.y;
	z *= v.z;
	return (*this);
}
/////////////////////////////////////////////////////////////////////////////
inline Vector3& Vector3::operator /= ( const Vector3& v )
{
	x /= v.x;
	y /= v.y;
	z /= v.z;
	return (*this);
}
/////////////////////////////////////////////////////////////////////////////
inline Vector3& Vector3::operator *= ( cfloat__t d )
{
	x *= d;
	y *= d;
	z *= d;
	return (*this);
}
/////////////////////////////////////////////////////////////////////////////
inline Vector3& Vector3::operator /= ( cfloat__t d )
{
	const float__t id = 1.0f / d;
	x *= id;
	y *= id;
	z *= id;
	return (*this);
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
inline Vector3 Vector3::operator + () const
{
	return (*this);
}
/////////////////////////////////////////////////////////////////////////////
inline Vector3 Vector3::operator - () const
{
	return Vector3( -x, -y, -z );
}
/////////////////////////////////////////////////////////////////////////////
inline float__t& Vector3::operator [] ( const int i )
{
//	return (i==0?x:(i==1?y:z));						// for class, safe
//	return vec[i];
	return (&x)[i];
}
/////////////////////////////////////////////////////////////////////////////
inline float__t Vector3::operator [] ( const int i ) const
{
//	return (i==0?x:(i==1?y:z));						// for class, safe
//	return vec[i];
	return (&x)[i];
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
inline Vector3 Vector3::operator + ( const Vector3& v ) const
{
	return Vector3(x+v.x,y+v.y,z+v.z);
}
/////////////////////////////////////////////////////////////////////////////
inline Vector3 Vector3::operator - ( const Vector3& v ) const
{
	return Vector3(x-v.x,y-v.y,z-v.z);
}
/////////////////////////////////////////////////////////////////////////////
inline Vector3 Vector3::operator * ( const Vector3& v ) const
{
	return Vector3( x*v.x, y*v.y, z*v.z );
}
/////////////////////////////////////////////////////////////////////////////
inline Vector3 Vector3::operator / ( const Vector3& v ) const
{
	return Vector3( x/v.x, y/v.y, z/v.z );
}
/////////////////////////////////////////////////////////////////////////////
inline Vector3 Vector3::operator * ( cfloat__t d ) const
{
	return Vector3( x*d, y*d, z*d );
}
/////////////////////////////////////////////////////////////////////////////
/*
inline Vector3 operator * ( const Vector3& v, const int d )
{
	return Vector3( v.x*d, v.y*d, v.z*d );
}
/////////////////////////////////////////////////////////////////////////////
inline Vector3 operator * ( const int d, const Vector3& v)
{
	return Vector3( v.x*d, v.y*d, v.z*d );
}
*/
/////////////////////////////////////////////////////////////////////////////
inline Vector3 Vector3::operator / ( cfloat__t d ) const
{
	const float__t id = 1.0f/d;
	return Vector3(x*id,y*id,z*id);
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
inline Vector3 Vector3::Cross( const Vector3& v ) const
{
	// Conservative algo: 6 muls, 3 'adds'
	return Vector3( y*v.z-z*v.y, z*v.x-x*v.z, x*v.y-y*v.x );
}
/////////////////////////////////////////////////////////////////////////////
inline double Vector3::Dot( const Vector3& v ) const
{
	// Convert the input to double so that the entire calculation is done in double
	//  this prevents (unpredictable, because of float optimizations) rounding errors
	return (double)x*(double)v.x + (double)y*(double)v.y + (double)z*(double)v.z;
}
/////////////////////////////////////////////////////////////////////////////
inline float__t Vector3::SqrLength() const
{ 
	return (x*x+y*y+z*z); 
}
/////////////////////////////////////////////////////////////////////////////
inline float__t Vector3::Length() const
{ 
	return (float__t)_fsqrt( SqrLength() ); 
}	
/////////////////////////////////////////////////////////////////////////////
inline double Vector3::Angle( const Vector3& v ) const
{
	// Convert the input to double so that the entire calculation is done in double
	//  this prevents (unpredictable, because of float optimizations) rounding errors
	const double v1x = x; const double v1y = y; const double v1z = z;
	const double v2x = v.x; const double v2y = v.y; const double v2z = v.z;
	const double len = _fsqrt( (v1x * v1x + v1y * v1y + v1z * v1z) * (v2x * v2x + v2y * v2y + v2z * v2z) );
	return safeacos( (v1x*v2x + v1y*v2y + v1z*v2z)/len );
//	The following implementation is dangerous because it mixes double and float, 
//	 can lead to +/-1.0000000001 as input for acos (which is fatal).
//	const float__t len = _fsqrt( SqrLength() * v.SqrLength() );
//	return safeacos( (x*v.x + y*v.y + z*v.z)/len );
}
/////////////////////////////////////////////////////////////////////////////
inline Vector3& Vector3::Normalize()
{ 
	const float__t il = 1.0f/Length(); 
	x *= il; 
	y *= il; 
	z *= il; 
	return (*this); 
}
/////////////////////////////////////////////////////////////////////////////
inline Vector3& Vector3::Flip()
{ 
	x =- x; 
	y =- y; 
	z =- z; 
	return (*this); 
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//	Friends:
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
inline Vector3 operator * ( cfloat__t d, const Vector3& v )
{
	return Vector3( d * v.x, d * v.y, d * v.z );
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#ifdef USE_IOSTREAM
inline ostream & operator << ( ostream &o, const Vector3& t )
{
	o << "(" << t.x << "," << t.y << "," << t.z << ")";
	return o;
}
#endif // USE_IOSTREAM
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_VECTOR3_H_INCLUDED
///////////////////////////////// [citkt_Vector3.h] END
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
class DBezierCurve
{
public:
	Vector3		cp0, cp1, cp2, cp3 ;
	float__t	t ;
	DBezierCurve() {} 
	DBezierCurve(const Vector3& c0, const Vector3& c1, const Vector3& c2, const Vector3& c3) 
		: cp0(c0), cp1(c1), cp2(c2), cp3(c3) {} 
	DBezierCurve(const Vector3& c0, const Vector3& d0, cfloat__t l0, 
				const Vector3& c1, const Vector3& d1, cfloat__t l1)
		: cp0(c0), cp1(c0+l0*d0), cp2(c1+l1*d1), cp3(c1) {}
	void SetT(cfloat__t i)  { _compute_pols(i); _compute_derv(i); }
	float__t GetX( cfloat__t i ) { _compute_pols(i); return GetX(); }
	float__t GetX() const	
	{
		return ( ( b0 * cp0.x ) + ( b1 * cp1.x ) + ( b2 * cp2.x ) + ( b3 * cp3.x ) ) ;
	}
	float__t GetY( cfloat__t i ) { _compute_pols(i); return GetY(); }
	float__t GetY() const
	{
		return ( ( b0 * cp0.y ) + ( b1 * cp1.y ) + ( b2 * cp2.y ) + ( b3 * cp3.y ) ) ;
	}
	float__t GetZ( cfloat__t i ) { _compute_pols(i); return GetZ(); }
	float__t GetZ() const
	{
		return ( ( b0 * cp0.z ) + ( b1 * cp1.z ) + ( b2 * cp2.z ) + ( b3 * cp3.z ) ) ;
	}
	Vector3	GetPosition( cfloat__t i )	{ _compute_pols(i); return GetPosition(); }
	Vector3	GetPosition() const		{ return Vector3 ( GetX(), GetY(), GetZ() ); }
	Normal3 GetDirection( cfloat__t i ) { _compute_derv(i); return GetDirection(); }
	Normal3 GetDirection() const
	{
		float__t x = d0 * (cp1.x - cp0.x) + d1 * (cp2.x - cp1.x) + d2 * (cp3.x - cp2.x) ;
		float__t y = d0 * (cp1.y - cp0.y) + d1 * (cp2.y - cp1.y) + d2 * (cp3.y - cp2.y) ;
		float__t z = d0 * (cp1.z - cp0.z) + d1 * (cp2.z - cp1.z) + d2 * (cp3.z - cp2.z) ;
		return Vector3(x, y, z).Normalized() ;
	}
private:
	float__t	b0, b1, b2, b3 ;
	float__t	d0, d1, d2 ;
	//! compute bezier coefficients for the position
	void _compute_pols(cfloat__t t)
	{
		float__t t1 = 1.0f - t ;
		float__t t2 = t*t ;
		float__t t3 = t1*t1 ;
		b0 = t1 * t3 ;
		b1 = 3.0f * t * t3 ;
		b2 = 3.0f * t2 * t1 ;
		b3 = t * t2 ;
	}
	//! compute bezier coefficients for the tangent
	void _compute_derv( cfloat__t t )
	{
		float__t t0 = 1.0f - t ;
		d0 = (t0 * t0) * 2.0f ;	//	2 * (1-t)^2
		d1 = 4.0f * t * t0    ;	//	2 * 2 * t * (1-t)
		d2 = 2.0 * t * t     ;	//	2 * t^2
	}
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_BEZIERCURVE_H_INCLUDED
///////////////////////////////// [citkt_BezierCurve.h] END
///////////////////////////////// [citkt_Bitmap.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
//  citkt_Bitmap.h
//
//  Declares DBitmap, a versatile Bitmap container (formerly: LFB)
//  !! Currently being completely rewritten !!
#ifndef CITKT_BITMAP_H_INCLUDED
#define CITKT_BITMAP_H_INCLUDED
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citkt_Color32.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITKT_COLOR_H_INCLUDED
#define CITKT_COLOR_H_INCLUDED
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
/////////////////////////////////////////////////////////////////////////////
union Color32
{
	static inline uchar clip( int x ) { return (uchar)_limit(x,0,255); }
	enum {
		// TODO: change these for big endian machines
		BLUE	= 0x000000FF,
		GREEN	= 0x0000FF00,
		RED		= 0x00FF0000,
		COLOR	= 0x00FFFFFF,
		ALPHA	= 0xFF000000
	};
	ulong		val;
	struct /*no name*/
	{
		uchar	b, g, r, a;
	};
	// Constructors
	Color32() {}
	Color32( ulong l ) : val(l) {}
	Color32( uchar rr, uchar gg, uchar bb, uchar aa=255) : r(rr), g(gg), b(bb), a(aa) {}
	
	// Operators
	bool operator == ( const Color32 &c ) const		{ return val == c.val; }
	operator int () const							{ return (int)val; }
	Color32&	operator = ( ulong l )				{ val = l; return *this; }
	Color32&	operator += (const Color32 &c );
	Color32		operator + ( const Color32 &c ) const;
	Color32		operator * ( float f ) const;
	// Methods
	void	SetI8( uchar ii )							{ r=g=b=ii; /*a=255;*/ }
	void	SetRGB888( uchar rr, uchar gg, uchar bb )	{ r=rr; g=gg; b=bb; /*a=255;*/ }
	void	SetRGBA8888( uchar rr, uchar gg, uchar bb, uchar aa ) { r=rr; g=gg; b=bb; a=aa; }
	void	SetClip( int rr, int gg, int bb )			{ r=clip(rr); g=clip(gg); b=clip(bb); }
	Color32&	SetRGB565 ( ushort const x );
	ushort		RGB565() const;
	//! Generate a random color (does not touch alpha)
	Color32&	Random()			{ r=rand()&255; g=rand()&255; b=rand()&255; return *this; }
};
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
inline Color32 Color32::operator * ( float f ) const
{
	return Color32( clip(__ftoi(r*f)), clip(__ftoi(g*f)), clip(__ftoi(b*f)), a);
}
/////////////////////////////////////////////////////////////////////////////
inline Color32 Color32::operator + ( const Color32 &c ) const
{
	return Color32( clip(r+c.r), clip(g+c.g), clip(b+c.b), a );
}
/////////////////////////////////////////////////////////////////////////////
inline Color32& Color32::operator += (const Color32 &c )
{
	r = clip( (int)r+c.r );
	g = clip( (int)g+c.g );
	b = clip( (int)b+c.b );
	return *this;
}
/////////////////////////////////////////////////////////////////////////////
inline Color32& Color32::SetRGB565 ( ushort const x )
{
	r = (uchar)((x>>11)<<3);
	g = (uchar)((x>>5)<<2);
	b = (uchar) (x<<3);
	a = 255;
	return *this;
}
/////////////////////////////////////////////////////////////////////////////
inline ushort Color32::RGB565() const 
{
	return ((ushort)(((int)(r>>3)<<11) | ((int)(g>>2)<<5) | (b>>3))); 
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_COLOR_H_INCLUDED
///////////////////////////////// [citkt_Color32.h] END
///////////////////////////////// [citkt_Templates.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITKT_TEMPLATES_INCLUDED
#define CITKT_TEMPLATES_INCLUDED
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#ifndef __cplusplus
#error C++ compiler required.
#endif
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
////////////////////////////////////////////////////////////////////////////////
//! Assert that a (return) value gets used (used for handles)
template <typename T>
class _use
{
	const T	retval;
	bool	unused_return_value;
public:
	_use( const T& rv ) : retval(rv), unused_return_value(false) {}
	~_use()				{ assert(unused_return_value); }
	operator T ()		{ unused_return_value=true; return retval; }
};
/////////////////////////////////////////////////////////////////////////////
//! Universal swap method:
template <typename T>
inline void _swap( T& t1, T& t2 )
{
	const T temp = t1;
	t1 = t2;
	t2 = temp;
}
//! Safe delete:
template <typename T>
inline void _delete( T& t )
{
	delete t;
	t = 0;
}
//! Safe delete for arrays:
template <typename T>
inline void _delete_array( T& t )
{
	delete [] t;
	t = 0;
}
/////////////////////////////////////////////////////////////////////////////
//! Find minimum
template <typename T>
inline void _set_min( T& tmin, const T& t )
{
	if (t<tmin) tmin = t;
}
//! Find maximum
template <typename T>
inline void _set_max( T& tmax, const T& t )
{
	if (t>tmax) tmax = t;
}
//! Find minimum and maximum
template <typename T>
inline void _set_minmax( T& tmin, T& tmax, const T& t2 )
{
	if (t2>tmax) tmax = t2;
	else
	if (t2<tmin) tmin = t2;
}
/////////////////////////////////////////////////////////////////////////////
//! Sort two values. First one will be the smallest
template <typename T>
inline void _sort( T& a, T& b )
{
	if (a>b) _swap(a,b);
}
// Sort three values. First one will be the smallest
// Might be done a bit faster (3,2,1 does three swaps)
template <typename T>
inline void _sort3( T& a, T& b, T& c )
{
	if (a>b) _swap(a,b);
	if (b>c) _swap(b,c);
	if (a>b) _swap(a,b);
}
/////////////////////////////////////////////////////////////////////////////
#ifdef _min
#undef _min
#endif
//! Find minimum
template <typename T>
inline T _min( const T& t1, const T& t2 )
{
	return t1<t2?t1:t2;
}
#ifdef _max
#undef _max
#endif
//! Find maximum
template <typename T>
inline T _max( const T& t1, const T& t2 )
{
	return t1>t2?t1:t2;
}
#ifdef _limit
#undef _limit
#endif
//! Limit between two values
template <typename T>
inline T _limit( const T& t, const T& mn, const T& mx )
{
	return t>=mx?mx:(t<mn?mn:t);
}
/////////////////////////////////////////////////////////////////////////////
//! Reverse all the bytes
template <typename T>
inline void _swap_bytes( T &in )
{
	for (int t=0,e=(sizeof(T)>>1);t<e;t++)
		_swap( ((char*)&in)[t], ((char*)&in)[(sizeof(T)-1)-t] );
}
/////////////////////////////////////////////////////////////////////////////
//! Reverse an array
template <typename T>
inline void _reverse_array( T* array, int size )
{
	for (int i=0; i<(size>>1);i++)
		_swap(array[i], array[size- (i+1)]);
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_TEMPLATES_INCLUDED
///////////////////////////////// [citkt_Templates.h] END
///////////////////////////////// [citkt_Rect.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITKT_RECT_H_INCLUDED
#define CITKT_RECT_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citkt_Range.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITKT_RANGE_H_INCLUDED
#define CITKT_RANGE_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citkt_Limits.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITKT_LIMITS_H_INCLUDED
#define CITKT_LIMITS_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#include <limits.h>
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
///////////////////////////////////////////////////////////////////////////////
class _MaxValue
{
public:
	operator unsigned char () const { return UCHAR_MAX; }
	operator unsigned short () const { return USHRT_MAX; }
	operator unsigned int () const { return UINT_MAX; }
	operator unsigned long () const { return ULONG_MAX; }
	// 'char' is assumed to be signed!!
	operator char () const { return CHAR_MAX; }
	operator short () const { return SHRT_MAX; }
	operator int () const { return INT_MAX; }
	operator long () const { return LONG_MAX; }
	operator float () const { return FLT_MAX; }
	operator double () const { return DBL_MAX; }
	operator long double () const { return LDBL_MAX; }
};
///////////////////////////////////////////////////////////////////////////////
class _MinValue
{
public:
	operator unsigned char () const { return 0; }
	operator unsigned short () const { return 0; }
	operator unsigned int () const { return 0; }
	operator unsigned long () const { return 0; }
	// 'char' is assumed to be signed!!
	operator char () const { return CHAR_MIN; }
	operator short () const { return SHRT_MIN; }
	operator int () const { return INT_MIN; }
	operator long () const { return LONG_MIN; }
	operator float () const { return -FLT_MAX; }
	operator double () const { return -DBL_MAX; }
	operator long double () const { return -LDBL_MAX; }
};
///////////////////////////////////////////////////////////////////////////////
class _DeltaValue
{
public:
	operator unsigned char () const { return 1; }
	operator unsigned short () const { return 1; }
	operator unsigned int () const { return 1; }
	operator unsigned long () const { return 1; }
	// 'char' is assumed to be signed!!
	operator char () const { return 1; }
	operator short () const { return 1; }
	operator int () const { return 1; }
	operator long () const { return 1; }
	operator float () const { return FLT_EPSILON; }
	operator double () const { return DBL_EPSILON; }
	operator long double () const { return LDBL_EPSILON; }
};
///////////////////////////////////////////////////////////////////////////////
#define MAXVAL		_MaxValue()
#define MINVAL		_MinValue()
#define DELTAVAL	_DeltaValue()
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_LIMITS_H_INCLUDED
///////////////////////////////// [citkt_Limits.h] END
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
///////////////////////////////////////////////////////////////////////////////
enum outrange_t { orBefore=-1, orIn=0, orAfter=1 };
enum intersect_t { irUnknown, irOut, irIn, irOverlap, irContains };
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
template <class T>
class DRange
{
public:
	// Constructors:
	DRange() { Empty(); }
	DRange( const DRange &d ) { Begin=d.GetBegin(); End=d.GetEnd(); }
	DRange( const T b, const T e ) { if (b<=e) Set(b,e); else Set(e,b); }
	// Methods:
	T			GetBegin() const { return Begin; }
	T			GetCenter() const { return (Begin+End)/2; }
	T			GetEnd() const { return End; }
	T			GetLength() const { /*if (End<Begin) return 0;*/ return End - Begin + (T)DELTAVAL; }
	DRange&		Empty() { Begin=MAXVAL; End=MINVAL; return *this; }
	bool		IsEmpty() const { return End<Begin; }
	DRange&		Set( const DRange &r ) { Begin=r.GetBegin(); End=r.GetEnd(); return *this; }
	DRange&		Set( const T b, const T e ) { Begin=b; End=e; if (Begin>End) _swap(Begin,End); return *this; }
	DRange&		SetBegin( const T beg ) { Begin = beg; if (Begin>End) End=Begin; return *this; }
	DRange&		SetEnd( const T end ) { End = end; if (End<Begin) Begin=End; return *this; }
	DRange&		Deflate( const T val ) { End+=val; Begin-=val; return *this; }
	DRange&		Inflate( const T val ) { End-=val; Begin+=val; return *this; }
	DRange&		Scale( const T val ) { End*=val; Begin*=val; if (val<0) _swap(Begin,End); return *this; }
	DRange&		Offset( const T val ) { End+=val; Begin+=val; return *this; }
	DRange&		Include( const T val ) { if (IsEmpty()) Begin=End=val; else if (val<Begin) Begin=val; else if (val>End) End=val; return *this; }
	DRange&		Union( const DRange &rhs ) { _set_min(Begin,rhs.GetBegin()); _set_max(End,rhs.GetEnd()); return *this; }
	DRange&		Substract( const DRange &rhs );
	DRange&		Intersect( const DRange &rhs ) { _set_max(Begin,rhs.GetBegin()); _set_min(End,rhs.GetEnd()); return *this; }
	DRange&		Normalize() { if (Begin>End) _swap(Begin,End); return *this; }
	bool		Contains( const T val ) const { return val>=Begin && val<=End; }
	bool		Overlaps( const DRange &rhs ) const { return rhs.GetBegin()<End && Begin<rhs.GetEnd(); }
	T			Compare( const T val ) const { if (val<Begin) return val-Begin; if (val>End) return val-End; return 0; }
	outrange_t	Test( const T val ) const { if (val<Begin) return orBefore; if (val>End) return orAfter; return orIn; }
	intersect_t	Test( const DRange &rhs ) const;
	// Math:
	T			Mod( const T val ) const { T m = (val-Begin)%(End-Begin); return (m<0?m+End:m+Begin); }
	int			Div( const T val ) const { return (int)(val>=Begin?val-Begin:val-End)/GetLength(); }
	T			Clip( const T val ) const { return _limit(val,Begin,End); }
	double		Pos( const T val ) const { return (val-Begin)/(double)(End-Begin); }
	// const operators:
	DRange		operator | ( const T val ) const { return DRange( _min(Begin,val), _max(End,val) ); }
	DRange		operator | ( const DRange &rhs ) const { return DRange( _min(Begin,rhs.GetBegin()), _max(End,rhs.GetEnd()) ); }
	DRange		operator - ( const DRange &rhs ) const;
	DRange		operator & ( const DRange &rhs ) const { return DRange( _max(Begin,rhs.GetBegin()), _min(End,rhs.GetEnd()) ); }
	DRange		operator + ( const T rhs ) const { return DRange( Begin+rhs, End+rhs ); }
	DRange		operator - ( const T rhs ) const { return DRange( Begin-rhs, End-rhs ); }
	DRange		operator * ( const T rhs ) const { return DRange( Begin*rhs, End*rhs ); }
	DRange		operator / ( const T rhs ) const { return DRange( Begin/rhs, End/rhs ); }
	// operators:
	DRange&		operator |= ( const T val ) { return Include(val); }
	DRange&		operator |= ( const DRange &rhs ) { return Union(rhs); }
	DRange&		operator -= ( const DRange &rhs ) { return Substract(rhs); }
	DRange&		operator &= ( const DRange &rhs ) { return Intersect(rhs); }
	DRange&		operator += ( const T rhs ) { Begin+=rhs, End+=rhs; return *this; }
	DRange&		operator -= ( const T rhs ) { Begin-=rhs, End-=rhs; return *this; }
	DRange&		operator *= ( const T rhs ) { Begin*=rhs, End*=rhs; if (Begin>End) _swap(Begin,End); return *this; }
	DRange&		operator /= ( const T rhs ) { Begin/=rhs, End/=rhs; if (Begin>End) _swap(Begin,End); return *this; }
	// Other operators:
	bool		operator == ( const DRange &rhs ) const { return rhs.GetBegin()==Begin && rhs.GetEnd()==End; }
	T			operator [] ( const T val ) const { return Mod(val); }
	// Type-cast operators:
				operator T () const { return GetLength(); }
private:
	T	Begin, End;
};
///////////////////////////////////////////////////////////////////////////////
template <class T>
DRange<T> DRange<T>::operator - ( const DRange<T> &rhs ) const
{
	int bc = Test(rhs.GetBegin());
	if (bc>0)
		return DRange(*this);
	int ec = Test(rhs.GetEnd());
	if (ec<0 || bc==ec)
		return DRange(*this);
	if (bc<0)
	{
		if (ec>0)
			return DRange();
		return DRange( rhs.GetEnd(), End );
	}
	return DRange( Begin, rhs.GetBegin() );
}
///////////////////////////////////////////////////////////////////////////////
template <class T>
DRange<T>& DRange<T>::Substract( const DRange<T> &rhs )
{
	int bc = Test(rhs.GetBegin());
	if (bc>0)
		return *this;
	int ec = Test(rhs.GetEnd());
	if (ec<0 || bc==ec)
		return *this;
	if (bc<0)
	{
		if (ec>0)
			return Empty();
		Begin = rhs.GetEnd();
	}
	else
		End = rhs.GetBegin();
	return *this;
}
///////////////////////////////////////////////////////////////////////////////
#define _TESTVAL(bt,et) (((int)(bt)<<2)+(int)(et))
template <class T>
intersect_t	DRange<T>::Test( const DRange<T> &rhs ) const
{
	switch (_TESTVAL( Test(rhs.GetBegin()), Test(rhs.GetEnd()) ))
	{
	case _TESTVAL(ORT_BEFORE,ORT_BEFORE):
	case _TESTVAL(ORT_AFTER,ORT_AFTER):
		return irOut;
	case _TESTVAL(ORT_BEFORE,ORT_IN):
	case _TESTVAL(ORT_IN,ORT_AFTER):
		return irOverlap;
	case _TESTVAL(ORT_BEFORE,ORT_AFTER):
		return irContains;
	case _TESTVAL(ORT_IN,ORT_IN):
		return irIn;
	}
	return irUnknown;
}
#undef _TESTVAL
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// Specialization for floating point types
inline double DRange<double>::Mod( const double val ) const 
{ 
	double m = fmod(val-Begin,End-Begin); 
	return (m<0?m+End:m+Begin);
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_RANGE_H_INCLUDED
///////////////////////////////// [citkt_Range.h] END
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
///////////////////////////////////////////////////////////////////////////////
template <class T>
class DRect
{
public:
	DRange<T>	LR, TB;
	DRect() { Empty(); }
	DRect( const DRect &d ) { LR = d.LR; TB = d.TB; }
	DRect( const T bx, const T by, const T ex, const T ey ) { LR.Set(bx,ex); TB.Set(by,ey); }
	// Methods:
	T			GetLeft() const { return LR.GetBegin(); }
	T			GetRight() const { return LR.GetEnd(); }
	T			GetBottom() const { return TB.GetBegin(); }
	T			GetTop() const { return TB.GetEnd(); }
	T			GetWidth() const { return LR.GetLength(); }
	T			GetHeight() const { return TB.GetLength(); }
	DRect<T>	GetSize() const { return DRect<T>(GetWidth(),GetHeight()); }
	DRect&		Empty() { TB.Empty(); LR.Empty(); return *this; }
	bool		IsEmpty() const { return GetWidth()<=0 || GetHeight()<=0; }
	DRect&		Set( const T bx, const T by, const T ex, const T ey ) { LR.Set(bx,ex); TB.Set(by,ey); return *this; }
	DRect&		SetLeftRight( const T bx, const T ex ) { LR.Set(bx,ex); return *this; }
	DRect&		SetTopBottom( const T by, const T ey ) { TB.Set(by,ey); return *this; }
	DRect&		SetLeft( const T end ) { LR.SetBegin(end); return *this; }
	DRect&		SetRight( const T beg ) { LR.SetEnd(beg); return *this; }
	DRect&		SetBottom( const T beg ) { TB.SetBegin(beg); return *this; }
	DRect&		SetTop( const T end ) { TB.SetEnd(end); return *this; }
	DRect&		Deflate( const T val ) { LR.Deflate(val); TB.Deflate(val); return *this; }
	DRect&		Inflate( const T val ) { LR.Inflate(val); TB.Inflate(val); return *this; }
	DRect&		Scale( const T x, const T y ) { LR.Scale(x); TB.Scale(y); return *this; }
	DRect&		Offset( const T x, const T y ) { LR.Offset(x); TB.Offset(y); return *this; }
	DRect&		Include( const T x, const T y ) { LR.Include(x); TB.Include(y); return *this; }
	DRect&		Union( const DRect &rhs ) { LR.Union(rhs.LR); TB.Union(rhs.TB); return *this; }
	DRect&		Substract( const DRect &rhs );
	DRect&		Intersect( const DRect &rhs ) { LR.Intersect(rhs.LR); TB.Intersect(rhs.TB); return *this; }
	DRect&		Normalize() { LR.Normalize(); TB.Normalize(); return *this; }
	bool		Contains( const T x, const T y ) const { return LR.Contains(x)&&TB.Contains(y); }
	intersect_t	Test( const DRect &rhs ) const;
	DRect&		Clip( T& h, T& v ) const { h=LR.Clip(h); v=TB.Clip(v); return *this; }
	// const operators:
	bool		operator == ( const DRect &rhs ) const { return rhs.LR==LR && rhs.TB==TB; }
	DRect		operator | ( const DRect &rhs ) const { return DRect( _min(Begin,rhs.GetBegin()), _max(End,rhs.GetEnd()) ); }
	DRect		operator - ( const DRect &rhs ) const;
	DRect		operator & ( const DRect &rhs ) const { return DRect( _max(Begin,rhs.GetBegin()), _min(End,rhs.GetEnd()) ); }
	// operators:
	DRect&		operator |= ( const DRect &rhs ) { return Union(rhs); }
	DRect&		operator -= ( const DRect &rhs ) { return Substract(rhs); }
	DRect&		operator &= ( const DRect &rhs ) { return Intersect(rhs); }
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
template <class T>
intersect_t DRect<T>::Test( const DRect<T> &rhs ) const
{
	intersect_t h = LR.Test(rhs.LR);
	intersect_t v = TB.Test(rhs.TB);
	if (h==v)
		return h;
	if (h==irUnknown || v==irUnknown)
		return irUnknown;
	if (h==irOut || v==irOut)
		return irOut;
	return irOverlap;
}
///////////////////////////////////////////////////////////////////////////////
template <class T>
DRect<T>& DRect<T>::Substract( const DRect<T> &rhs )
{
	intersect_t h = LR.Test(rhs.LR);
	intersect_t v = TB.Test(rhs.TB);
	if (h==irContains && v==irOverlap)
	{
		// doeiets
	}
	else
	if (h==irOverlap && v==irContains)
	{
		// doeiets
	}
	else
	if (h==irContains && v==irContains)
	{
		Empty();
	}
	return *this;
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_RECT_H_INCLUDED
///////////////////////////////// [citkt_Rect.h] END
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class DBitmap
{
public:
	bool		hasalpha, hascolor;
	Color32		bgcolor;
	bool		fixedstride;						// Remove this please
	DBitmap ();										// Create empty
	DBitmap ( const int, const int, const int=-1);	// Create, with stride
	DBitmap ( const int, const int, const Color32);	// Create, fill with Background
	DBitmap ( const DBitmap* );						// Copy constructor
	DBitmap ( const DBitmap& );						// Copy constructor
	~DBitmap ();									// Destructor
	void		Delete();							// Use on bitmaps returned from any methods below
	DBitmap&	operator = ( const DBitmap& );		// Copy
	Color32*	operator [] ( const int n ) const { return line[n]; }	// Return pointer to row; NO CHECK
	Color32**	GetRowPointers() const { return line; }
	
	void		Create ( const int, const int, const int=-1 );	// Create, with stride
	void		Create ( const int, const int, const Color32);	// Create, fill with Background
	void		Create ( const DBitmap*);						// Copy
	void		Attach ( const int, const int, Color32*, const int=-1 );	// Attach existing data
	void		Attach ( DBitmap* );				// Attach data from other bitmap
	Color32*	Detach ();							// Detach data from other bitmap
	Color32*	GetData () const { return data; }	// Returns pointer to bitmap data
	Color32		GetPixel( cfloat__t, cfloat__t ) const;	// 0..1
	Color32&	GetPixel( const int x, const int y ) const { return line[y][x]; }
	void		SetPixel( const int x, const int y, const Color32& c ) { line[y][x] = c; }
	Color32		GetPixelW( cfloat__t x, cfloat__t y ) const { return GetPixel((float__t)(x-floor(x)),(float__t)(y-floor(y))); }  
	Color32&	GetPixelW( const int x, const int y ) const { return line[(int)_mod(y,_sizey)][(int)_mod(x,_sizex)]; }
	void		SetPixelW( const int x, const int y, const Color32& c ) { line[(int)_mod(y,_sizey)][(int)_mod(x,_sizex)] = c; }
	double		GetAspectRatio() const { return _sizey?(_sizex/(double)_sizey):1.0; }
	void		Fill ( const Color32& );				// Fill with color
	void		FillRect(const DRect<int>&,const Color32&);// Fill rectangle with color
	void		Erase ();								// Fill with Background
	void		EraseRect( const DRect<int>& );			// Fill rectangle with Background
	void		Free();									// Delete all data
	DBitmap*	GetRect ( const DRect<int>& ) const;	// Copy data from rectangle
	void		CopyToPos ( const int, const int, const DBitmap* );	// Copy data
	void		BlitToPos ( const int, const int, const DBitmap* );	// Alpha blends
	void		BlitToRect ( const DRect<int>&, const DBitmap* );	// Scaling & blending
	DBitmap*	GetScaled ( const int, const int ) const;
	void		ScaleTo ( const int, const int );
	void		ScaleBy ( cfloat__t );
	void		ScaleBy ( cfloat__t, cfloat__t );
	void		SetSizeX ( const int );					// Crops x, around center
	void		SetSizeY ( const int );					// Crops y, around center
	void		SetSize ( const int, const int );		// Crops x and y, around center
	void		SetFixedStride ( const int );			// Fix the stride
	void		Crop ( const DRect<int>& );				// Crops this range, fills new space with bgcolor
	void		Rotate90CW ();							// May resize to fit rotated image
	void		Rotate180 ();
	void		Rotate90CCW ();							// May resize to fit rotated image
	void		RotateClip90CW ();						// Will not resize, clipping may (will) occur
	void		RotateClip90CCW ();						// Will not resize, clipping may (will) occur
	void		MirrorX ();
	void		MirrorY ();
	void		MirrorXY ();
	void		RotateBy ( cfloat__t );					// May resize to fit rotated image
	void		RotateByClip ( cfloat__t );				// Will not resize, clipping may (will) occur
	int			GetStride () const { return _stride; }
	int			GetStrideInBytes () const;				// Returns stride in bytes
	int			GetBytesPerPixel() const { return sizeof(Color32); }
	int			GetSizeX () const { return _sizex; } 
	int			GetSizeY () const { return _sizey; }
	void		SetAlpha( const int );
	void		ApplyBackground();
	void		ChromaKey( Color32, const ulong =0, const ulong =0 );
	void		ScaleToFit( const int, const int );
	void		ScaleToMin( const int, const int );
	DBitmap*	FromRGB565( const int, const int, const void* const );
	long		ToRGB565( void* ) const;
//	long		ToRGB332( void* ) const;
protected:
	Color32		*data;
	Color32		**line;
	int			_sizex, _sizey, _stride;
	DBitmap*	GetScaledUp ( const int, const int ) const;
	DBitmap*	GetScaledDown ( const int, const int ) const;
	void		_Attach ( const int, const int, Color32*,  const int=-1 );
private:
	enum  RotateAngle {CW90,CW180,CW270};
	void _Rotate(RotateAngle rotang); 
};
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_BITMAP_H_INCLUDED
///////////////////////////////// [citkt_Bitmap.h] END
///////////////////////////////// [citkt_BufferVal.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
//		Container, uitgevoerd als resizing array FIFO
//
#ifndef	CITKT_BUFFERVAL_H_INCLUDED
#define	CITKT_BUFFERVAL_H_INCLUDED
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T>
class BufferVal : protected Array<T,1>			// use malloc/free/realloc
{
public:
	//! Constructors:
	BufferVal()				: Begin(0)				{ }
	BufferVal( size_t ni )	: Begin(0)				{ Reserve(ni); }
	//! Copy constructor
	BufferVal( const BufferVal<T> &b ) : Begin(0)	{ AddFrom(b); }
	// Add an item
	T&			Add();
	T&			Push()								{ return Add(); }
	void		Add( T const &a )					{ Add() = a; }
	void		Push( T const &a )					{ Add() = a; }
	//! Add multiple items
	void		AddFrom( const BufferVal<T>& );
	void		AddFrom( const T*, size_t );
	void		AddFrom( const Array<T> &ar )		{ AddFrom(ar,ar); }
	//! Copy multiple items
	void		CopyFrom( const BufferVal<T> &b )	{ Empty(); AddFrom(b); }
	void		CopyFrom( const T* p, size_t c )	{ Empty(); AddFrom(p,c); }
	void		CopyFrom( const Array<T> &ar )		{ Empty(); AddFrom(ar); }
	//! Get an item
	T			Get();
	T			Pop()					{ return Get(); }
	//! Unget an item
	void		UnGet( T const& );
	void		UnPop( T const &a )		{ Unget(a); }
	//! Peek at the next item
	inline T&	Peek();
	//! Remove all the items (frees the memory)
	void		RemoveAll();
	//! Reserve enough space for 'mi' items
	void		Reserve( size_t mi )	{ if (mi>MaxItems) _Resize(mi); }
	//! Makes MaxItems == NumItems (no wasted space)
	void		Optimize();
	//! Empty but keeps the memory
	void		Empty()					{ NumItems = Begin = 0; }
	//! Return number of items in buffer
	size_t		Count() const			{ return NumItems; }
	//! Returns true if buffer is empty
	bool		IsEmpty() const			{ return NumItems==0; }
	//! Changes the delta/growth value
	void		SetDelta( size_t d )	{ Delta = (d>0?d:DEFAULT_DELTA); }
	//! Replace a (any) occurence of the specified value (operator ==)
	bool		FindAndReplace( T const &find, T const& replace );
#ifdef BUFFERVAL_REMOVE
	//! There's no efficient way to remove items. Do something like this instead:
	bool		Remove( T const &d )	{ return FindAndReplace(d,(T)0); }
#endif
	//! Check whether this buffer already contains a specific value (operator ==)
	bool		Contains( T const &d ) const	{ return _Find(d)!=NULL; }
	//! Returns item number x (with 0 <= x < Count)
	T			GetNo( size_t ) const;	// asserts if invalid index
	// Overloaded operators:
	operator size_t () const			{ return NumItems; }
	operator T* () const				{ return Data; }
	void operator = ( const BufferVal<T> &b ) { CopyFrom(b); }
private:
	size_t		Begin;
	inline size_t	_I( size_t i ) const { return (Begin+i) % MaxItems; }
	void	_Resize( size_t );			// creates array for MaxItems
	//! Finds a (any) occurence of the specified value (operator ==)
	T*			_Find( T const& ) const;
};
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T>
void BufferVal<T>::_Resize( size_t mi )
{
	THIS_ASSERT( mi>0, _T(": obsolete call to _Resize") );
	THIS_ASSERT( mi!=MaxItems, _T(": obsolete call to _Resize") );
	THIS_ASSERT( mi>=NumItems, _T(": resizing to small buffer") );
	
	T* New = _new(mi);								// New array (calls ctors)
	if (Data)
	{
		// Since resizing is always costly, I've optimized it for size
		for (size_t t=0; t<NumItems; t++)
			New[t] = Data[_I(t)];	// calls operator =
		_delete(Data);								// calls dtors
	}									
	Data = New;
	Begin = 0;
	MaxItems = mi;
}
///////////////////////////////////////////////////////////////////////
template <class T>
void BufferVal<T>::UnGet( T const &d )
{
	THIS_ASSERT( NumItems < MaxItems, "::UnGet on a full buffer" );
	if (Begin==0)
		Begin = MaxItems;
	Begin--;
	Data[Begin] = d;
	NumItems++;
}
///////////////////////////////////////////////////////////////////////
template <class T>
T BufferVal<T>::Get()
{
	THIS_ASSERT( NumItems>0, _T("::Pop on empty buffer") );
	T &tini = Data[Begin++];
	// Reset the pointer if we've emptied the buffer or are passed the end.
	if (--NumItems==0 || Begin>=MaxItems)
		Begin = 0;
	return tini;
}
///////////////////////////////////////////////////////////////////////
template <class T>
inline T& BufferVal<T>::Peek()
{
	THIS_ASSERT( NumItems>0, _T("::Peek on empty buffer") );
	return Data[Begin];
}
///////////////////////////////////////////////////////////////////////
template <class T>
T& BufferVal<T>::Add()
{
	if (NumItems >= MaxItems)
		_Resize( MaxItems + Delta );
	return Data[_I(NumItems++)];
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T>
void BufferVal<T>::AddFrom( const T *data, size_t i )
{
	THIS_ASSERT( i<1000000, _T("::AddFrom invalid parameter i") );
	THIS_ASSERT( data||!i, _T("::AddFrom with NULL pointer") );
	// We want to be able to simply append the new items (no wrap)
	size_t end = Begin + NumItems;
	if ((end+i) > MaxItems)
		_Resize( NumItems+i );
	for (size_t t=0; t<i; t++)
		Data[end + t] = data[t];		// calls operator =
	NumItems += i;
}
///////////////////////////////////////////////////////////////////////
template <class T>
void BufferVal<T>::RemoveAll()
{
	_delete( Data );
	Data = NULL;
	NumItems = MaxItems = 0;
	Begin = 0;
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T>
inline T BufferVal<T>::GetNo( size_t i ) const
{
	THIS_ASSERT( _smaller(i,NumItems), _T("::GetNo() : i>=0 && i<NumItems") );
	return Data[_I(i)];
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T>
void BufferVal<T>::Optimize() 
{ 
	if (MaxItems > NumItems)
	{
		if (NumItems==0) 
			RemoveAll(); 
		else 
			_Resize( NumItems );
	}
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T>
T* BufferVal<T>::_Find( T const &d ) const
{
	size_t end = Begin + NumItems;
	if (end > MaxItems)
	{
		// Part 1: from 0 to end of data
		end -= MaxItems;
		for (size_t t=0; t<end; t++)
			if (Data[t]==d)
				return &Data[t];
		// Part 2: from Begin to end of array
		end = MaxItems;
	}
	// Simple iteration from Begin to end
	for (size_t t=Begin; t<end; t++)
		if (Data[t]==d)
			return &Data[t];
	// Not found
	return NULL;
}
///////////////////////////////////////////////////////////////////////
template <class T>
bool BufferVal<T>::FindAndReplace( T const &find, T const& replace )
{
	T* f = _Find(find);
	if (f)
	{
		*f = replace;
		return true;
	}
	else
		return false;
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T>
void BufferVal<T>::AddFrom( const BufferVal<T> &b )
{ 	
	size_t end = b.NumItems + b.Begin;
	if (end > b.MaxItems)
	{
		// Set the size now (so we don't resize twice)
		Reserve( b.Count() );
		// Part 1: from Begin to end of array
		AddFrom( b.Data+b.Begin, b.MaxItems - b.Begin );
		// Part 2: from 0 to end of data
		AddFrom( b.Data, end - b.MaxItems );
	}
	else
	{
		// If we get here, the buffer is either simple (no wrap) or empty
		AddFrom( b.Data+b.Begin, b.Count() );
	}
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_BUFFERVAL_H_INCLUDED
///////////////////////////////// [citkt_BufferVal.h] END
///////////////////////////////// [citkt_Color.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_COLORS_H_INCLUDED
#define CITK_COLORS_H_INCLUDED
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#define DCOLOR_MAX		1.0f
#define DCOLOR_MIN		0.0f
#define DCOLOR_BLACK	0.01f					// also used by IsEqual
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
/////////////////////////////////////////////////////////////////////////////
struct DColor
{
//	static const float ooff = 1.0f/255.0f;		// would be nice
	float	r, g, b;
	static inline void ClipValUp( float &v ) { if (v>DCOLOR_MAX) v=DCOLOR_MAX; }
	static inline void ClipValLow( float &v ) { if (v<DCOLOR_MIN) v=DCOLOR_MIN; }
	static inline void ClipVal( float &v ) { if (v>DCOLOR_MAX) v=DCOLOR_MAX; else if (v<DCOLOR_MIN) v=DCOLOR_MIN; }
	static inline bool IsZero( float v ) { return v<DCOLOR_BLACK; }
	// Constructors
	DColor() {}
	DColor( cfloat__t rr, cfloat__t gg, cfloat__t bb ) : r(rr), g(gg), b(bb) {}
//	DColor( const DColor &c ) : r(c.r), g(c.g), b(c.b) {}
	explicit DColor( cfloat__t i ) : r(i), g(i), b(i) {}
	explicit DColor( const Vector3 &v ) : r(v.x), g(v.y), b(v.z) {}
	explicit DColor( const Color32& col ) { SetColor32(col); }
	DColor&		operator = ( cfloat__t i ) { r=b=g=i; return *this; }
//	DColor&		operator = ( const DColor &c ) { r=c.r; g=c.g; b=c.b; return *this; }
	DColor&		operator = ( const Vector3 &v ) { r=v.x; g=v.y; b=v.z; return *this; }
	DColor&		ClipUp() { ClipValUp(r); ClipValUp(g); ClipValUp(b); return *this; }
	DColor&		ClipLow() { ClipValLow(r); ClipValLow(g); ClipValLow(b); return *this; }
	DColor&		Clip() { ClipVal(r); ClipVal(g); ClipVal(b); return *this; }
	DColor		operator * ( cfloat__t i ) const { return DColor(r*i,g*i,b*i); }
	DColor		operator / ( cfloat__t i ) const { const float ooi=1.0f/i; return DColor(r*ooi,g*ooi,b*ooi); }
//	DColor		operator + ( cfloat__t i ) const { return DColor(r+i,g+i,b+i); }
//	DColor		operator - ( cfloat__t i ) const { return DColor(r-i,g-i,b-i); }
	DColor		operator * ( const DColor &c ) const { return DColor(r*c.r,g*c.g,b*c.b); }
	DColor		operator + ( const DColor &c ) const { return DColor(r+c.r,g+c.g,b+c.b); }
	DColor		operator - ( const DColor &c ) const { return DColor(r-c.r,g-c.g,b-c.b); }
	DColor&		operator *= ( cfloat__t i ) { return ScaleBy(i); }
	DColor&		operator /= ( cfloat__t i ) { return ScaleBy(1.0f/i); }
//	DColor&		operator += ( cfloat__t i ) { r+=i; g+=i; b+=i; return *this; }
//	DColor&		operator -= ( cfloat__t i ) { r-=i; g-=i; b-=i; return *this; }
	DColor&		operator *= ( const DColor &c ) { r*=c.r; g*=c.g; b*=c.b; return *this; }
	DColor&		operator += ( const DColor &c ) { r+=c.r; g+=c.g; b+=c.b; return *this; }
	DColor&		operator -= ( const DColor &c ) { r-=c.r; g-=c.g; b-=c.b; return *this; }
	Color32		GetColor32() const { return Color32(__ftoi(r*255),__ftoi(g*255),__ftoi(b*255),255); }
	DColor&		SetColor32( const Color32 &c ) { const float o=1/255.f; r=o*c.r; g=o*c.g; b=o*c.b; return *this; }
	DColor&		ScaleBy( cfloat__t i ) { r*=i; g*=i; b*=i; return *this; }
	DColor&		Set( cfloat__t i ) { r=b=g=i; return *this; }
	DColor&		Set( const DColor &d ) { r=d.r; g=d.g; b=d.b; return *this; }
	DColor&		Set( cfloat__t rr, cfloat__t gg, cfloat__t bb ) { r=rr; g=gg; b=bb; return *this; }
	DColor&		SetI( int i ) { r=b=g=(i/255.0); return *this; }
	DColor&		SetRGB( int rr, int gg, int bb ) { const float o=1/255.f; r=o*rr; g=o*gg; b=o*bb; return *this; }
	void		GetRGB( int &rr, int &gg, int &bb ) { rr=__ftoi(r*255); gg=__ftoi(g*255); bb=__ftoi(b*255); }
	DColor&		SetBW( cfloat__t i ) { r=g=b=i; return *this; }
	float		GetBW() const { return (r+g+b)/3.f; }
	float		GetMin() const { return _min3(r,g,b); }
	float		GetMax() const { return _max3(r,g,b); }
	Vector3		GetVector() const { return Vector3(r,g,b); }
	DColor&		SetVector( const Vector3 &v ) { r=v.x; g=v.y; b=v.z; return *this; }
				operator Vector3 () const { return GetVector(); }
				operator Color32 () const { return GetColor32(); }
	DColor		Blend( const DColor &col, cfloat__t amt ) const { return (*this)+(col-(*this))*amt; }
	//! Color is black if all the components are under 1%
	bool		IsBlack() const { return IsZero(r) && IsZero(g) && IsZero(b); }
	//! Two colors are equal if their difference is considered black
	bool		IsEqual( const DColor& c ) const { 
		return IsZero(_fabs(r-c.r)) && IsZero(_fabs(g-c.g)) && IsZero(_fabs(b-c.b)); }
	bool		AllLess( cfloat__t i ) const { return r<i && g<i && b<i; }
	bool		AllMore( cfloat__t i ) const { return r>i && g>i && b>i; }
	//! Generate a random color
	DColor&		Random( float mx =1.0f )	{ r=_frnd(mx); g=_frnd(mx); b=_frnd(mx); return *this; }
};
/////////////////////////////////////////////////////////////////////////////
inline DColor operator * ( cfloat__t i, const DColor &c )
{
	return DColor( c.r*i, c.g*i, c.b*i );	// return c*i; would have been ok too
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
struct DColorA : DColor
{
	float	a;
	// Constructors
	DColorA() {}
	DColorA( const DColor &c ) : DColor(c), a(1.f) {}
	DColorA( const DColor &c, cfloat__t aa ) : DColor(c), a(aa) {}
	DColorA( const Vector3 &v, cfloat__t aa ) : DColor(v), a(aa) {}
	DColorA( cfloat__t rr, cfloat__t gg, cfloat__t bb, cfloat__t aa =1.f ) : DColor(rr,gg,bb), a(aa) {}
	explicit DColorA( cfloat__t i ) : DColor(i) {}
	explicit DColorA( const Color32& col ) { SetColor32(col); }
	explicit DColorA( const Vector3 &v ) : DColor(v), a(1.f) {}
	Color32		GetColor32() const;
	DColorA&	SetColor32( const Color32 &c ) { return SetRGBA(c.r,c.g,c.b,c.a); }
	DColorA&	Set( const DColorA &d ) { r=d.r; g=d.g; b=d.b; a=d.a; return *this; }
	DColorA&	SetRGBA( int rr, int gg, int bb, int aa );
	DColorA&	SetAlpha( cfloat__t aa ) { a=aa; return *this; }
	float		GetAlpha() const { return a; }
				operator Color32 () const { return GetColor32(); }
	bool		IsEqual( const DColorA& c ) const;
};
/////////////////////////////////////////////////////////////////////////////
inline Color32 DColorA::GetColor32() const 
{ 
	return Color32(__ftoi(r*255),__ftoi(g*255),__ftoi(b*255),__ftoi(a*255)); 
}
/////////////////////////////////////////////////////////////////////////////
inline DColorA& DColorA::SetRGBA( int rr, int gg, int bb, int aa ) 
{ 
	const float o=1/255.f; 
	r=o*rr; g=o*gg; b=o*bb; a=o*aa; 
	return *this; 
}
/////////////////////////////////////////////////////////////////////////////
inline bool DColorA::IsEqual( const DColorA& c ) const 
{ 
	return IsZero(_fabs(r-c.r)) && IsZero(_fabs(g-c.g)) && IsZero(_fabs(b-c.b)) && IsZero(_fabs(a-c.a)); 
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Some predefined colors (should be static member constants)
#define COL_BLACK		DColor(0.f,0.f,0.f)
#define COL_BLUE		DColor(0.f,0.f,1.f)
#define COL_GREEN		DColor(0.f,1.f,0.f)
#define COL_CYAN		DColor(0.f,1.f,1.f)
#define	COL_RED			DColor(1.f,0.f,0.f)
#define COL_PURPLE		DColor(1.f,0.f,1.f)
#define COL_YELLOW		DColor(1.f,1.f,0.f)
#define COL_WHITE		DColor(1.f,1.f,1.f)
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITK_COLORS_H_INCLUDED
///////////////////////////////// [citkt_Color.h] END
///////////////////////////////// [citkt_CommandLine.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
#ifndef CITKT_COMMANDLINE_H_INCLUDED
#define CITKT_COMMANDLINE_H_INCLUDED
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
/////////////////////////////////////////////////////////////////////////////
class DCommandLine
{
public:
	struct argument_t
	{
		bool*	state;
		char	option;
		cstr_t	option_long;
		cstr_t	description;
		char_t*	param;
		int		param_len;
	} *arguments;
	bool	_Help;
	bool	_Verbose;
	DCommandLine() : arguments(NULL), argc(0), argv(NULL), _Verbose(false) {}
	bool			Parse( int argc, cstr_t* argv );	// C style
	bool			Parse( cstr_t all_args );			// Win32 style
	void			ShowHelp( cstr_t appname );
	// Command-line argument extraction. Returns NULL when done
	static cstr_t	ExtractArg( cstr_t in, String &out );
private:
	int		argc;
	cstr_t*	argv;
	bool	options_short( cstr_t options, int& t);
	bool	options_long( cstr_t options, int& t);
	bool	options_none( cstr_t options );
};
///////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_DCOMMANDLINE_H_INCLUDED
///////////////////////////////// [citkt_CommandLine.h] END
///////////////////////////////// [citkt_CRC32.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
//
//  CRC32.h		crc32 utility class
//
#ifndef CITKT_CRC32_H_INCLUDED
#define CITKT_CRC32_H_INCLUDED
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
//////////////////////////////////////////////////////////////////////////////
typedef unsigned long crc_t;
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
class CRC32
{
public:
	CRC32();
	void			Begin();
	crc_t			End() const;
	void			AddByte( unsigned char b ) { cur = Table[(b^cur)&255] ^ (cur>>8); }
	void			AddBlock( const void*, unsigned long );
	void			AddString( cstr_t );
	static crc_t	DoBlock( const void*, unsigned long );
	static crc_t	DoString( cstr_t );
private:
	crc_t			cur;
	static crc_t	Table[256];
	static void		MakeTable();
};
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_CRC32_H_INCLUDED
///////////////////////////////// [citkt_CRC32.h] END
///////////////////////////////// [citkt_EnumSet.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITKT_ENUMSET_H_INCLUDED
#define CITKT_ENUMSET_H_INCLUDED
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
///////////////////////////////////////////////////////////////////////////////
template <class TEnum, class TContainer =unsigned long>
class DEnumSet
{
public:
	TContainer		Flags;
	DEnumSet() : Flags(0) {}
	DEnumSet( const DEnumSet &b ) : Flags(b.Flags) {}
	DEnumSet( const TContainer t ) : Flags(t) {}
	DEnumSet( const TEnum a ) : Flags(1<<a) {}
	DEnumSet( const TEnum a, const TEnum b ) : Flags((1<<a)|(1<<b)) {}
	DEnumSet( const TEnum a, const TEnum b, const TEnum c ) : Flags((1<<a)|(1<<b)|(1<<c)) {}
	// Assignment operator:
	DEnumSet&		operator = ( const TContainer f )	{ Flags=f; return *this; }
	DEnumSet&		operator = ( const TEnum f )		{ Flags=1<<f; return *this; }
	// Operators:
	bool			operator [] ( const TEnum b ) const	{ return IsSet(b); }
	void			operator &= ( const TEnum f ) { Flags &= 1<<f; }
	void			operator |= ( const TEnum f ) { Flags |= 1<<f; }
	void			operator ^= ( const TEnum f ) { Flags ^= 1<<f; }
	DEnumSet		operator & ( const TEnum f ) const { return Flags & (1<<f); }
	DEnumSet		operator | ( const TEnum f ) const { return Flags | (1<<f); }
	DEnumSet		operator ^ ( const TEnum f ) const { return Flags ^ (1<<f); }
//	bool			operator == ( const TContainer f ) const { return Flags==f; }
//	bool			operator != ( const TContainer f ) const { return Flags!=f; }
	// Type-cast operator:
					operator TContainer () const { return Flags; }
	// Methods:
	inline void		Set( const TEnum bla ) { Flags |= 1<<bla; }
	inline void		Clear( const TEnum bla ) { Flags &= ~(1<<bla); }
	inline void		Toggle( const TEnum bla ) { Flags ^= (1<<bla); }
	inline void		Set( const TEnum bla, bool set ) { set?(Flags|=1<<bla):(Flags&=~(1<<bla)); }
	inline bool		IsSet( const TEnum bla ) const { return (Flags&(1<<bla))!=0; }
};
/////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_ENUMSET_H_INCLUDED
///////////////////////////////// [citkt_EnumSet.h] END
///////////////////////////////// [citkt_Face3.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITKT_FACE3_H_INCLUDED
#define CITKT_FACE3_H_INCLUDED
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citkt_Plane.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITKT_PLANE_H_INCLUDED
#define CITKT_PLANE_H_INCLUDED
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citkt_Matrix33.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
//
//  Matrix33.hpp	3x3 Matrix Math Class/Template
//
//  Copyright by Copac I.T. 1997. All rights reserved.
//
// Revision log:
//		11/06 23:43	L.Lunesu
#ifndef CITKT_MATRIX33_H_INCLUDED
#define CITKT_MATRIX33_H_INCLUDED
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
/////////////////////////////////////////////////////////////////////////////
#define C_RIGHT	x					//0
#define C_UP	y					//1
#define C_PN	z					//2
#define V_RIGHT	i					//0
#define V_UP	j					//1
#define V_PN	k					//2
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class Matrix33
{
public:					
	Vector3		i, j, k;
	static const Matrix33 I;
	// Default Constructor:
	inline Matrix33() {}
	// Constructors:
	inline Matrix33( const Vector3& a, const Vector3& b, const Vector3& c ) { Set(a,b,c); }
	inline Matrix33( const Vector3 v[3] ) { Set(v); }
	inline Matrix33( const float a[9] ) { Set(a); }
	inline Matrix33( const double a[9] ) { Set(a); }
	inline Matrix33( cfloat__t ax, cfloat__t ay, cfloat__t az,
					 cfloat__t bx, cfloat__t by, cfloat__t bz,
					 cfloat__t cx, cfloat__t cy, cfloat__t cz ) :
						i(ax,ay,az), j(bx,by,bz), k(cx,cy,cz) {}
	// Copy-constructor (let compiler do it)
//	inline Matrix33( const Matrix33 &m ) : i(m.i), j(m.j), k(m.k) {}//{ Set(m); }
	
	// Operators:
//	Matrix33&	operator  = ( const Matrix33 &m ) { return Set(m); }
	Matrix33&	operator += ( const Matrix33 & );
	Matrix33&	operator -= ( const Matrix33 & );
	Matrix33&	operator *= ( const Matrix33 & );
	Matrix33&	operator /= ( const Matrix33 & );			// * Transponed
	Matrix33&	operator *= ( cfloat__t );					// Scalar
	Matrix33&	operator /= ( cfloat__t );					// Scalar
	// Const-operators:
	Matrix33	operator + ( const Matrix33 & ) const;
	Matrix33	operator - ( const Matrix33 & ) const;
	Matrix33	operator * ( const Matrix33 & ) const;
	Matrix33	operator / ( const Matrix33 & ) const;		// * Transponed
	Matrix33	operator * ( cfloat__t ) const;				// Scalar
	Matrix33	operator / ( cfloat__t ) const;				// Scalar
	Vector3		operator * ( const Vector3 & ) const;		// Transformation
	Vector3		operator / ( const Vector3 & ) const;		// Back-Transformation
	inline Vector3&	operator [] ( const int p )				// Array Access
		{ return (&i)[p]; }					
	inline const Vector3& operator [] ( const int p ) const	// Array Access
		{ return (&i)[p]; }
	inline float__t&	operator () ( const int p, const int v )// Array Access
		{ return (&i)[p][v]; }
	inline double	operator () ( const int p, const int v ) const
		{ return (&i)[p][v]; }
	inline Vector3	operator () ( const Vector3 &v ) const	// Transform
		{ return v * SELF; }
	inline Matrix33 operator + () const						// Self
		{ return (*this); }
	inline Matrix33 operator - () const						// Negate
		{ return Matrix33( -i.x, -i.y, -i.z, -j.x, -j.y, -j.z, -k.x, -k.y, -k.z ); }
	inline Matrix33 operator ! () const						// Transpone
		{ return Matrix33( i.x, j.x, k.x, i.y, j.y, k.y, i.z, j.z, k.z ); }
	// Initialisation:
	Matrix33&	Set( const Matrix33& );
	Matrix33&	Set( const Vector3& a, const Vector3& b, const Vector3& c ) { i=a; j=b; k=c; return *this; }
	Matrix33&	Set( const Vector3 v[3] ) { i.Set(v[0]); j.Set(v[1]); k.Set(v[2]); return *this; }
	Matrix33&	Set( const float a[9] ) { i.Set(a); j.Set(a+3); k.Set(a+6); return *this; }
	Matrix33&	Set( const double a[9] ) { i.Set(a); j.Set(a+3); k.Set(a+6); return *this; }
	Matrix33&	Set( cfloat__t ax, cfloat__t ay, cfloat__t az,
					 cfloat__t bx, cfloat__t by, cfloat__t bz,
					 cfloat__t cx, cfloat__t cy, cfloat__t cz );
	Matrix33&	Identity() { return Set(I); }
	Matrix33&	Scaling( cfloat__t s ) { i.x=j.y=k.z=(float__t)s; i.y=i.z=j.x=j.z=k.x=k.y=0.f; return *this; }
	Matrix33&	Scaling( cfloat__t x, cfloat__t y, cfloat__t z ) { i.x=x; j.y=y; k.z=z; i.y=i.z=j.x=j.z=k.x=k.y=0.f; return *this; }
	Matrix33&	Scaling( const Vector3 &v ) { i.x=v.x; j.y=v.y; k.z=v.z; i.y=i.z=j.x=j.z=k.x=k.y=0.f; return *this; }
	Matrix33&	RotationX( cfloat__t el );
	Matrix33&	RotationY( cfloat__t az );
	Matrix33&	RotationZ( cfloat__t tw );
	Matrix33&	FromEuler( cfloat__t az, cfloat__t el, cfloat__t tw );
	Matrix33&	FromAxisAngle( const Vector3&, cfloat__t );
	// Euler returned by this function: -pi<az<pi, -pi/2<el<pi/2, -pi<tw<pi
	void		ToEuler( float__t &az, float__t &el, float__t &tw ) const;
	// Various Functions:
	Matrix33&	Transpone();
	Matrix33&	Normalize();							// SLOW!
	Matrix33&	Invert();								// SLOW!
	Matrix33	Adjoint() const;						// SLOW!
	Matrix33	Inverse() const;						// SLOWER!
	Matrix33&	ScaleBy( cfloat__t s ) { i.x*=s; j.y*=s; k.z*=s; return *this; } 
	Matrix33&	ScaleBy( cfloat__t x, cfloat__t y, cfloat__t z ) { i.x*=x; j.y*=y; k.z*=z; return *this; } 
	Matrix33&	ScaleBy( const Vector3 &s ) { i.x*=s.x; j.y*=s.y; k.z*=s.z; return *this; } 
	Matrix33&	RotateByX( cfloat__t d_el );
	Matrix33&	RotateByY( cfloat__t d_az );
	Matrix33&	RotateByZ( cfloat__t d_tw );
	double		Determinant() const;
	double		Trace() const { return i.x + j.y + k.z; }
	Vector3		GetScaling() const { return Vector3( i.Length(), j.Length(), k.Length() ); }
	double		GetMaxScaling() const { return _fsqrt(_max3( i.SqrLength(), j.SqrLength(), k.SqrLength() )); }
	bool		IsOrthogonal() const;
	bool		IsNormalized() const;
	bool		IsOrthonormal() const;
	bool		IsIdentity() const;
	bool		IsEqual( const Matrix33 &o ) const { return o.i.IsEqual(i) && o.j.IsEqual(j) && o.k.IsEqual(k); }
	bool		IsLeftHanded() const { return ((i%j)^k) >= 0.0f; }
	inline Vector3			Column( int p ) const { return Vector3(i[p],j[p],k[p]); }
	inline const Vector3&	Row( int p ) const { return (&i)[p]; }
	float__t*	GetData() { return &i.x; }
	// Transform normals
	void		TransformNormals( int num, const Vector3* loc, Vector3* world, int stride =0 ) const;
	// Transform vectors; takes additional position/offset
	void		TransformPoints( int num, const Vector3* loc, Vector3* world, const Vector3&, int stride =0 ) const;
	// Friend Functions:
	friend	Matrix33 operator * ( cfloat__t, const Matrix33 & );
#ifdef USE_IOSTREAM
	friend ostream& operator << ( ostream&, const Matrix33& );
#endif
};
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#define SCALEMATRIX(s)		Matrix33(s,0.f,0.f,0.f,s,0.f,0.f,0.f,s)
#define ScaleMatrix(s)		SCALEMATRIX(s)
#define IDENTITYMATRIX		(Matrix33::I)
#define IdentityMatrix		(Matrix33::I)
#define RotationMatrixI		RotationMatrixX
#define RotationMatrixJ		RotationMatrixY
#define RotationMatrixK		RotationMatrixZ
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
inline Matrix33& Matrix33::RotationX( cfloat__t a)
{
	float__t c, s;
	__fsincos(a,&s,&c);
	return Set(1,0,0,0,c,s,0,-s,c);
}
/////////////////////////////////////////////////////////////////////////////
inline Matrix33& Matrix33::RotationY( cfloat__t a)
{
	float__t c, s;
	__fsincos(a,&s,&c);
	return Set(c,0,-s,0,1,0,s,0,c);
}
/////////////////////////////////////////////////////////////////////////////
inline Matrix33& Matrix33::RotationZ( cfloat__t a)
{
	float__t c, s;
	__fsincos(a,&s,&c);
	return Set(c,s,0,-s,c,0,0,0,1);
}
/////////////////////////////////////////////////////////////////////////////
inline Matrix33 RotationMatrixX( cfloat__t a)
{
	float__t c, s;
	__fsincos(a,&s,&c);
	return Matrix33(1,0,0,0,c,s,0,-s,c);
}
/////////////////////////////////////////////////////////////////////////////
inline Matrix33 RotationMatrixY( cfloat__t a )
{
	float__t c, s;
	__fsincos(a,&s,&c);
	return Matrix33(c,0,-s,0,1,0,s,0,c);
}
/////////////////////////////////////////////////////////////////////////////
inline Matrix33 RotationMatrixZ( cfloat__t a )
{
	float__t c, s;
	__fsincos(a,&s,&c);
	return Matrix33(c,s,0,-s,c,0,0,0,1);
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
inline Matrix33& Matrix33::Set( cfloat__t ax, cfloat__t ay, cfloat__t az,
								cfloat__t bx, cfloat__t by, cfloat__t bz,
								cfloat__t cx, cfloat__t cy, cfloat__t cz )
{
	i.Set( ax, ay, az );
	j.Set( bx, by, bz );
	k.Set( cx, cy, cz );
	return *this;
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
inline bool Matrix33::IsOrthogonal() const
{
	return _feqz(i^j) && _feqz(j^k) && _feqz(i^k);
}
/////////////////////////////////////////////////////////////////////////////
inline bool Matrix33::IsNormalized() const
{
	return i.IsNormal() && j.IsNormal() && k.IsNormal();
}
/////////////////////////////////////////////////////////////////////////////
inline bool Matrix33::IsOrthonormal() const
{
	return IsOrthogonal() && IsNormalized();
}
/////////////////////////////////////////////////////////////////////////////
inline bool Matrix33::IsIdentity() const
{
	return (i - I.i).IsZero() && (j - I.j).IsZero() && (k - I.k).IsZero();
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_MATRIX33_H_INCLUDED
///////////////////////////////// [citkt_Matrix33.h] END
///////////////////////////////// [citkt_Line3.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITKT_LINE3_H_INCLUDED
#define CITKT_LINE3_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
///////////////////////////////////////////////////////////////////////////////
class Line3
{
public:
	// Provided for compatibility with Ray3 and LinePiece3 (does nothing)
	inline float__t ClipT( cfloat__t T ) const				{ return T; }
	// Point of origin
	Vector3		Pos;
	// Direction (need not be normal)
	Vector3		Dir;
	// Constructors
	Line3() {}
	Line3( const Vector3 &pos, const Vector3 &dir ) : Pos(pos), Dir(dir) {}
	Line3( const Line3 &l ) : Pos(l.Pos), Dir(l.Dir) {}
	// Calculate offset
	float__t	CalcT( const Vector3 &p ) const				{ return CalcT2(p)/Dir.SqrLength(); }
	float__t	CalcT2( const Vector3 &p ) const			{ return (p-Pos)^Dir; }
	// Calculate the vector at specified offset
	Vector3		CalcVector( cfloat__t T ) const				{ return Pos + T*Dir; }
	// Closest point on this line
	Vector3		ClosestPoint( const Vector3 &p ) const		{ return CalcVector(CalcT(p)); }
	// Shortest vector from 'p' to this line
	Vector3		Diff( const Vector3 &p ) const				{ return ClosestPoint(p) - p; }
	// Shortest distance from vector 'p' to line
	float__t	Distance( const Vector3 &p ) const			{ return Diff(p).Length(); }
	// Distance between two points on two lines
	float__t	Distance( const Line3& L, cfloat__t T1, cfloat__t T2 ) const {
		return CalcVector(T1).Distance(L.CalcVector(T2)); }
	// Initialization methods:
	Line3&		Set( const Vector3 &p, const Vector3 &d )	{ Pos=p; Dir=d; return SELF; }
	Line3&		Set( const Line3 &l )						{ Pos=l.Pos; Dir=l.Dir; return SELF; }
	// Transformation methods
	Line3&		Rotate( const Matrix33 &R )					{ Dir *= R; Pos *= R; return SELF; }
	Line3&		Translate( const Vector3 &P )				{ Pos += P; return SELF; }
	Line3&		Transform( const Matrix33 &R, const Vector3 &P );
	Line3&		TransformBest( const Matrix33 &M, const Vector3 &P );
	// Distance between two lines
	float__t	Distance( const Line3& L ) const;
	// Calculate the parameters of the closest points
	bool		ClosestPoints( const Line3& L, float__t& T1, float__t& T2 ) const;
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
class Ray3 : public Line3
{
public:
	// Clips T to [0.0...>
	inline float__t ClipT( cfloat__t T ) const				{ return T<0.f?0.f:T; }
	// Constructors
	Ray3() {}
	Ray3( const Vector3 &pos, const Vector3 &dir ) : Line3(pos,dir) {}
	Ray3( const Line3 &l ) : Line3(l) {}
	Ray3( const Ray3 &l ) : Line3(l) {}
	// Calculate offset
	float__t	CalcT( const Vector3 &p ) const				{ return ClipT(Line3::CalcT(p)); }
	// Shortest vector from 'p' to this line
	Vector3		Diff( const Vector3 &p ) const				{ return p - CalcVector(CalcT(p)); }
	// Shortest distance from vector 'p' to line
	float__t	Distance( const Vector3 &p ) const			{ return Diff(p).Length(); }
	// Calculate the parameters of the closest points (ray - line)
	bool		ClosestPoints( const Line3& L, float__t& T1, float__t& T2 ) const {
		return Line3::ClosestPoints(L,T1,T2)?T1=ClipT(T1),true:false; }
	// Calculate the parameters of the closest points (ray - ray)
	bool		ClosestPoints( const Ray3& R, float__t& T1, float__t& T2 ) const;
	// Distance between ray and line; calculate closest points first
	float__t	Distance( const Line3& L ) const {
		float__t T1,T2; return ClosestPoints(L,T1,T2)?Line3::Distance(L,T1,T2):Line3::Distance(L); }
	// Distance between ray and ray; calculate closest points first
	float__t	Distance( const Ray3& R ) const { 
		float__t T1,T2; return ClosestPoints(R,T1,T2)?Line3::Distance(R,T1,T2):Line3::Distance(R); }
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
class LinePiece3 : public Line3
{
public:
	// Clips T to [0.0...Length]
	inline float__t ClipT( cfloat__t T ) const				{ return T<0.f?0.f:(T>Length?Length:T); }
	// Length of the line piece (multiplier for Dir; 1.0 by default)
	float__t	Length;
	// Constructors
	LinePiece3() : Length(1.0f) {}
	LinePiece3( const Vector3 &pos, const Vector3 &dir ) : Line3(pos,dir), Length(1.0f) {}
	LinePiece3( const Line3 &l ) : Line3(l), Length(1.0f) {}
	LinePiece3( const LinePiece3 &l ) : Line3(l), Length(l.Length) {}
	explicit LinePiece3( cfloat__t l ) : Length(l) {}
	// New method the returns the end-point of the line segment
	Vector3		EndPoint() const							{ return CalcVector(Length); }
	// Calculate offset on line-piece for a given point
	float__t	CalcT( const Vector3 &p ) const				{ return ClipT(Line3::CalcT(p)); }
	// Shortest vector from 'p' to this line
	Vector3		Diff( const Vector3 &p ) const				{ return p - CalcVector(CalcT(p)); }
	// Shortest distance from vector 'p' to line
	float__t	Distance( const Vector3 &p ) const			{ return Diff(p).Length(); }
	// Calculate the parameters of the closest points (piece - line)
	bool		ClosestPoints( const Line3& L, float__t& T1, float__t& T2 ) const {
		return Line3::ClosestPoints(L,T1,T2)?T1=ClipT(T1),true:false; }
	// Calculate the parameters of the closest points (piece - ray)
	bool		ClosestPoints( const Ray3& L, float__t& T1, float__t& T2 ) const;
	// Calculate the parameters of the closest points (piece - piece)
	bool		ClosestPoints( const LinePiece3& L, float__t& T1, float__t& T2 ) const;
	// Distance between piece and line; calculate closest points first
	float__t	Distance( const Line3& L ) const { 
		float__t T1,T2; return ClosestPoints(L,T1,T2)?Line3::Distance(L,T1,T2):Line3::Distance(L); }
	// Distance between piece and ray; calculate closest points first
	float__t	Distance( const Ray3& R ) const { 
		float__t T1,T2; return ClosestPoints(R,T1,T2)?Line3::Distance(R,T1,T2):Line3::Distance(R); }
	// Distance between piece and piece; calculate closest points first
	float__t	Distance( const LinePiece3& P ) const { 
		float__t T1,T2; return ClosestPoints(P,T1,T2)?Line3::Distance(P,T1,T2):Line3::Distance(P); }
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_LINE3_H_INCLUDED
///////////////////////////////// [citkt_Line3.h] END
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
/////////////////////////////////////////////////////////////////////////////
class Plane3
{
public:
	Normal3		normal;
	float__t		dist;
	// Default constructor (does not initialize the members)
	Plane3() {}
	// Copy-constructor (no: let the compiler do it)
//	Plane3( const Plane3 &p ) : normal(p.normal), dist(p.dist) {}
	// Constructors
	Plane3( const Normal3 &n, cfloat__t d ) : normal(n), dist(d) {}
	Plane3( cfloat__t d, const Normal3 &n ) : normal(n), dist(d) {}
	Plane3( const Normal3 &n, const Vector3 &v ) { Set(n,v); }
	explicit Plane3( const Vector3 v[3] ) { Set(v[0],v[1],v[2]); }
	Plane3( const Vector3 &v1, const Vector3 &v2, const Vector3 &v3 ) { Set(v1,v2,v3); }
	// Operators (no: let the compiler do it)
//	inline Plane3&		operator = ( const Plane3 &p ) { normal=p.normal; dist=p.dist; return *this; }
	// Math
	inline Vector3		GetPivot() const						{ return normal*dist; }
	inline Plane3&		SetPivot( Vector3 const &v )			{ dist=v^normal; return *this; }
	inline double		PointDist( Vector3 const &v ) const		{ return (v^normal); }
	inline double		Distance( Vector3 const &v ) const		{ return dist - (v^normal); }
	inline bool			CheckVector( Vector3 const &v ) const	{ return (v^normal) <= dist; }
	bool				IsCoplanar( const Plane3& p ) const;
	inline Plane3&		Flip() { normal.Flip(); dist=-dist; return *this; }
	inline Plane3		Flipped() const { Plane3 p(*this) ; return (p.Flip()) ; } 
	inline double		Dist_YZ( cfloat__t y, cfloat__t z ) const
		{ return (dist - normal.y * y - normal.z * z) / normal.x; }
	inline double		Dist_XZ( cfloat__t x, cfloat__t z ) const
		{ return (dist - normal.x * x - normal.z * z) / normal.y; }
	inline double		Dist_XY( cfloat__t x, cfloat__t y ) const
		{ return (dist - normal.x * x - normal.y * y) / normal.z; }
	Plane3&				Rotate( const Matrix33 &R )			{ normal *= R; return *this; }
	Plane3&				Translate( const Vector3 &P )		{ dist += (P ^ normal); return *this; }
	Plane3&				Transform( const Matrix33 &rotation, const Vector3 &translation );
	Plane3&				TransformBest( const Matrix33 &matrix, const Vector3 &translation );
	inline void			Normalize() { const double nl=normal.Length(); dist*=nl; normal/=nl; }
	// Intersection with line 'l'
	inline double		CalcT( const Line3 &l ) const { return Distance(l.Pos) / (normal^l.Dir); }
	inline Vector3		Intersect( const Line3 &l ) const { return l.CalcVector( CalcT(l) ); }
	// Closest point from plane to point 'p'
	inline Vector3		ClosestPoint( const Vector3 &p ) const { return p + Diff(p); }
	// Shortest vector from point 'p' to this plane
	inline Vector3		Diff( const Vector3 &p ) const { return Distance(p)*normal; }
	// Initialization
	inline Plane3&		Set( const Plane3 &p ) { normal=p.normal; dist=p.dist; return *this; }
	inline Plane3&		Set( const Normal3 &n, cfloat__t d ) { normal=n; dist=d; return *this; }
	inline Plane3&		Set( cfloat__t d, const Normal3 &n ) { normal=n; dist=d; return *this; }
	inline Plane3&		Set( const Normal3 &n, const Vector3 &v ) { normal=n; dist=v^n; return *this; }
	inline Plane3&		Set( Vector3 const &v1, Vector3 const &v2, Vector3 const &v3 ) {
		normal = ((v1-v2)%(v3-v2)).Normalized(); dist = v2^normal; return *this; }
	// Mirror functions
	inline Vector3		MirrorPoint( const Vector3& v ) const { return ( v + (2.0f * Distance( v )) * normal ) ; } 
	inline Normal3		MirrorDirection( const Normal3& d ) const { return ( d - (2.0f * ( d ^ normal )) * normal ) ; }
	inline Plane3		MirrorPlane( const Plane3& p ) const ;
	inline Line3&		MirrorLine( Line3& p ) const ;		// Accepts Ray / LinePiece as well!
	// Intersection with another plane
	Line3				Intersect( const Plane3 &p ) const;
	enum clip_t {
		BOTH_OUT,
		CLIPPED_V1,
		CLIPPED_V2,
		BOTH_IN
	};
	// Clip an edge (two vectors); changes either v1 or v2
	clip_t				ClipEdge( Vector3 &v1, Vector3 &v2 );
};
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
inline bool Plane3::IsCoplanar( const Plane3& p ) const
{ 
	const double dot = normal ^ p.normal ;
	if( dot > (1.0f - EPSILON) )
		return _feqz(dist - p.dist);
	if( dot < (-1.0f + EPSILON) )
		return _feqz(dist + p.dist);
	return false ;
}
/////////////////////////////////////////////////////////////////////////////
inline Plane3& Plane3::Transform( const Matrix33 &rotation, const Vector3 &translation ) 
{
	// Calculate the new normal
	normal *= rotation; 
	// Calculate the new distance
	dist += (translation ^ normal); 
	return *this; 
}
/////////////////////////////////////////////////////////////////////////////
inline Plane3 Plane3::MirrorPlane( const Plane3& p ) const
{
	Plane3 mp ;
	// Mirror the plane direction
	mp.normal = MirrorDirection( p.normal ) ;
	// Create a point on the plane, mirror it, and calculate plane-distance
	mp.dist = MirrorPoint( p.dist * p.normal ) ^ mp.normal ;
	return mp ;
}
/////////////////////////////////////////////////////////////////////////////
inline Line3& Plane3::MirrorLine( Line3& p ) const
{
	p.Pos = MirrorPoint(p.Pos);
	p.Dir = MirrorDirection(p.Dir);
	return p;
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_PLANE_H_INCLUDED
///////////////////////////////// [citkt_Plane.h] END
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
/////////////////////////////////////////////////////////////////////////////
class DFace3
{
public:
	enum {
		NumVertices = 3
	};
	//! The three vertices of this face
	Vector3		v[3];
	// Default constructor (does not initialize the members)
	inline DFace3() {}
	// Copy-constructor (let compiler do it)
//	DFace3( const DFace3& );
	// Constructors
	explicit DFace3( const Vector3 vs[3] ) { v[0]=vs[0]; v[1]=vs[1]; v[2]=vs[2]; }
	DFace3( const Vector3 &v0, const Vector3 &v1, const Vector3 &v2 );
	DFace3&		Set( const Vector3 *vs, int i0, int i1, int i2 );
	DFace3&		Set( const Vector3 vs[3] ) { v[0]=vs[0]; v[1]=vs[1]; v[2]=vs[2]; return *this; }
	DFace3&		Set( const Vector3 &v0, const Vector3 &v1, const Vector3 &v2 );
	//! Calculates the face normal (always normalized)
	Normal3		CalcNormal() const;
	//! Surface area
	float__t	CalcArea() const;
	//! Volume of pyramid below this face
	float__t	CalcVolume() const;
	//! Check the face against a plane; returns number of vertices inside
	int			CheckAgainstPlane( const Plane3& ) const;
	//! Check the face against a plane
	bool		CheckAgainstPlaneIn( const Plane3& ) const;
	bool		CheckAgainstPlaneOut( const Plane3& ) const;
	//! Returns the mid-point of this face
	Vector3		MidPoint() const		{ return (v[0]+v[1]+v[2])*(1.f/3.f); }
				
	//! Obsolete, retained for backwards compatibility (use Intersect)
	bool		IsUnder( const Vector3& ) const;
	//! Obsolete, retained for backwards compatibility
	Vector3		GetVector( const int i ) const				{ return v[i]; }
	//! Fancy intersection test
	bool		Intersect( const Line3&, Vector3& result, bool cull ) const;
	//! Flip the order of the vertices (by swapping the first two vertices)
	void		Flip()									{ _swap(v[0],v[1]); }
	//! Clip this face against a plane; if returning 2, second face was filled
	int			ClipAgainstPlane( const Plane3&, DFace3& );
	//! Clip this face against a plane; also creates outside faces
	int			ClipAgainstPlane( const Plane3&, DFace3&, DFace3 outside[2] );
	// Fancy intersection test
	//  result.x/y		(s,t) on the triangle (UV)
	//  result.z		offset in line
	// Intersection point can be calculated as: line.Pos + result.z*line.Dir
	static bool	Intersect( const Vector3&, const Vector3&, const Vector3&, 
		const Line3&, Vector3& result, bool cull );
};
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
inline DFace3::DFace3( const Vector3 &v0, const Vector3 &v1, const Vector3 &v2 )
{
	v[0] = v0;
	v[1] = v1;
	v[2] = v2;
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
inline DFace3& DFace3::Set( const Vector3 *vs, int i0, int i1, int i2 ) 
{ 
	v[0] = vs[i0]; 
	v[1] = vs[i1]; 
	v[2] = vs[i2]; 
	return *this; 
}
/////////////////////////////////////////////////////////////////////////////
inline DFace3& DFace3::Set( const Vector3 &v0, const Vector3 &v1, const Vector3 &v2 )
{
	v[0] = v0;
	v[1] = v1;
	v[2] = v2;
	return *this;
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
inline bool DFace3::Intersect( const Line3 &line, Vector3& result, bool cull ) const
{
	return Intersect( v[0], v[1], v[2], line, result, cull );
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_FACE3_H_INCLUDED
///////////////////////////////// [citkt_Face3.h] END
///////////////////////////////// [citkt_File.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITKT_FILE_H_INCLUDED
#define CITKT_FILE_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#if defined _WIN32 || defined _XBOX
// we us a void* instead of HANDLE to prevent having to include windows.h
# define CITK_FILE_WIN32
#else
# include <stdio.h>
#endif
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
///////////////////////////////////////////////////////////////////////////////
typedef int64	filepos_t;
///////////////////////////////////////////////////////////////////////////////
class DFile
{
public:
	// traits
#if defined _WIN32 || defined _XBOX
	enum { CRLF=1, STDIO=0 };
	typedef void* file_t;
#else
	enum { CRLF=0, STDIO=1 };
	typedef FILE* file_t;
#endif
	DFile();
	virtual ~DFile();
	bool	Open( cstr_t, bool read_write =false );
	bool	Create( cstr_t, bool read_write =true );
	bool	Append( cstr_t );
	bool	Close();
	bool	Opened() const;
	// IO methods
	uint	ReadBlock( void* data, uint count, uint sizet = 1 );
	uint	WriteBlock( const void * data, uint count, uint sizet = 1 );
	byte	ReadByte();
	uint	WriteByte( byte );
	bool	EndOfFile() const;
	void	Flush();
	bool	SeekTo( filepos_t );
	bool	SeekBy( filepos_t );
	bool	SeekEnd( filepos_t );
	filepos_t	FilePos() const;
	filepos_t	FileSize() const;
	// Emulated (using the block methods)
	uint	WriteWord( ushort );
	uint	WriteDWord( ulong );
	uint	WriteFloat( float );
	uint	WriteDouble( double );
	uint	WriteString( cstr_t, bool term_null=false );
	uint	WriteLine( cstr_t, bool crlf =CRLF );
	ushort	ReadWord();
	ulong	ReadDWord();
	float	ReadFloat();
	double	ReadDouble();
	String	ReadString();
//	int	CDECL Scanf( cstr_t, ... );
	int	CDECL Printf( cstr_t, ... );
	// FILE handle access
	file_t	Detach();
	bool	Attach( file_t f );
	bool	Attach( DFile *f );
	bool	Attach( DFile &f );
	
	file_t	GetHandle() const		{ return fh; }
private:
	file_t	fh;			// file stream handle
	// Hidden members, not implemented (to avoid generated copy):
	DFile( const DFile& );
	void operator = ( const DFile& );
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_FILE_H_INCLUDED
///////////////////////////////// [citkt_File.h] END
///////////////////////////////// [citkt_FileBE.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITKT_FILEBE_H_INCLUDED
#define CITKT_FILEBE_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
///////////////////////////////////////////////////////////////////////////////
class DFileBE : public DFile
{
public:
	void	WriteWord( ushort const );
	void	WriteDWord( ulong const );
	void	WriteFloat( float const );
	void	WriteDouble( double const );
	ushort	ReadWord();
	ulong	ReadDWord();
	float	ReadFloat();
	double	ReadDouble();
	size_t	ReadBlock( void* const, size_t, size_t =1 );
	size_t	WriteBlock( void const * const, size_t, size_t =1 );
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_FILEBE_H_INCLUDED
///////////////////////////////// [citkt_FileBE.h] END
///////////////////////////////// [citkt_Flags.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITKT_FLAGS_H_INCLUDED
#define CITKT_FLAGS_H_INCLUDED
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
///////////////////////////////////////////////////////////////////////////////
enum {
	F_ALL = ~0
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
template <class T>
union DFlagsT
{
	T		flags;
	struct {
		T	b0:1,  b1:1,  b2:1,  b3:1,  b4:1,  b5:1,  b6:1,  b7:1,
			b8:1,  b9:1,  b10:1, b11:1, b12:1, b13:1, b14:1, b15:1, 
			b16:1, b17:1, b18:1, b19:1, b20:1, b21:1, b22:1, b23:1, 
			b24:1, b25:1, b26:1, b27:1, b28:1, b29:1, b30:1, b31:1;
	};
	// Constructor:
	DFlagsT() : flags(0) {}
	DFlagsT(const T v) : flags(v) {}
	// Assignment operator:
	DFlagsT&		operator = ( const T f )			{ flags=f; return *this; }
	// operators:
	bool		operator [] ( const int b ) const	{ return TestBit(b); }
	T			operator () ( const T f ) const		{ return flags&f; }
	DFlagsT&		operator &= ( const T f )			{ return And(f); }
	DFlagsT&		operator |= ( const T f )			{ return Or(f); }
	DFlagsT&		operator ^= ( const T f )			{ return Xor(f); }
//	bool		operator == ( const T f )	const	{ return f==flags; }
//	bool		operator != ( const T f )	const	{ return f!=flags; }
	// Type-cast operator:
				operator T () const					{ return flags; }
	// Test functions:
	bool		Any( const T f=F_ALL ) const		{ return (flags&f)!=0; }
	bool		None( const T f=F_ALL ) const		{ return (flags&f)==0; }
	bool		All( const T f=F_ALL ) const		{ return (flags&f)==f; }
	// Bitwise operations:
	DFlagsT&		And( const T f )					{ flags&=f; return *this; }
	DFlagsT&		Or( const T f )						{ flags|=f; return *this; }
	DFlagsT&		Xor( const T f )					{ flags^=f; return *this; }
	DFlagsT&		Invert()							{ flags=~flags; return *this; }
	DFlagsT&		Toggle( const T f )					{ flags^=f; return *this; }
	DFlagsT&		Clear( const T f )					{ flags&=~f; return *this; }
	DFlagsT&		Set( const T f )					{ flags|=f; return *this; }
	DFlagsT&		Set( const T f, bool set )			{ return set?Set(f):Clear(f); }
	// Bit-manipulation by bit-number
	bool		TestBit( const int b ) const		{ return (flags>>b)&1; }
	DFlagsT&		ToggleBit( const int b )			{ return Toggle(1<<b); }
	DFlagsT&		ClearBit( const int b )				{ return Clear(1<<b); }
	DFlagsT&		SetBit( const int b )				{ return Set(1<<b); }
	DFlagsT&		SetBit( const int b, bool v )		{ return Set(1<<b,v); }
};
///////////////////////////////////////////////////////////////////////////////
typedef unsigned long flags_t;
typedef DFlagsT<flags_t> DFlags;
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_FLAGS_H_INCLUDED
///////////////////////////////// [citkt_Flags.h] END
///////////////////////////////// [citkt_HeightMap.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_HEIGHTMAP_H_INCLUDED
#define CITK_HEIGHTMAP_H_INCLUDED
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
/////////////////////////////////////////////////////////////////////////////
// Type for height samples
typedef float height_t;
/////////////////////////////////////////////////////////////////////////////
class DHeightMap 
{
public:
	// Height samples
	Array2D<height_t>	HeightData;
	DHeightMap() : Min(0), Max(0), MPSx(1), MPSy(1) { }
	// Loading and saving to HMP
	bool		LoadHMP( cstr_t filename );
	bool		SaveHMP( cstr_t filename );
	// Change the terrain resolution in MPS (meters per sample)
	void		SetMPS( cfloat__t meters_per_sample );
	void		SetMPS( cfloat__t meters_per_sample_x, cfloat__t meters_per_sample_y );
	// Change the height samples; Min and Max will be updated accordingly
	void		MoveUp( height_t );
	void		ScaleHeight( cfloat__t );
	// Changes both height and MPS; Min and Max will be updated accordingly
	void		ScaleBy( cfloat__t ); 
	// Updates the Min and Max height values
	void		UpdateMinMax();
	// Get terrain properties
	height_t	GetMin() const { return Min; }
	height_t	GetMax() const { return Max; }
	cfloat__t	GetMPSx() const { return MPSx; }
	cfloat__t	GetMPSy() const { return MPSy; }
	// Get the actual dimensions of the terrain
	double		GetSizeX() const { return MPSx*(HeightData.GetSizeX()-1); }
	double		GetSizeY() const { return MPSy*(HeightData.GetSizeY()-1); }
	// Sets MPS from the (world) dimensions of the terrain
	void		SetSize( cfloat__t sx, cfloat__t sy ) { MPSx = sx/(HeightData.GetSizeX()-1); MPSy = sy/(HeightData.GetSizeY()-1); }
private:
	height_t	Min, Max;			// Min and Max height values
	float__t		MPSx, MPSy;			// Resolution in meters per sample
};
/////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITK_HEIGHTMAP_H_INCLUDED
///////////////////////////////// [citkt_HeightMap.h] END
///////////////////////////////// [citkt_IDBroker.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITKT_IDBROKER_H_INCLUDED
#define CITKT_IDBROKER_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
///////////////////////////////////////////////////////////////////////////////
// These are outside the class for backwards compatibility (TODO)
typedef int id__t;							
enum {
	ID_NONE = -1							// invalid ID
};
///////////////////////////////////////////////////////////////////////////////
class IDBroker
{
public:
	enum {
		ID_NONE = -1,						// invalid ID
		ID_TEMP = -2						// temporary ID (no cache)
	};
	typedef int id_t;
	IDBroker( id_t first =0 ) : NextID(first) {}
	id_t			RequestID();			// request a new ID
	void			ReleaseID( id_t );		// release an ID
	void			ReleaseAll();			// release all IDs
protected:
	Array<id_t,1>	FreeIDs;				// use malloc/free (faster)
	id_t			NextID;
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_IDBROKER_H_INCLUDED
///////////////////////////////// [citkt_IDBroker.h] END
///////////////////////////////// [citkt_Matrix34.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
#ifndef CITKT_MATRIX34_H_INCLUDED
#define CITKT_MATRIX34_H_INCLUDED
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class Matrix34 : public Matrix33
{
public:					
	Vector3		p;
	static const Matrix34 I;
	// Default Constructor:
	inline Matrix34() {}
	// Constructors:
	inline Matrix34( const Vector3 v[4] ) { Set(v); }
	inline Matrix34( const float   a[12] ) { Set(a); }
	inline Matrix34( const double  a[12] ) { Set(a); }
	// Copy-constructor (no, let compiler do it)
//	inline Matrix34( const Matrix34 &m ) : i(m.i), j(m.j), k(m.k) {}//{ Set(m); }
	
	// Operators:
//	Matrix34&	operator  = ( const Matrix34 &m ) { return Set(m); }
	Matrix34&	operator *= ( const Matrix34 & );
	Matrix34&	operator /= ( const Matrix34 & );			// * transponed
	Matrix34&	operator *= ( cfloat__t );					// scalar
	Matrix34&	operator /= ( cfloat__t );					// scalar
	// Const-operators:
	Matrix34	operator * ( const Matrix34 & ) const;
	Matrix34	operator / ( const Matrix34 & ) const;		// * transponed
	Matrix34	operator * ( cfloat__t ) const;				// scalar
	Matrix34	operator / ( cfloat__t ) const;				// scalar
	Vector3		operator * ( const Vector3 & ) const;		// transformation
	Vector3		operator / ( const Vector3 & ) const;		// back-Transformation
	inline Vector3&	operator [] ( const int p )				// array Access
		{ return (&i)[p]; }					
	inline const Vector3& operator [] ( const int p ) const	// array Access
		{ return (&i)[p]; }
	inline float__t&	operator () ( const int p, const int v )// array Access
		{ return (&i)[p][v]; }
	inline double	operator () ( const int p, const int v ) const
		{ return (&i)[p][v]; }
	inline Vector3	operator () ( const Vector3 &v ) const	// transform
		{ return v * SELF; }
	inline Matrix34 operator ! () const;					// transpone
	// Initialisation:
	Matrix34&	Set( const Matrix34& );
//	Matrix34&	Set( const Vector3 a, const Vector3 b, const Vector3 c ) { i=a; j=b; k=c; return *this; }
	Matrix34&	Set( const Vector3 v[4] ) { i.Set(v[0]); j.Set(v[1]); k.Set(v[2]); return *this; }
	Matrix34&	Set( const float a[12] ) { i.Set(a); j.Set(a+3); k.Set(a+6); return *this; }
	Matrix34&	Set( const double a[12] ) { i.Set(a); j.Set(a+3); k.Set(a+6); return *this; }
	Matrix34&	Identity() { return Set(I); }
	// Various Functions:
	Matrix34&	Transpone();
	Matrix34&	Invert();								// SLOW!
	Matrix34	Inverse() const;						// SLOWER!
	Matrix34&	RotateByX( cfloat__t d_el );
	Matrix34&	RotateByY( cfloat__t d_az );
	Matrix34&	RotateByZ( cfloat__t d_tw );
	bool		IsIdentity() const					{ return p.IsZero() && Matrix33::IsIdentity(); }
	bool		IsEqual( const Matrix34 &o ) const	{ return p.IsEqual(o.p) && Matrix33::IsEqual(o); }
	float__t*	GetData() { return &i.x; }				// 3*4=12 floats
	// Friend Functions:
	friend	Matrix34 operator * ( cfloat__t, const Matrix34 & );
#ifdef USE_IOSTREAM
	friend ostream& operator << ( ostream&, const Matrix34& );
#endif
};
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_MATRIX34_H_INCLUDED
///////////////////////////////// [citkt_Matrix34.h] END
///////////////////////////////// [citkt_MemoryPool.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITKT_MEMORYPOOL_H_INCLUDED
#define CITKT_MEMORYPOOL_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
///////////////////////////////////////////////////////////////////////////////
template <class T>
class DMemoryPool
{
public:
	enum {
		DEFAULT_MAX = 1024
	};
	// Default constructor
	DMemoryPool( size_t max_blocks =DEFAULT_MAX ) { SetMaxBlocks(max_blocks); }
	// Destructor, frees all cached items
	~DMemoryPool() { FreeAll(); }
	
	// Returns a 'new' instance
	// NOTE: Constructor might not have been called!
	T*		Alloc();
	// Returns an existing instance (if available) or NULL otherwise
	T*		Get()						{ return (T*)FreeBlocks.Pop(); }
	// 'Frees' an instance. Deletes the object if the cache limit was reached
	// NOTE: Destructor might not get called!
	void	Free( T *ptr );
	// Free all cached items
	void	FreeAll();
	// Return the number of cached memory blocks
	size_t	GetNumBlocks() const		{ return FreeBlocks.Count(); }
	// Return the amount of 'cached' memory
	size_t	GetSize() const				{ return sizeof(T)*FreeBlocks.Count(); }
	// Sets the number of maximum blocks to be cached (frees if less than current)
	void	SetMaxBlocks( size_t m );
private:
	// Hidden members, not implemented (to avoid generated copy):
	DMemoryPool( const DMemoryPool<T>& );
	void operator = ( const DMemoryPool<T>& );
	// Maxmimum number of cached memory blocks allowed in the cache
	size_t		MaxBlocks;
	// Array containing pointers to the cached items
	ArrayPtr<T>	FreeBlocks;
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
template <class T>
inline T* DMemoryPool<T>::Alloc()
{
	if (FreeBlocks.IsEmpty())
		return ::new T;
	else
		return (T*)FreeBlocks.Pop(); 
}
///////////////////////////////////////////////////////////////////////////////
template <class T>
inline void DMemoryPool<T>::Free( T* ptr )
{
	if (FreeBlocks<MaxBlocks) 
		FreeBlocks.Add(ptr); 
	else 
		::delete ptr;
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
template <class T>
void DMemoryPool<T>::FreeAll()
{
	for (int t=0;t<FreeBlocks.Count();t++)
		::delete (T*)FreeBlocks[t];
	FreeBlocks.RemoveAll();
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
template <class T>
void DMemoryPool<T>::SetMaxBlocks( size_t m )
{
//	if (m<0) m=0;
	FreeBlocks.SetDelta( MaxBlocks = m );
	while (m<FreeBlocks)
		::delete (T*)FreeBlocks.Pop();
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_MEMORYPOOL_H_INCLUDED
///////////////////////////////// [citkt_MemoryPool.h] END
///////////////////////////////// [citkt_PriorityQueue.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITKT_PRIORITYQUEUE_H_INCLUDED
#define CITKT_PRIORITYQUEUE_H_INCLUDED
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
// This class uses T::operator < to order the items in the array.
// For custom order, create a struct containg the data and implement
//  bool T::operator < ( const T& ) const;
template <class T>
class DPriorityQueue : protected ArrayVal<T>
{
public:
	void		Add( const T& );
	T&			Peek() const { THIS_ASSERT(NumItems>0,_T("::Peek on empty queue")); return Data[0]; }
	void		Pop();
	void		Heapify( const Array<T> &ar )	{ Heapify(ar,ar); }
	void		Heapify( const T*, size_t );
	void		Reheapify();
	void		Update()						{ _HeapifyDown(0); }
	// These are similar to the inherited ones from Array<>
	void		RemoveAll()						{ ArrayVal<T>::RemoveAll(); }
	void		Empty()							{ ArrayVal<T>::Empty(); }
	void		Reserve( const size_t c )		{ ArrayVal<T>::Reserve(c); }
	void		SetDelta( size_t d )			{ ArrayVal<T>::SetDelta(d); }
	bool		IsEmpty() const					{ return NumItems==0; }
	int			Count() const					{ return NumItems; }
protected:
	void		_HeapifyDown(size_t);
	void		_HeapifyUp(size_t);
};
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T>
void DPriorityQueue<T>::Add( const T& val )
{
	size_t i = ArrayVal<T>::Add(val);
	_HeapifyUp(i);
}
///////////////////////////////////////////////////////////////////////
template <class T>
void DPriorityQueue<T>::Pop()
{
	THIS_ASSERT(NumItems>0,_T("::Pop on empty queue"));
	Data[0] = Data[--NumItems];
	_HeapifyDown(0);
}
///////////////////////////////////////////////////////////////////////
template <class T>
void DPriorityQueue<T>::_HeapifyDown( size_t i )
{
	while (1)
	{
		size_t child = (i<<1)+1;
		if (child>=NumItems)
			return;
		// Find smallest child (1st comparison)
		if (child<NumItems-1)
			if (Data[child+1] < Data[child])
				child++;
		// Compare me with my smallest child (2nd comparison)
		if (Data[i] < Data[child])
			return;
		_swap(Data[i],Data[child]);
		i = child;
	}
}
///////////////////////////////////////////////////////////////////////
template <class T>
void DPriorityQueue<T>::_HeapifyUp( size_t i )
{
	while (1)
	{
		if (i==0)
			return;
		size_t parent = ((i-1)>>1);
		// Compare me with parent (comparison)
		if (Data[parent] < Data[i])
			return;
		_swap(Data[i],Data[parent]);
		i = parent;
	}
}
///////////////////////////////////////////////////////////////////////
template <class T>
void DPriorityQueue<T>::Heapify( const T* d, size_t i )
{
	CopyFrom(d,i);
	Reheapify();
}
///////////////////////////////////////////////////////////////////////
template <class T>
void DPriorityQueue<T>::Reheapify()
{
	for (int i=(NumItems>>1)-1;i>=0;i--)
		_HeapifyDown(i);
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_PRIORITYQUEUE_H_INCLUDED
///////////////////////////////// [citkt_PriorityQueue.h] END
///////////////////////////////// [citkt_Profiler.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
#ifndef CITKT_PROFILER_H_INCLUDED
#define CITKT_PROFILER_H_INCLUDED
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
/////////////////////////////////////////////////////////////////////////////
class DProfile
{
public:
	DProfile();										// resets the counter
	~DProfile();
	void		Reset();							// for reuse
	ctime_t		CheckPoint( cstr_t );				// only need this one
	uint		GetCheckPointCount() const			{ return checkpoints; }
	cstr_t		GetCheckPointString( int i ) const	{ return checkpoints[i].text; }
	ctime_t		GetCheckPointTime( int i ) const	{ return checkpoints[i].delta; }
	//! This function is handy for easy profiling; dumps all info to the console.
	void		puts( cstr_t prefix =NULL ) const;
private:
	ulong time[2];
	ulong freq[2];
	struct checkpoint_t {
		String		text;
		ctime_t		delta;
	};
	Array<checkpoint_t>	checkpoints;
};
///////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_PROFILER_H_INCLUDED
///////////////////////////////// [citkt_Profiler.h] END
///////////////////////////////// [citkt_Quaternion.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
#ifndef CITKT_QUATERNION_H_INCLUDED
#define CITKT_QUATERNION_H_INCLUDED
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#ifdef USE_IOSTREAM
# include <iostream>
#endif // USE_IOSTREAM
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
/////////////////////////////////////////////////////////////////////////////
class Matrix33;											// Forward
//class Vector3;										// Forward
/////////////////////////////////////////////////////////////////////////////
class Quaternion
{
public:
	float__t		x, y, z, w;
	static const Quaternion I;
	static const Quaternion Z;
	// Constructors:
	inline	Quaternion() {}
	inline	Quaternion( const float a[4] ) : x(a[0]), y(a[1]), z(a[2]), w(a[3]) {}
	inline	Quaternion( const double a[4] ) : x(a[0]), y(a[1]), z(a[2]), w(a[3]) {}
	inline	Quaternion( cfloat__t a, cfloat__t b, cfloat__t c, cfloat__t d ) : x(a), y(b), z(c), w(d) {}
//	inline	Quaternion( const Quaternion &v ) : x(v.x), y(v.y), z(v.z), w(v.w) {}
	inline	Quaternion( const Vector3& v ) { Set(v); }
//	inline	Quaternion( const Vector3& v, cfloat__t a=0.0f ) { Set(v,a); }
	inline	Quaternion( const Vector3& v, cfloat__t a ) { FromAxisAngle(v,a); }
	// Operators:
	inline	Quaternion&	operator  = ( const Vector3 & );
//	inline	Quaternion&	operator  = ( const Quaternion & );
	inline	Quaternion&	operator += ( const Quaternion & );
	inline	Quaternion&	operator -= ( const Quaternion & );
			Quaternion&	operator *= ( const Quaternion & );		// Rotate
			Quaternion&	operator /= ( const Quaternion & );		// Rotate, back
	inline	Quaternion&	operator *= ( cfloat__t );			// Scalar
	inline	Quaternion&	operator /= ( cfloat__t );			// Scalar
	// const-Operators:
	inline	Quaternion	operator + ( const Quaternion & ) const;
	inline	Quaternion	operator - ( const Quaternion & ) const;
			Quaternion	operator * ( const Quaternion & ) const;// Rotate
	inline	Quaternion	operator * ( const Vector3 & ) const;
	inline	Quaternion	operator * ( cfloat__t ) const;		// Scalar (!)
			Quaternion	operator / ( const Quaternion & ) const;// Rotate, back
	inline	Quaternion	operator / ( cfloat__t ) const;		// Scalar
	inline	Quaternion	operator + () const;
	inline	Quaternion	operator - () const;					// Flip
	inline	Quaternion	operator ! () const;					// Conjugate
	inline	double		operator ^ ( const Quaternion& ) const;	// Dot
	inline	float__t&	operator [] ( const int );				// Array access [0..3]
	inline	double		operator [] ( const int ) const;		// Array access [0..3]
//	inline Quaternion&	operator *= ( const Matrix33 & );		// Transformation
//	inline Quaternion&	operator /= ( const Matrix33 & );		// Back-Transformation
//	inline Quaternion	operator * ( const Matrix33 & ) const;	// Transformation
//	inline Quaternion	operator / ( const Matrix33 & ) const;	// Back-Transformation
	// Initialisation:
	inline	Quaternion&	Set( cfloat__t, cfloat__t, cfloat__t, cfloat__t );
	inline	Quaternion&	Set( const float [4] );
	inline	Quaternion&	Set( const double [4] );
	inline	Quaternion&	Set( const Vector3&, cfloat__t =0.0f );
	inline	Quaternion&	Set( const Quaternion& );
	Quaternion&			Zero() { Set(Z); return *this; }
	Quaternion&			Identity() { Set(I); return *this; }
	Quaternion&			Random();
	Quaternion			Intermediate( const Quaternion &before, const Quaternion &after ) const;
	Vector3				Log() const;
	Quaternion&			Exp( const Vector3& );
	Quaternion&			FromMatrix( const Matrix33& );
//	Quaternion&			FromEuler( const Vector3& );
	Quaternion&			FromSpherical( cfloat__t, cfloat__t, cfloat__t );
	Quaternion&			FromEuler( cfloat__t, cfloat__t, cfloat__t );
	Quaternion&			FromAxisAngle( const Vector3&, cfloat__t );
	Quaternion&			RotationX( cfloat__t );
	Quaternion&			RotationY( cfloat__t );
	Quaternion&			RotationZ( cfloat__t );
	// Functions:
	Quaternion			Copy() const { return Quaternion(*this); }
	Quaternion&			Flip();						// (v=-v)
	Quaternion&			Conjugate();
	Quaternion&			Invert();
	Quaternion&			Normalize();
	double				SqrLength() const { return x*x+y*y+z*z+w*w; }
	double				Length() const { return _fsqrt(SqrLength()); }
	inline bool			IsEqual( const Quaternion& ) const;
//	inline Quaternion	Conjugated() const;
//	inline Quaternion	Inverse() const;
//	Vector3				ToEuler() const;
	void				ToEuler( float__t&, float__t&, float__t& ) const;
	void				ToSpherical( float__t&, float__t&, float__t& ) const;
	void				ToMatrix( Matrix33& ) const;
//	Quaternion&			ToMatrixRef( Matrix33& ) const;
	void				ToAxisAngle( Vector3&, float__t& ) const;
	Quaternion&			RotateByX( cfloat__t );
	Quaternion&			RotateByY( cfloat__t );
	Quaternion&			RotateByZ( cfloat__t );
	Quaternion			Slerp( const Quaternion&, cfloat__t ) const;
	// Friend Functions:
	friend	Quaternion operator * ( cfloat__t, const Quaternion & );
#ifdef USE_IOSTREAM
	friend ostream & operator << ( ostream &, const Quaternion & );
#endif // USE_IOSTREAM
};
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Macros for null-vector:
#define ZEROQUAT		Quaternion::Z
#define ZeroQuat		ZEROQUAT
#define UNITQUAT		Quaternion::I
#define UnitQuat		UNITQUAT
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
inline Quaternion& Quaternion::Set( cfloat__t a, cfloat__t b, cfloat__t c, cfloat__t d )
{
	x = a;
	y = b;
	z = c;
	w = d;
	return *this;
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
inline Quaternion& Quaternion::Set( const double a[4] )
{
	x = a[0];
	y = a[1];
	z = a[2];
	w = a[3];
	return *this;
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
inline Quaternion& Quaternion::Set( const float a[4] )
{
	x = a[0];
	y = a[1];
	z = a[2];
	w = a[3];
	return *this;
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
inline Quaternion& Quaternion::Set( const Vector3 &v, cfloat__t a )
{
	x = v.x;
	y = v.y;
	z = v.z;
	w = a;
	return *this;
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
inline Quaternion& Quaternion::Set( const Quaternion& q )
{
//	memcpy( (void*)&x, (void*)&v.x, sizeof(float__t)*4 );		// faster?
	x = q.x;
	y = q.y;
	z = q.z;
	w = q.w;
	return *this;
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
inline Quaternion& Quaternion::operator = ( const Vector3 &v )
{
	x = v.x;
	y = v.y;
	z = v.z;
	w = 0.0f;
	return *this;
}
/////////////////////////////////////////////////////////////////////////////
inline Quaternion& Quaternion::operator += ( const Quaternion &v )
{
	x += v.x;
	y += v.y;
	z += v.z;
	w += v.w;
	return (*this);
}
/////////////////////////////////////////////////////////////////////////////
inline Quaternion& Quaternion::operator -= ( const Quaternion &v )
{
	x -= v.x;
	y -= v.y;
	z -= v.z;
	w -= v.w;
	return (*this);
}
/////////////////////////////////////////////////////////////////////////////
inline Quaternion& Quaternion::operator *= ( cfloat__t d )
{
	x *= d;
	y *= d;
	z *= d;
	w *= d;
	return (*this);
}
/////////////////////////////////////////////////////////////////////////////
inline Quaternion& Quaternion::operator /= ( cfloat__t d )
{
	const float__t id = 1.0f / d;
	x *= id;
	y *= id;
	z *= id;
	w *= id;
	return (*this);
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
inline Quaternion Quaternion::operator + () const
{
	return (*this);
}
/////////////////////////////////////////////////////////////////////////////
inline Quaternion Quaternion::operator - () const
{
	return Quaternion( -x, -y, -z, -w );
}
/////////////////////////////////////////////////////////////////////////////
inline Quaternion Quaternion::operator ! () const
{
	return Quaternion( -x, -y, -z, w );
}
/////////////////////////////////////////////////////////////////////////////
inline float__t& Quaternion::operator [] ( const int i )
{
//	return (i==0?x:(i==1?y:z));						// for class, safe
//	return vec[i];
	return (&x)[i];
}
/////////////////////////////////////////////////////////////////////////////
inline double Quaternion::operator [] ( const int i ) const
{
	return (&x)[i];
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
inline Quaternion Quaternion::operator + ( const Quaternion &v ) const
{
	return Quaternion( x+v.x, y+v.y, z+v.z, w+v.w );
}
/////////////////////////////////////////////////////////////////////////////
inline Quaternion Quaternion::operator - ( const Quaternion &v ) const
{
	return Quaternion( x-v.x, y-v.y, z-v.z, w-v.w );
}
/////////////////////////////////////////////////////////////////////////////
inline Quaternion Quaternion::operator * ( cfloat__t d ) const
{
	return Quaternion( x*d, y*d, z*d, w*d );
}
/////////////////////////////////////////////////////////////////////////////
inline Quaternion Quaternion::operator / ( cfloat__t d ) const
{
	const float__t id = 1.0f/d;
	return Quaternion( x*id, y*id, z*id, w*id );
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
inline Quaternion& Quaternion::Flip()
{ 
	x=-x; 
	y=-y; 
	z=-z; 
	w=-w;
	return (*this); 
}
/////////////////////////////////////////////////////////////////////////////
inline Quaternion& Quaternion::Conjugate()
{ 
	x=-x; 
	y=-y; 
	z=-z; 
	return (*this); 
}
/////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
inline double Quaternion::operator ^ ( const Quaternion &q ) const
{
	return x * q.x + y * q.y + z * q.z + w * q.w;
}
///////////////////////////////////////////////////////////////////////////////
inline bool Quaternion::IsEqual( const Quaternion& q ) const 
{ 
	return _feq(x,q.x) && _feq(y,q.y) && _feq(z,q.z) && _feq(w,q.w); 
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
inline Quaternion& Quaternion::RotationX( cfloat__t a )
{
	float__t sa, ca;
	__fsincos( a * 0.5f, &sa, &ca );
 	return Set( sa, 0.f, 0.f, ca );
}
///////////////////////////////////////////////////////////////////////////////
inline Quaternion& Quaternion::RotationY( cfloat__t a )
{
	float__t sa, ca;
	__fsincos( a * 0.5f, &sa, &ca );
 	return Set( 0.f, sa, 0.f, ca );
}					   
///////////////////////////////////////////////////////////////////////////////
inline Quaternion& Quaternion::RotationZ( cfloat__t a )
{
	float__t sa, ca;
	__fsincos( a * 0.5f, &sa, &ca );
 	return Set( 0.f, 0.f, sa, ca );
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
inline Quaternion Quaternion::operator * ( const Vector3 &v ) const
{
	return (SELF*Quaternion(v))*(!SELF);
}
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//	Friends:
/////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
inline Vector3& Vector3::operator *= ( const Quaternion &q )
{
	Quaternion v = (!q)*(Quaternion(SELF)*q);
	return Set(v.x,v.y,v.z);
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
inline Vector3& Vector3::operator /= ( const Quaternion &q )
{
	Quaternion v = q/(Quaternion(SELF)*(!q));
	return Set(v.x,v.y,v.z);
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
inline Vector3 Vector3::operator * ( const Quaternion &q ) const
{
	Quaternion v = (!q)*(Quaternion(SELF)*q);
	return Vector3(v.x,v.y,v.z);
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
inline Vector3 Vector3::operator / ( const Quaternion &q ) const
{
	Quaternion v = q/(Quaternion(SELF)*(!q));
	return Vector3(v.x,v.y,v.z);
}
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
inline Quaternion operator * ( cfloat__t d, const Quaternion &v )
{
	return Quaternion( d * v.x, d * v.y, d * v.z, d * v.w );
}
/////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
inline Quaternion RotationQuatX( cfloat__t a )
{
	float__t sa, ca;
	__fsincos( a * 0.5f, &sa, &ca );
 	return Quaternion( sa, 0.f, 0.f, ca );
}
///////////////////////////////////////////////////////////////////////////////
inline Quaternion RotationQuatY( cfloat__t a )
{
	float__t sa, ca;
	__fsincos( a * 0.5f, &sa, &ca );
 	return Quaternion( 0.f, sa, 0.f, ca );
}					   
///////////////////////////////////////////////////////////////////////////////
inline Quaternion RotationQuatZ( cfloat__t a )
{
	float__t sa, ca;
	__fsincos( a * 0.5f, &sa, &ca );
 	return Quaternion( 0.f, 0.f, sa, ca );
}
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_QUATERNION_H_INCLUDED
///////////////////////////////// [citkt_Quaternion.h] END
///////////////////////////////// [citkt_Random.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
#ifndef CITKT_RANDOM_H_INCLUDED
#define CITKT_RANDOM_H_INCLUDED
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
/////////////////////////////////////////////////////////////////////////////
class DRandom
{
public:
	// Constructors:
	DRandom();										// seeds with current time
	DRandom( uint32 seed )						{ srand(seed); }
	//! Reinitialization with given seed
	void	srand( uint32 seed );
	//! Main random number generator, from UINT_MIN to UINT_MAX (fastest)
	uint	randu();
	// Random methods:
	int		rand();									// from 0 to RAND_MAX.
	int		rand( int upperBound );					// from 0 to upperBound-1.
	int		rand( int lowerBound, int upperBound );	// from lowerBound to upperBound-1.
	void	rand( byte* buffer, int count );		// random byte array.
	float	randf();								// random float in [0.0f, 1.0f).
	double	randd();								// random double in [0.0, 1.0).
	bool	randb();								// random boolean (fast)
private:
	inline uint _NextUInt();
	// Last 4 generated numbers:
	uint32 m_X, m_Y, m_Z, m_W;
	
	// index for NextBool():
	int m_BitBufferIdx;
};
/////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_RANDOM_H_INCLUDED
///////////////////////////////// [citkt_Random.h] END
///////////////////////////////// [citkt_RLEArray.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
#ifndef	CITKT_RLEARRAY_H_INCLUDED
#define	CITKT_RLEARRAY_H_INCLUDED
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T>
class RLEArray
{
	typedef unsigned char len_t;
public:
	// Default constructor
	RLEArray() {}
	// Copy constructor
	RLEArray( const RLEArray<T> &ar ) : data(ar.data) {}
	// Constructors
	RLEArray( const Array<T,0> &ar )		{ _AddFrom(ar,ar.Count()); }
	RLEArray( const Array<T,1> &ar )		{ _AddFrom(ar,ar.Count()); }
	RLEArray( const T* d, size_t c )		{ _AddFrom(d,c); }
	T&		_Add( len_t count =1 );
	void	Add( const T& );
	bool	RemoveNo( size_t at );
	T		Pop();
	void	Push( const T &v )		{ Add(v); }
	T&		Peek() const			{ return data.Peek().value; }	// CAREFULL
	size_t	PeekCount() const		{ return data.Peek().length; }	// CAREFULL
	size_t	Count() const;
	T		GetNo( size_t at ) const;
	void	SetNo( size_t at, const T& );
	void	SetAt( size_t at, const T*, size_t );
	void	CopyTo( T* ) const;				// needs room for Count() items
	void	AddFrom( const T*, size_t len );
	void	CopyFrom( const T* d, size_t l )	{ Empty(); _AddFrom(d,l); }
	bool	ContainsNo( size_t a ) const		{ return a<Count(); }
	size_t	FindAndReplace( const T& f, const T& r );
	// From Array<>:
	const void*	GetData() const			{ return data.GetData(); }	// const
	bool	IsEmpty() const				{ return data.IsEmpty(); }
	size_t	GetDataSize() const			{ return data.GetDataSize(); }
	size_t	GetMem() const				{ return data.GetMem(); }
	void	RemoveAll()					{ data.RemoveAll(); }
	void	Empty()						{ data.Empty(); }
protected:
	enum {
		MAXLEN = 255					// maximum value for a len_t
	};
	struct rle_t
	{
		T				value;
		unsigned char	length;
	};
	Array<rle_t,1> data;
	void	_AddFrom( const T*, size_t count );
	T&		_Insert( int at );
};
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template<class T>
inline T& RLEArray<T>::_Add( len_t count )
{
	rle_t &p = data.Add();
	p.length = count;
	return p.value;
}
///////////////////////////////////////////////////////////////////////
template<class T>
T& RLEArray<T>::_Insert( int at )
{
	// TODO: optimize by reusing dummy entries
	rle_t &p = data.Insert(at);
	p.length = 1;
	return p.value;
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template<class T>
void RLEArray<T>::Add( const T& val )
{
	// If the new value is the same as the last, append
	if (data.Count() && val==Peek())
	{
		len_t& len = data.Peek().length;
		if (len<MAXLEN)
		{
			// Simply increment and we're done
			++len;
			return;
		}
		// Last piece is max-ed out, append
	}
	_Add() = val;
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template<class T>
size_t RLEArray<T>::Count() const
{
	size_t count = 0;
	for (int t=0; t<data.Count(); t++)
		count += data[t].length;
	return count;
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template<class T>
void RLEArray<T>::SetAt( size_t at, const T* dat, size_t count )
{
	// SLOW
	for (size_t t=0; t<count; t++)
		SetNo(at+t,dat[t]);
}
///////////////////////////////////////////////////////////////////////
template<class T>
void RLEArray<T>::SetNo( size_t at, const T& val )
{
	THIS_ASSERT( _smaller(at,0x1000000), _T("RLEArray::SetNo() : index out of range") );
	for (int t=0; t<data.Count(); t++)
	{
		const len_t len = data[t].length;
		if (at < len)
		{
			// This RLE block contains the requested item
			if (len==1)
				data[t].value = val;
			else
			if (data[t].value != val)
			{
/*				if (at==0 && t)
				{
					// Try to use the previous item
					if (data[t-1].length==0)
					{
						data[t-1].value = val;
						data[t-1].length = 1;
						return;
					}
					if (data[t-1].value==val)
					{
						++data[t-1].length;
						return;
					}
				}
				else
				if (at==len-1 && t<data.Count()-1)
				{
					// Try to use the next item
					if (data[t+1].length==0)
					{
						data[t+1].value = val;
						data[t+1].length = 1;
						return;
					}
					if (data[t+1].value==val)
					{
						++data[t+1].length;
						return;
					}
				}*/
				if (at==0)
				{
					// Insert the new item before the current one
					--data[t].length;
					_Insert(t) = val;
				}
				else
				if (at+1==len)
				{
					// Insert the new item after the current one
					--data[t].length;
					_Insert(t+1) = val;
				}
				else
				{
					// Insert before and after
					data[t].length = at;
					// TODO: could be faster
					_Insert(t+1) = val;
					_Insert(t+2) = data[t].value;
					data[t+2].length = len-at-1;
				}
			}
			return;
		}
		at -= len;
	}
	// Insert dummy items until we reach the position
	while (at)
	{
		len_t len = (at>MAXLEN?MAXLEN:at);
		_Add(len);								// adds anything
		at -= len;
	}
	// Append
	Add(val);
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template<class T>
void RLEArray<T>::AddFrom( const T* dat, size_t len )
{
	if (!len || !dat)
		return;
	// SLOW but trivial implementation
//	for (int t=0; t<len; t++)
//		Add( data[t] );
	if (data.Count())
	{
		// If the first of the new data is the same as the last, increment
		len_t &lastlen = data.Peek().length;
		const T& lastval = data.Peek().value;
		while (lastlen<255 && *dat==lastval)
		{
			++lastlen;
			++dat;
			--len;
		}
	}
	_AddFrom(dat,len);
}
///////////////////////////////////////////////////////////////////////
template<class T>
void RLEArray<T>::_AddFrom( const T* dat, size_t len )
{
	for (size_t t=0; t<len;)
	{
		// Fetch next value to be added
		const T& value = dat[t++];
		// Find out if there are more equal ones
		len_t ln;
		for (ln=1; t<len && ln<MAXLEN; ln++, t++)
			if (dat[t]!=value)
				break;
		// Add the whole lot of 'm
		_Add(ln) = value;
	}
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template<class T>
T RLEArray<T>::GetNo( size_t i ) const
{
	for (int t=0; t<data.Count(); t++)
	{
		len_t &len = data[t].length;
		if (i < len)
			return data[t].value;
		i -= len;
	}
	// Invalid; return default value
	return T();
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template<class T>
bool RLEArray<T>::RemoveNo( size_t i )
{
	for (int t=0; t<data.Count(); t++)
	{
		len_t &len = data[t].length;
		if (i < len)
		{
			if (--len==0)
				while (data.Count() && PeekCount()==0)
				{
					// Pop the last two items (len + data) from the array
					data.Pop();
				}
			return true;
		}
		i -= len;
	}
	// Invalid; return false
	return false;
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template<class T>
void RLEArray<T>::CopyTo( T *dest ) const
{
	for (int t=0; t<data.Count(); t++)
	{
		const len_t l = data[t].length;
		const T v = data[t].value;
		for (int d=0; d<l; d++)
			*dest++ = v;
	}
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template<class T>
T RLEArray<T>::Pop()
{
	while (data.Count())
	{
		len_t &len = data.Peek().length;
		if (len)
		{
			const T &value = data.Peek().value;
			if (--len==0)
				do
				{
					// Pop the last two items (len + data) from the array
					data.Pop();
				}
				while (data.Count() && PeekCount()==0);
			return value;
		}
		// Pop last two items (len + data) from array
		data.Pop();
	}
	// Invalid; return default value
	return T();
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template<class T>
size_t RLEArray<T>::FindAndReplace( const T& f, const T& r )
{
	size_t replaced = 0;
	for (int t=0; t<data.Count(); t++)
		if (data[t].value==f)
			if (data[t].length)
			{
				// Replace the value and add the count
				data[t].value = r;
				replaced += data[t].length;
			}
	return replaced;
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_RLEARRAY_H_INCLUDED
///////////////////////////////// [citkt_RLEArray.h] END
///////////////////////////////// [citkt_Set.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITKT_SET_H_INCLUDED
#define CITKT_SET_H_INCLUDED
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
///////////////////////////////////////////////////////////////////////////////
template <class EType>
struct DSet
{
	flags_t		flags;
	// Constructor:
	DSet() : flags(0) {}
	explicit DSet( const EType b ) : flags(1<<(int)b) {}
	// Copy constructor:
	DSet( const DSet& f ) : flags(f.flags) {}
	// Assignment operator:
	DSet&		operator = ( const DSet& f )		{ flags=f.flags; return *this; }
	// operators:
	bool		operator [] ( const EType b ) const	{ return Test(b); }
	DSet&		operator &= ( const DSet &f )		{ return Intersect(f); }
	DSet&		operator |= ( const DSet &f )		{ return Add(f); }
	DSet&		operator ^= ( const DSet &f )		{ return Toggle(f); }
	// Test functions:
	bool		Any() const							{ return flags!=0; }
	bool		None() const						{ return flags==0; }
	DSet&		Intersect( const DSet &f )			{ flags&=f.flags; return *this; }
	DSet&		Add( const DSet &f )				{ flags|=f.flags; return *this; }
	DSet&		Remove( const DSet &f )				{ flags&=~f.flags; return *this; }
	DSet&		Toggle( const DSet &f )				{ flags^=f.flags; return *this; }
	// Bit-testing by bit-number
	bool		Test( const EType b ) const			{ return (flags>>(int)b)&1; }
	DSet&		Add( const EType b )				{ return Add(DSet(b)); }
	DSet&		Remove( const EType b )				{ return Remove(DSet(b)); }
	DSet&		Toggle( const EType b )				{ return Toggle(DSet(b)); }
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_SET_H_INCLUDED
///////////////////////////////// [citkt_Set.h] END
///////////////////////////////// [citkt_SmartBool.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITKT_SMARTBOOL_H_INCLUDED
#define CITKT_SMARTBOOL_H_INCLUDED
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
///////////////////////////////////////////////////////////////////////////////
class DSmartBool
{
public:
	DSmartBool(): old(false), val(false) {}
	explicit DSmartBool(bool x): old(x), val(x) {}
	bool operator = (bool newval) { old = val; return val = newval; }
	operator bool () const { return val; }
	bool	Toggled() const { return val != old; }
	bool	ToggledOn() const { return val && !old; }
	bool	ToggledOff() const { return !val && old; }
	bool	Toggle() { old=val; val = !val; return val; }
private:
	bool val;
	bool old;
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_SMARTBOOL_H_INCLUDED
///////////////////////////////// [citkt_SmartBool.h] END
///////////////////////////////// [citkt_SmartPtr.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITKT_SMARTPTR_H_INCLUDED
#define CITKT_SMARTPTR_H_INCLUDED
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
/////////////////////////////////////////////////////////////////////////////
template <class _T>
class DSmartPtr
{
public:
	DSmartPtr() : ptr(NULL) {}
	DSmartPtr( _T* p ) : ptr(p) {}
	// Methods:
	inline _T*		New() { return PointTo( new _T ); }
	inline void		Delete() { delete ptr; ptr=NULL; }
	inline void		Free() { free(ptr); ptr=NULL; }
	inline _T*		Target() const { return ptr; }
	inline _T*		PointTo( _T* p ) { ptr=p; return p; }
	// Assignment operators:
	inline DSmartPtr& operator = ( _T* p ) { PointTo(p); return *this; }
	// Type-cast operators:
	inline operator _T* () const { return ptr; }
	// Dereference operators:
	inline _T* operator -> () const { THIS_ASSERT(ptr!=NULL," NULL"); return ptr; }
	inline _T& operator * () const { THIS_ASSERT(ptr!=NULL," NULL"); return *ptr; }
	// Compare
	inline bool operator == ( _T* const rhs ) const { return ptr == rhs; }
	inline bool operator != ( _T* const rhs ) const { return ptr != rhs; }
	inline bool operator ! () const { return !ptr; }
protected:
	_T*	ptr;
};
/////////////////////////////////////////////////////////////////////////////
template <class _T>
class DDeletePtr : public DSmartPtr<_T>
{
	DDeletePtr& operator = ( _T* );						// = forbidden
	DDeletePtr& operator = ( const DDeletePtr<_T>& );	// = forbidden
	DDeletePtr( const DDeletePtr<_T>& );				// = forbidden
public:
	~DDeletePtr() { delete ptr; }
};
/////////////////////////////////////////////////////////////////////////////
template <class _T>
class DFreePtr : public DSmartPtr<_T>
{
	DFreePtr& operator = ( _T* );					// = forbidden
	DFreePtr& operator = ( const DFreePtr<_T>& );	// = forbidden
	DFreePtr( const DFreePtr<_T>& );				// = forbidden
public:
	~DFreePtr() { free(ptr); }
};
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_SMARTPTR_H_INCLUDED
///////////////////////////////// [citkt_SmartPtr.h] END
///////////////////////////////// [citkt_SortedArray.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#ifndef CITKT_SORTEDARRAY_H_INCLUDED
#define CITKT_SORTEDARRAY_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
///////////////////////////////////////////////////////////////////////////////
typedef unsigned long hash_t;
///////////////////////////////////////////////////////////////////////////////
template <class CType>
class DSortedArray
{
public:
	void			Add( hash_t hash, CType* obj );								// Won't sort
	void			AddUnsorted( hash_t hash, CType* obj );						// Won't sort
	CType*			Find( hash_t hash ) const { return GetNo(hash); }
	bool			Contains( hash_t ) const;
	CType*			Peek() const { return _Array.Peek().ptr; }
	hash_t			PeekHash() const { return _Array.Peek().value; }
	CType*			Pop() { return _Array.Pop().ptr; }
	CType*			Remove( hash_t );
	bool			Delete( hash_t );
	void			RemoveAll() { _Array.RemoveAll(); }
	void			DeleteAll() { _Array.DeleteAll(); }
	void			SetNo( hash_t hash, CType* obj );
	CType*			GetNo( hash_t hash ) const;
	bool			IsEmpty() const { return _Array.IsEmpty(); }
	int				Count() const { return _Array.Count(); }
//	void			Sort();														// After Add()
	// Iteration
	CType*			First( hash_t &iterator ) const { iterator=0; return Next(iterator); }
	CType*			Next( hash_t &iterator ) const { return _Array.ContainsNo(iterator)?_Array[iterator++].ptr:NULL; }
	CType*			operator [] ( const int i ) { return _Array[i].ptr; }		// Won't check
	CType*			operator [] ( const int i ) const { return _Array[i].ptr; }	// Won't check
	hash_t			GetHash( const int i ) const { return _Array[i].value; }		// Won't check
	void			SetHash( const int i, hash_t hash ) const { _Array[i].value = hash; }	// Won't sort
private:
	struct hashentry_t
	{
		hash_t		value;
		CType*		ptr;
	};
	Array<hashentry_t>	_Array;
	// Method to find the right index; i<0 means 'insert at (-1-i)'
	int				_Find( const hash_t &what, int begin, int end ) const;
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
template <class CType>
int DSortedArray<CType>::_Find( const hash_t &what, int begin, int end ) const
{
	while (begin<=end)
	{
		int t = (begin+end)>>1;
		if (_Array[t].value < what)
			begin = t+1;
		else if (what < _Array[t].value)
			end = t-1;
		else
			return t;						// Found at [t]; return t
	}
	return -begin-1;						// Not found; return 'insert position'
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
template <class CType>
void DSortedArray<CType>::AddUnsorted( hash_t hv, CType* obj )
{
	hashentry_t& he = _Array.Add();
	he.value = hv;
	he.ptr = obj;
	// Array is now not sorted!
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
template <class CType>
void DSortedArray<CType>::Add( hash_t value, CType* obj )
{
	int b = _Find(value,0,Count()-1);
	// Not found: insert at '-1-b'
	if (b<0)
		b = -1-b;
	hashentry_t &he = _Array.Insert(b);
	he.value = value;
	he.ptr = obj;
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
template <class CType>
CType* DSortedArray<CType>::GetNo( hash_t hv ) const
{
	int b = _Find(hv,0,Count()-1);
	if (b>=0)
		return _Array[b].ptr;
	return NULL;
}
///////////////////////////////////////////////////////////////////////////////
template <class CType>
void DSortedArray<CType>::SetNo( hash_t value, CType* obj )
{
	int b = _Find(value,0,Count()-1);
	if (b>=0)
	{
		// Found at index 'b'
		_Array[b].ptr = obj;
	}
	else
	{
		// Not found; insert at '-1-b'
		hashentry_t &he = _Array.Insert(-1-b);
		he.value = value;
		he.ptr = obj;
	}
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
template <class CType>
CType* DSortedArray<CType>::Remove( hash_t hv )
{
	int b = _Find(hv,0,Count()-1);
	if (b>=0)
	{
		// Found at index 'b'; remove but keep the order
		CType *d = _Array[b].ptr;
		_Array.RemoveOrdered(b);
		return d;
	}
	return NULL;
}
///////////////////////////////////////////////////////////////////////////////
template <class CType>
bool DSortedArray<CType>::Delete( hash_t hv )
{
	CType* c = Remove(hv);
	if (c)
		delete c;
	return c!=NULL;
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
template <class CType>
bool DSortedArray<CType>::Contains( hash_t hv ) const
{
	return _Find(hv,0,Count()-1) >= 0;
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_SORTEDARRAY_H_INCLUDED
///////////////////////////////// [citkt_SortedArray.h] END
//#include "citkt_SparseArray.h"
///////////////////////////////// [citkt_SparseArray2D.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
#ifndef	CITKT_SPARSEARRAY2D_H_INCLUDED
#define	CITKT_SPARSEARRAY2D_H_INCLUDED
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T, class RowT =RLEArray<T> >
class SparseArray2D
{
public:
	// Default constructor
	SparseArray2D() {}
	// Copy constructor
//	SparseArray2D( const SparseArray2D<T,RowT> &ar );
	void	SetNo( size_t x, size_t y, const T& );
	T		GetNo( size_t x, size_t y ) const;
	size_t	GetSizeX() const;							// SLOW
	size_t	GetSizeY() const							{ return rows.Count(); }
	size_t	GetMem() const;
	bool	ContainsNo( size_t x, size_t y ) const;		// SLOW
	void	RemoveAll()									{ rows.DeleteAll(); }
	size_t	FindAndReplace( const T& f, const T& r );
	// Row manipulation
	
	size_t	GetRowSize( size_t y ) const { RowT *r = rows.GetNo(y); return r?r->Count():0; }
	void*	GetRowData( size_t y ) const { RowT *r = rows.GetNo(y); return r?r->GetData():NULL; }
	size_t	GetRowDataSize( size_t y ) const { RowT *r = rows.GetNo(y); return r?r->GetDataSize():0; }
	void	SetRowAt( size_t x, size_t y, const T*, size_t rowl );
	void	CopyRowFrom( size_t y, const T*, size_t rowl );
	void	CopyRowTo( size_t y, T* );
	void	SetRowsAt( size_t x, size_t y, const T**, size_t rowl, size_t rowc );
	void	CopyRowsFrom( size_t y, const T**, size_t rowl, size_t rowc );
	void	CopyRowsTo( size_t y, T**, size_t rowc );
	void	RemoveRow( size_t y )		{ rows.DeleteNo(y); }
protected:
	ArrayPtr<RowT>	rows;
};
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T, class RowT>
bool SparseArray2D<T,RowT>::ContainsNo( size_t x, size_t y ) const
{
	RowT *row = rows.GetNo(y);
	if (row)
		return row->ContainsNo(x);
	else
		return false;
}
///////////////////////////////////////////////////////////////////////
template <class T, class RowT>
inline T SparseArray2D<T,RowT>::GetNo( size_t x, size_t y ) const
{
	RowT *row = rows.GetNo(y);
	if (row)
		return row->GetNo(x);
	else
		return T();				// returns anything
}
///////////////////////////////////////////////////////////////////////
template <class T, class RowT>
inline void SparseArray2D<T,RowT>::SetNo( size_t x, size_t y, const T &val )
{
	RowT *row = rows.GetNo(y);
	if (!row)
		row = rows.SetNew(y);
	row->SetNo(x,val);
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T, class RowT>
size_t SparseArray2D<T,RowT>::GetMem() const
{
	size_t s = rows.GetMem();
	for (int t=0; t<rows.Count(); t++)
		if (rows[t])
			s += rows[t]->GetMem() + sizeof(RowT);
	return s;
}
///////////////////////////////////////////////////////////////////////
template <class T, class RowT>
size_t SparseArray2D<T,RowT>::GetSizeX() const
{
	size_t s = 0;
	for (int t=0; t<rows.Count(); t++)
		if (rows[t])
			_set_max( s, rows[t]->Count() );
	return s;
}
///////////////////////////////////////////////////////////////////////
template <class T, class RowT>
inline void SparseArray2D<T,RowT>::SetRowAt( size_t x, size_t y, const T *d, size_t c )
{
	RowT *row = rows.GetNo(y);
	if (!row)
		row = rows.SetNo(y,new RowT);
	row->SetAt( x, d, c );
}
///////////////////////////////////////////////////////////////////////
template <class T, class RowT>
void SparseArray2D<T,RowT>::CopyRowFrom( size_t y, const T *d, size_t c )
{
	if (!d || !c)
	{
		RemoveRow(y);
		return;
	}
	RowT *row = rows.GetNo(y);
	if (!row)
		row = rows.SetNew(y);
	row->CopyFrom(d,c);
}
///////////////////////////////////////////////////////////////////////
template <class T, class RowT>
inline void SparseArray2D<T,RowT>::CopyRowTo( size_t y, T *d )
{
	RowT *r = rows.GetNo(y);
	if (r)
		r->CopyTo(d);
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T, class RowT>
inline void SparseArray2D<T,RowT>::SetRowsAt( size_t x, size_t y, const T **d, size_t c, size_t rc )
{
	for (int t=0; t<rc; t++)
		if (d[t])
			SetAtRow( x,y+t, d[t], c );
}
///////////////////////////////////////////////////////////////////////
template <class T, class RowT>
inline void SparseArray2D<T,RowT>::CopyRowsFrom( size_t y, const T **d, size_t c, size_t rc )
{
	for (int t=0; t<rc; t++)
		CopyRowFrom( y+t, d[t], c );
}
///////////////////////////////////////////////////////////////////////
template <class T, class RowT>
inline void SparseArray2D<T,RowT>::CopyRowsTo( size_t y, T **d, size_t rc )
{
	for (int t=0; t<rc; t++)
		if (d[t])
			CopyRowTo( y+t, d[t] );
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
template <class T, class RowT>
inline size_t SparseArray2D<T,RowT>::FindAndReplace( const T& f, const T& r )
{
	size_t replaced = 0;
	for (int t=0; t<rows.Count(); t++)
		if (rows[t])
			replaced += rows[t]->FindAndReplace(f,r);
	return replaced;
}
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_SPARSEARRAY2D_H_INCLUDED
///////////////////////////////// [citkt_SparseArray2D.h] END
//#include "citkt_StringHash.h"
//#include "citkt_StringMap.h"
///////////////////////////////// [citkt_TempBuf.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITKT_TEMPBUF_INCLUDED
#define CITKT_TEMPBUF_INCLUDED
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
/////////////////////////////////////////////////////////////////////////////
template <class T>
class DTempBuf
{
public:
	
	//! Default constructor	(takes ownership of the pointer)
	DTempBuf( T* bp =NULL ) : buff(bp)			{ }
	//! Copy-constructor (actually steals the data from the other buffer)
	DTempBuf( DTempBuf &tb ) : buff(tb.buff)	{ tb.buff=NULL; }
	//! Constructor that allocates specified amount of memory
	explicit DTempBuf( size_t s )				{ _alloc(s); }
	//! Destructor; frees allocated memory
	~DTempBuf()									{ _free(); }
	//! Cast operator (simply returns the pointer to the current buffer)
	operator T* () const						{ return buff; }
	//! Assignment operator (actually steals the data from the other buffer)
	T*		operator = ( DTempBuf& tb )			{ return Attach(tb); }
	//! Returns 'true' if there's currently no memory allocated
	bool	operator ! () const					{ return !buff; }
	// Support methods
	T*		Alloc( size_t s )		{ _free(); return _alloc(s); }
	void	Free()					{ _free(); buff=NULL; }
	T*		Detach()				{ T* b=buff; buff=NULL; return b; }
	T*		Attach( T* b )			{ _free(); return buff = b; }
	T*		Swap( T* b )			{ T* bb=buff; buff=b; return bb; }
	T*		Attach( DTempBuf &tb )	{ return Attach( tb.Detach() ); }
	T*		Swap( DTempBuf &tb )	{ return buff = tb.Swap(buff); }
private:
	T*		buff;
	// Memory management functions
	T*		_alloc( size_t s )		{ return buff = (T*)malloc(s); }
	void	_free()					{ free((void*)buff); }
};
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_TEMPBUF_INCLUDED
///////////////////////////////// [citkt_TempBuf.h] END
///////////////////////////////// [citkt_TempFile.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This path is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITK_TEMPFILE_H_INCLUDED
#define CITK_TEMPFILE_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citkt_DOS.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef	CITKT_DOS_H_INCLUDED
#define	CITKT_DOS_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
class DOS
{
public:
	static const char_t Slash;			// platform dependent
	// Simple file searching:
	static int		GetFileList( cstr_t wildcard, Array<String>& filelist );
	static int		GetFileListEx( cstr_t wildcard, cstr_t paths, Array<String>& filelist );
	static int		GetFileListAlt( cstr_t file, cstr_t paths, Array<String>& filelist );
	// Advanced file searching:
	struct findstruct_t {
		String			name;			// file name (includes path)
		long			size;			// file size (-1 == unknown)
		String			wc;				// used internally; don't change!
		long			fh;				// used internally; don't change!
		void*			fd;				// used internally; don't change!
		int				pre;			// number of char_t's added before original part
	};
	static bool		FindFileFirst( cstr_t wildcard, findstruct_t& );
	static bool		FindFileNext( findstruct_t& );
	static void		FindFileClose( findstruct_t& );
	static bool		FindFileFirstEx( cstr_t wildcard, cstr_t paths, findstruct_t& );
	static bool		FindFileNextEx( findstruct_t& );
	static void		FindFileCloseEx( findstruct_t& );
	static bool		FindFileFirstAlt( cstr_t file, cstr_t paths, findstruct_t& );
	static bool		FindFileNextAlt( findstruct_t& );
	static void		FindFileCloseAlt( findstruct_t& );
	static String	FindFileEx( cstr_t wildcard, cstr_t paths_semicolon_separated );
	// General OS functions:
	static String	GetEnvironmentVariable( cstr_t );
	static String	GetUserName();
	static String	GetComputerName();
	static String	GetOSName();
	static String	GetOSVersion();
	static void		Sleep( ctime_t milliseconds );
	//! Runs an external program. Returns -1 on error, exit-code otherwise
	static int		RunProgram( cstr_t, bool synchronous, cstr_t params =NULL );
	// Windows/X specific:
	static void*	GetWindowHandle();
	static void*	GetDesktopWindowHandle();
	// Filename helpers:
	static char_t*	FixSlashes( char_t* );		// fixes slashes, returns pointer to last char
	static cstr_t	FixFolder( String& );		// fixes slashes and appends one
	static bool		IsFolder( cstr_t );			// true if string ends in a slash
	static bool		IsRelativePath( cstr_t );
	static void		GetFileParts( cstr_t path, int* name, int* ext );
	static cstr_t	GetFileName( cstr_t );		// "file.txt"
	static cstr_t	GetFileExt( cstr_t );		// ".txt"
	static String	GetFileFolder( cstr_t );	// "C:\\Windows\\"
	static String	GetFileNameNoExt( cstr_t );	// "file"
	static String	GetProtocol( cstr_t url );	// "http"
	//! Check for existence of a file
	static bool		FileExists( cstr_t );
	//! Check for existence of a folder
	static bool		FolderExists( cstr_t );
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
} // namespace citk
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_DOS_H_INCLUDED
///////////////////////////////// [citkt_DOS.h] END
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
///////////////////////////////////////////////////////////////////////////////
class DFile_temp : public DFile
{
public:
	
	// Constructor; creates a unique filename
	DFile_temp( cstr_t extension =NULL );
	// Destructor; closes and removes the file
	virtual ~DFile_temp();
	bool		Open()					{ return DFile::Open(path); }
	bool		Create()				{ return DFile::Create(path); }
	cstr_t		GetFilePath() const		{ return path; }
	cstr_t		GetFileName() const		{ return DOS::GetFileName(path); }
protected:
	String		path;
};
///////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITK_TEMPFILE_H_INCLUDED
///////////////////////////////// [citkt_TempFile.h] END
///////////////////////////////// [citkt_StateMachine.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
#ifndef CITKT_STATEMACHINE_H_INCLUDED
#define CITKT_STATEMACHINE_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
///////////////////////////////////////////////////////////////////////////////
template <class V =int, class D =void*>
class DState
{
public:
	//! User-defined data for this state (not initialized)
	D		data;
	
	//! The default next state, followedwhen no link is found (NULL by default)
	DState*	defstate;
	//! Default constructor
	DState() : defstate(NULL) {}
	//! Constructor that initializes the data and default state
	explicit DState( const D d, DState *def =NULL ) : defstate(def), data(d) {}
	//! Follow an link to a next state
	DState*		Follow( const V );
	//! Process n values and return the final state
	DState*		Process( int n, const V* );
	// Members get/set methods
	DState*		GetDefaultLink() const			{ return defstate; }
	DState&		SetDefaultLink( DState* s )		{ defstate = s; return *this; }
	DState&		SetDefaultSelf()				{ defstate = this; return *this; }
	const D&	GetData() const					{ return data; }
	DState&		SetData( D d )					{ data = d; return *this; }
	// Iterate through links
	int			GetLinkCount() const			{ return links.Count(); }
	const V&	GetLinkValueNo( int i ) const	{ return links[i].value; }
	DState*		GetLinkStateNo( int i ) const	{ return links[i].state; }
	// Add methods
	DState&		AddLinks( int, const V*, DState* );		// no duplicate checks
	DState&		AddLink( const V, DState* );			// no duplicate check
	DState&		SetLink( const V, DState* );			// replaces if exists
	// Remove methods
	DState*		RemoveLink( const V );					// returns old state
	DState&		RemoveLinks( DState* );
	DState&		RemoveAllLinks()				{ links.Empty(); return *this; }
	// State-graph management methods
	DState*		AddNewState( const V );					// no duplicate check
	typedef void (CDECL *visitfunc_t)(DState*,long_ptr);
	void		VisitAll( visitfunc_t, long_ptr );
private:
	int			visited;								// for _Visit
	struct visitparams_t
	{
		visitfunc_t		vf;
		long_ptr		param;
		int				v;
	};
	void		_Visit( const visitparams_t &p );
	//! Find the link for a specific value
	int			_FindEdge( const V ) const;
	struct link_t
	{
		V		value;
		DState*	state;
		link_t() {}
		link_t(V v) : value(v) {}
	};
	ArrayVal<link_t>	links;							// TODO: sort?
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
template <class V, class D>
int	DState<V,D>::_FindEdge( const V value ) const
{
	// TODO: this can be a binary search or something like that
	for (int t=0; t<links.Count(); t++)
		if (links[t].value==value)
			return t;
	return links.INVALID_ITEM;
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
template <class V, class D>
DState<V,D>& DState<V,D>::AddLinks( int c, const V *values, DState* state )
{
	THIS_ASSERT( values, _T("::AddLinks NULL values") );
	for (int t=0; t<c; t++)
		AddLink( values[t], state );
	return *this;
}
///////////////////////////////////////////////////////////////////////////////
template <class V, class D>
DState<V,D>& DState<V,D>::AddLink( const V value, DState* state )
{
	// TODO: keep the array sorted here so we can use binary search
	link_t &e = links.Add();
	e.value = value;
	e.state = state;
	return *this;
}
///////////////////////////////////////////////////////////////////////////////
template <class V, class D>
DState<V,D>& DState<V,D>::SetLink( const V value, DState* state )
{
	int i = _FindEdge(value);
	if (i==links.INVALID_ITEM)
		// TODO: keep the array sorted here so we can use binary search
		i = links.Add( link_t(value) );
	links[i].state = state;
	return *this;
}
///////////////////////////////////////////////////////////////////////////////
template <class V, class D>
DState<V,D>* DState<V,D>::RemoveLink( const V value )
{
	DState *st = NULL;
	int t = _FindEdge(value);
	if (t!=links.INVALID_ITEM)
	{
		st = links[t].state;
		links.RemoveNo(t);
	}
	return st;
}
///////////////////////////////////////////////////////////////////////////////
template <class V, class D>
DState<V,D>& DState<V,D>::RemoveLinks( DState* state )
{
	// Linear search through all links
	for (int t=0; t<links.Count(); t++)
		if (links[t].state==state)
			links.RemoveNo(t--);
	return *this;
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
template <class V, class D>
DState<V,D>* DState<V,D>::Follow( const V value )
{
	int t = _FindEdge(value);
	if (t!=links.INVALID_ITEM)
		return links[t].state;
	else
		return defstate;
}
///////////////////////////////////////////////////////////////////////////////
template <class V, class D>
DState<V,D>* DState<V,D>::Process( int n, const V* v )
{
	DState<V,D> *now = this;
	while (now&&n--)
		now = now->Follow(*v++);
	return now;
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
template <class V, class D>
DState<V,D>* DState<V,D>::AddNewState( const V v )
{
	DState* newstate = new DState<V,D>();
	AddLink( v, newstate );
	return newstate;
}
///////////////////////////////////////////////////////////////////////////////
template <class V, class D>
void DState<V,D>::VisitAll( visitfunc_t vf, long_ptr param )
{
	visitparams_t vp;
	vp.vf = vf;
	vp.param = param;
	vp.v = visited+1;
	_Visit(vp);
}
///////////////////////////////////////////////////////////////////////////////
template <class V, class D>
void DState<V,D>::_Visit( const visitparams_t &vp )
{
	visited = vp.v;
	vp.vf(this,vp.param);
	for (int t=0; t<links.Count(); ++t)
		if (links[t].state->visited != vp.v)
			links[t].state->_Visit(vp);
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_STATEMACHINE_H_INCLUDED
///////////////////////////////// [citkt_StateMachine.h] END
///////////////////////////////// [citkt_UniqueArray.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
#pragma once
namespace citkTypes {
////////////////////////////////////////////////////////////////////////////////
template <typename T>
class UniqueArray : AArray<uint, T>
{
	typedef AArray<uint, T> super;
public:
	UniqueArray() : nextindex(0) {}
	using super::Contains;
	using super::IsEmpty;
	using super::Empty;
	using super::Count;
	using super::Reserve;
	bool	AddUnique( const T& item ) {
		uint *newindex;
		if (super::Add(item,&newindex)) {	// was added?
			*newindex = nextindex;
			++nextindex;
			return true;
		}
		else
			return false;
	}
	bool	Remove( const T& item ) {
		uint oldval;
		if (super::Remove(item,oldval)) {	// was removed?
			// Optimization: decrease the nextindex if it's the last item we're removing
			if (oldval == nextindex-1)
				--nextindex;
			return true;
		}
		else
			return false;
	}
	typedef delegate<bool(const T&)> foreach_d;
	void ForEach( foreach_d dg ) { super::ForEachKey( dg ); }
	template <int A>
	void AddTo( Array<const T*,A> &ids ) const { super::AddKeysTo(ids); }
	template <int A>
	void AddTo( Array<T,A> &ids ) const { super::AddKeysTo(ids); }
	template <int A>
	void CopyToOrdered( Array<const T*,A> &ids ) const {
		assert(ids.IsEmpty());
		_orderp<A> o(nextindex);
		super::_foreach( _foreach_d(&o,&_orderp<A>::set) );
		ids.AttachData( o.keyptrs );
	}
	template <int A>
	void CopyToOrdered( Array<T,A> &ids ) const {
		assert(ids.IsEmpty());
		// If we contain less items than the current index, some must have been removed
		if (nextindex == Count()) {
			// there are no removed items: put each element on its index
			_order<A> o(nextindex);
			super::_foreach( _foreach_d(&o,&_order<A>::set) );
			ids.AttachData( o.keys );
		}
		else {
			// we have removed items; first pass: collect pointers to elements
			_orderp<A> o(nextindex);
			super::_foreach( _foreach_d(&o,&_orderp<A>::set) );
			// second pass: fill ids
			ids.SetCount( Count() );
			size_t i=0;
			foreach (t,o.keyptrs)
				if (o.keyptrs[t])
					ids[i++] = *o.keyptrs[t];
		}
	}
	void CopyFrom( const UniqueArray<T> &aa ) {
		super::CopyFrom(aa);
		nextindex = aa.nextindex;
	}
private:
	uint nextindex;
/*	
	invariant {
		assert(nextindex >= Count());
	}
*/
	template <int A>
	struct _orderp {
		Array<const T*,A>	keyptrs;
		_orderp(uint n) : keyptrs(n) { if (!ZERO) keyptrs.Fill(null); }
		bool set( bucket_t *p ) { keyptrs[p->value] = &p->key; return true; }
	};
	template <int A>
	struct _order {
		Array<T,A>	keys;
		_order(uint n) : keys(n) { }
		bool set( bucket_t *p ) { keys[p->value] = p->key; return true; }
	};
};
////////////////////////////////////////////////////////////////////////////////
}// namespace citkTypes
///////////////////////////////// [citkt_UniqueArray.h] END
//#include "citkt_UniqueIDMap.h"
///////////////////////////////// [citkt_Vector2.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
//
//  vector2.h	3D Vector Math Class/Template
//  Copyright by Crystal Intertechnology 1999. All rights reserved.
//
//	Revision log:
//		99/11/09 20:26		L. Lunesu		Created (from vector3.h)
//
#ifndef CITKT_VECTOR2_H_INCLUDED
#define CITKT_VECTOR2_H_INCLUDED
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#ifdef USE_IOSTREAM
# include <iostream>
#endif // USE_IOSTREAM
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class Vector2
{
public:	
	float__t		x, y;
	// Constructors:
	inline Vector2() {}
	inline Vector2( const float a[2] ) : x((float__t)a[0]), y((float__t)a[1]) {}
	inline Vector2( const double a[2] ) : x((float__t)a[0]), y((float__t)a[1]) {}
	inline Vector2( cfloat__t a, cfloat__t b ) : x(a), y(b) {}
//	inline Vector2( const Vector2 &v ) : x(v.x), y(v.y) {}
	// Operators:
	inline Vector2&		operator += ( const Vector2 & );
	inline Vector2&		operator -= ( const Vector2 & );
	inline Vector2&		operator *= ( const Vector2 & );		// Scaling
	inline Vector2&		operator /= ( const Vector2 & );		// Scaling
	inline Vector2&		operator *= ( cfloat__t );			// Scalar
	inline Vector2&		operator /= ( cfloat__t );			// Scalar
	// const-Operators:
	inline Vector2		operator + ( const Vector2 & ) const;
	inline Vector2		operator - ( const Vector2 & ) const;
	inline Vector2		operator * ( const Vector2 & ) const;	// Scaling
	inline Vector2		operator / ( const Vector2 & ) const;	// Scaling
	inline Vector2		operator * ( cfloat__t ) const;	// Scalar (!)
	inline Vector2		operator / ( cfloat__t ) const;	// Scalar
	inline float__t		operator ^ ( const Vector2 & ) const;	// Dot-Product
	inline Vector2		operator + () const;
	inline Vector2		operator - () const;					// Flip
	inline float__t&	operator [] ( const int );				// Array access [0..1]
	inline float__t		operator [] ( const int ) const;		// Array access [0..1]
	// Functions:
	inline float__t		SqrLength() const;						// |v|^2
	inline float__t		Length() const;							// |v|
	inline Vector2		Copy() const { return Vector2(*this); }
	inline Vector2&		Normalize();							// (v/=|v|)
	inline Vector2&		Flip();									// (v=-v)
	inline Vector2		Normalized() const { return Copy().Normalize(); }
	inline Vector2		Flipped() const { return Copy().Flip(); }
	// Initialisation:
	inline Vector2&		Set( cfloat__t, cfloat__t );
	inline Vector2&		Set( const float [2] );
	inline Vector2&		Set( const double [2] );
	inline Vector2&		Set( const Vector2& );
	inline Vector2&		Zero() { x=y=0.f; return *this; }
	inline bool			IsNormal() const { return _feq(SqrLength(),1.f); }
	inline bool			IsZero() const { return _feqz(x)&&_feqz(y); }
	inline bool			IsEqual( const Vector2& v ) const { return _feq(x,v.x)&&_feq(y,v.y); }
	// Friend Functions:
	friend	Vector2 operator * ( cfloat__t, const Vector2 & );
#ifdef USE_IOSTREAM
	friend ostream & operator << ( ostream &, const Vector2 & );
#endif // USE_IOSTREAM
};
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Macros for null-vector:
#define ZEROVECTOR2 Vector2(0.f,0.f)
#define ZeroVector2() ZEROVECTOR2
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
inline Vector2& Vector2::Set( cfloat__t a, cfloat__t b )
{
	x = a;
	y = b;
	return *this;
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
inline Vector2& Vector2::Set( const float a[2] )
{
//	memcpy( (void*)&x, (void*)a, sizeof(float)*3 );			// faster?
	x = (float__t)a[0];
	y = (float__t)a[1];
	return *this;
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
inline Vector2& Vector2::Set( const double a[2] )
{
	x = (float__t)a[0];
	y = (float__t)a[1];
	return *this;
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
inline Vector2& Vector2::Set( const Vector2& v )
{
//	memcpy( (void*)&x, (void*)&v.x, sizeof(float__t)*3 );		// faster?
	x = v.x;
	y = v.y;
	return *this;
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/*
inline Vector2& Vector2::operator = ( const Vector2 &v )
{
	x = v.x;
	y = v.y;
	return (*this);
}
*/
/////////////////////////////////////////////////////////////////////////////
inline Vector2& Vector2::operator += ( const Vector2 &v )
{
	x += v.x;
	y += v.y;
	return (*this);
}
/////////////////////////////////////////////////////////////////////////////
inline Vector2& Vector2::operator -= ( const Vector2 &v )
{
	x -= v.x;
	y -= v.y;
	return (*this);
}
/////////////////////////////////////////////////////////////////////////////
inline Vector2& Vector2::operator *= ( const Vector2 &v )
{
	x *= v.x;
	y *= v.y;
	return (*this);
}
/////////////////////////////////////////////////////////////////////////////
inline Vector2& Vector2::operator /= ( const Vector2 &v )
{
	x /= v.x;
	y /= v.y;
	return (*this);
}
/////////////////////////////////////////////////////////////////////////////
inline Vector2& Vector2::operator *= ( cfloat__t d )
{
	x *= d;
	y *= d;
	return (*this);
}
/////////////////////////////////////////////////////////////////////////////
inline Vector2& Vector2::operator /= ( cfloat__t d )
{
	x /= d;
	y /= d;
	return (*this);
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
inline Vector2 Vector2::operator + () const
{
	return (*this);
}
/////////////////////////////////////////////////////////////////////////////
inline Vector2 Vector2::operator - () const
{
	return Vector2( -x, -y );
}
/////////////////////////////////////////////////////////////////////////////
inline float__t& Vector2::operator [] ( const int i )
{
//	return (i==0?x:y);						// for class, safe
//	return vec[i];
	return (&x)[i];
}
/////////////////////////////////////////////////////////////////////////////
inline float__t Vector2::operator [] ( const int i ) const
{
//	return (i==0?x:y);						// for class, safe
//	return vec[i];
	return (&x)[i];
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
inline Vector2 Vector2::operator + ( const Vector2 &v ) const
{
	return Vector2(x+v.x,y+v.y);
}
/////////////////////////////////////////////////////////////////////////////
inline Vector2 Vector2::operator - ( const Vector2 &v ) const
{
	return Vector2(x-v.x,y-v.y);
}
/////////////////////////////////////////////////////////////////////////////
inline Vector2 Vector2::operator * ( const Vector2 &v ) const
{
	return Vector2( x*v.x, y*v.y );
}
/////////////////////////////////////////////////////////////////////////////
inline Vector2 Vector2::operator / ( const Vector2 &v ) const
{
	return Vector2( x/v.x, y/v.y );
}
/////////////////////////////////////////////////////////////////////////////
inline Vector2 Vector2::operator * ( cfloat__t d ) const
{
	return Vector2( x*d, y*d );
}
/////////////////////////////////////////////////////////////////////////////
/*
inline Vector2 operator * ( const Vector2& v, const int d )
{
	return Vector2( v.x*d, v.y*d );
}
/////////////////////////////////////////////////////////////////////////////
inline Vector2 operator * ( const int d, const Vector2& v)
{
	return Vector2( v.x*d, v.y*d );
}
*/
/////////////////////////////////////////////////////////////////////////////
inline Vector2 Vector2::operator / ( cfloat__t d ) const
{
	return Vector2(x/d,y/d);
}
/////////////////////////////////////////////////////////////////////////////
inline float__t Vector2::operator ^ ( const Vector2 &v ) const
{
	return (x*v.x + y*v.y);
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
inline float__t Vector2::SqrLength() const
{ 
	return (x*x+y*y); 
}
/////////////////////////////////////////////////////////////////////////////
inline float__t Vector2::Length() const
{ 
	return (float__t)_fsqrt(x*x+y*y); 
}	
/////////////////////////////////////////////////////////////////////////////
inline Vector2& Vector2::Normalize()
{ 
	const double il = 1.0f/Length(); 
	x *= il; 
	y *= il; 
	return (*this); 
}
/////////////////////////////////////////////////////////////////////////////
inline Vector2& Vector2::Flip()
{ 
	x=-x; 
	y=-y; 
	return (*this); 
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//	Friends:
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
inline Vector2 operator * ( cfloat__t d, const Vector2 &v )
{
	return Vector2( d * v.x, d * v.y );
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#ifdef USE_IOSTREAM
inline ostream & operator << ( ostream &o, const Vector2 &t )
{
	o << "(" << t.x << "," << t.y << "," << t.z << ")";
	return o;
}
#endif // USE_IOSTREAM
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_VECTOR2_H_INCLUDED
///////////////////////////////// [citkt_Vector2.h] END
///////////////////////////////// [citkt_FilenameCache.h]
#pragma once
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
/////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
class DFileNameCache
{
public:
	DFileNameCache();
	~DFileNameCache();
	void	Init( cstr_t _Paths, cstr_t extensions_with_dot_space_sep );
	cstr_t	FindFile( cstr_t LibName ); // Returns full path name;
	void	Set(cstr_t LibName, cstr_t FullPath ); // Adds/replaces a pair
private:
	struct map_t
	{
		String ln, fn;
	};
	DHashTable<map_t, crc_t> Map;
	cstr_t _FindFile( cstr_t LibName_LC, crc_t crc );
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// [citkt_FilenameCache.h] END
// Platform wrappers
///////////////////////////////// [citkt_INIFile.h]
//  Copyright (C) 1998-2001 Mondo Bizzarro BV.  All rights reserved.
//  
//  This file is part of MBFPL vrSS.
//  
//  MBFPL vrSS is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Mondo Bizzarro Free Public
//  License (the "License") for full details.
//  
//  Every copy of MBFPL vrSS must include a copy of the License, normally
//  in a plain ASCII text file named MBFPL.TXT.  The License grants you the
//  right to copy, modify and redistribute MBFPL vrSS, but only under certain
//  conditions, as described in the License.  Among other things, the License
//  requires that the copyright notice and this notice be preserved on all
//  copies.
//
#ifndef CITK_INIFILE_H_INCLUDED
#define CITK_INIFILE_H_INCLUDED
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
/////////////////////////////////////////////////////////////////////////////
class DINIFile
{
public:
	DINIFile( cstr_t =NULL );
	~DINIFile();
	bool	Open( cstr_t );
	bool	Create( cstr_t );
	bool	Close();
	bool	Opened() const { return opened; }
	// Methods to read/write the default entry:
	bool	WriteDef( cstr_t );
	String	ReadDef();
	int		GetSizeDef();
	int		GetSize( cstr_t );
	// Methods to write data to INIFile:
	bool	WriteString( cstr_t, cstr_t );
	bool	WriteLong( cstr_t, long );
	bool	WriteData( cstr_t, void*, int );
	// Normal methods to retrieve data from INI-File:
	String	ReadString( cstr_t );
	long	ReadLong( cstr_t );
//	void*	ReadData( cstr_t );
	bool	ReadData( cstr_t, void*, int* );
	// Methods to retrieve data from INI-File with default value
	String	ReadStringDef( cstr_t, cstr_t );
	long	ReadLongDef( cstr_t, const long );
	// Safe methods:
	bool	ReadString2( cstr_t, char_t* );
	bool	ReadLong2( cstr_t, long* );
	// Type identification methods:
//	bool	IsString( String );
//	bool	IsLong( String );
//	bool	IsData( String );
private:
	bool	opened;
	String	filename, section;
};
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
} // namespace vrSSTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !VRSST_INIFILE_H_INCLUDED
///////////////////////////////// [citkt_INIFile.h] END
///////////////////////////////// [citkt_Library.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITKT_LIBRARY_H_INCLUDED
#define CITKT_LIBRARY_H_INCLUDED
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
///////////////////////////////////////////////////////////////////////////////
class DLibrary
{
public:
	DLibrary();
	~DLibrary();
	bool		Valid() const;
	bool		Load( cstr_t );
	void		Free();
	void*		GetProcAddress( const char* );			// always ANSI
	void*		GetHandle() const { return hDll; }
private:
	void*		hDll;
	// Hidden members, not implemented (to avoid generated copy):
	DLibrary( const DLibrary& );
	void operator = ( const DLibrary& );
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_LIBRARY_H_INCLUDED
///////////////////////////////// [citkt_Library.h] END
///////////////////////////////// [citkt_Thread.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITKT_THREAD_H_INCLUDED
#define CITKT_THREAD_H_INCLUDED
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifdef __unix__
#include <pthread.h>			// for pthread_t and pthread_cond_t
#endif // __unix__
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
class DThread
{
public:
	typedef void (CDECL *threadproc_t)(void* pParam);	//!< function prototype for the thread procedure.
	enum priority_t {LOWEST=-2, LOW=-1, NORMAL=0, HIGH=1, HIGHEST=2};
	//! Constructor.
	DThread( threadproc_t tp =NULL );
	//! Destructor (makes sure the thread is stopped).
	virtual ~DThread();
	//! Pass the thread procedure. Must be called before starting the thread.
	inline void		SetCallback( threadproc_t pFunc )	{ m_pFunc = pFunc; }
	//! Set the stack size. Must be called before starting the thread.
	inline void		SetStackSize(const unsigned int n)	{ m_uiStackSize = n; }
	bool			Start( void* pParam );			//!< create a new thread.
	bool			Suspend();						//!< suspend a running thread.
	bool			Resume();						//!< resume a suspended thread.
	bool			Wait( ctime_t timeout =~0 );	//!< wait for thread to finish
	bool			Kill();							//!< terminate
	bool			IsActive();						//!< checks whether the proc is done
	bool			IsSuspended() const					{ return m_bIsSuspended; }
	void*			GetParam() const					{ return m_pParam; }
	bool			SetPriority( priority_t );		//!< specify the thread's priority
//	void*			GetThreadHandle();				//!< get OS handle to thread
protected:
	//! This is called if no thread-proc is set (overridable)
	virtual void	ThreadProc( void* );			// throws an assertion
private:
	bool			m_bIsActive;					// active state
	bool			m_bIsSuspended;
//	bool			m_bAutoDelete;					// delete this when done
	threadproc_t	m_pFunc;
	void*			m_pParam;
	unsigned int	m_uiStackSize;
	void			_CleanUp();						//!< releases OS objects
	// Hidden members, not implemented (to avoid generated copy):
	DThread( const DThread& );
	void operator = ( const DThread& );
#if defined _WIN32 || defined _XBOX
	void*			m_hThread;						// HANDLE
	static unsigned int __stdcall _ThreadProc(void* pData);	// _beginthreadex
//	static DWORD WINAPI _ThreadProc(LPVOID pData);			// ::CreateThread
#endif // _WIN32 || _XBOX
#ifdef __unix__
	pthread_t		m_Thread;
	pthread_cond_t	m_SignaledEvent;				// signaled state event
	pthread_mutex_t m_EventMutex;					// mutex to protect the state event
	static void* CDECL _ThreadProc(void* pData);	// linux
#endif // __unix__	
};
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_THREAD_H_INCLUDED
///////////////////////////////// [citkt_Thread.h] END
// These are not included since they are hardly ever used
//#include "citkt_FileASC.h"
//#include "citkt_FixedP.h"
//#include "citkt_LFB2.h"
//#include "citkt_Vector4.h"
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#ifdef USING_CITKTYPES
using namespace citkTypes;
#endif
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !ONLY_VERSION_INFO
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !_CITKTYPES_H_INCLUDED
///////////////////////////////// [_citkTypes.h] END
