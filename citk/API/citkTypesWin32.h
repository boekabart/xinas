// This file was generated by HExpand v 1.6
//
///////////////////////////////// [_citkTypesWin32.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#pragma once
#include <citkTypes.h>
///////////////////////////////////////////////////////////////////////////////
#ifndef _XBOX
// No registry on XBOX
///////////////////////////////// [citkt_Registry_Win32.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITKT_REGISTRY_H_INCLUDED
#define CITKT_REGISTRY_H_INCLUDED
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#define WIN32_LEAN_AND_MEAN
#define Array __Array
#include <windows.h>
#undef Array
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
/////////////////////////////////////////////////////////////////////////////
class DRegistry
{
public:
	static const String DefaultValue;			// for EnumValues
	DRegistry();
	DRegistry( HKEY );
	~DRegistry();
	bool	Open( cstr_t );
	bool	Create( cstr_t );
	bool	Close();
	HKEY	Handle() const { return current_key; }
	bool	Opened() const { return opened; }
	// Subkey methods:
	bool	OpenSubKey( cstr_t );
	bool	CreateSubKey( cstr_t );
	bool	DeleteSubKey( cstr_t );
	String	EnumKeys( int index );
	String	EnumValues( int index );
	int		GetSize( cstr_t );
	bool	DeleteValue( cstr_t );
	// Methods to read/write the default entry:
	bool	WriteDef( cstr_t );
	String	ReadDef();
	int		GetSizeDef();
	// Methods to write data to registry:
	bool	WriteString( cstr_t, cstr_t );
	bool	WriteLong( cstr_t, long );
	bool	WriteData( cstr_t, void*, int );
	// Normal methods to retrieve data from registry:
	String	ReadString( cstr_t );
	long	ReadLong( cstr_t );
//	void*	ReadData( cstr_t );
	bool	ReadData( cstr_t, void*, int* );
	// Methods to retrieve data from registry with default value
	String	ReadStringDef( cstr_t, cstr_t );
	long	ReadLongDef( cstr_t, const long );
	// Safe methods:
	bool	ReadString2( cstr_t, char_t* );
	bool	ReadLong2( cstr_t, long* );
	// Type identification methods:
//	bool	IsString( String );
//	bool	IsLong( String );
//	bool	IsData( String );
private:
	// Hidden members, not implemented (to avoid generated copy):
	DRegistry( const DRegistry& );
	void operator = ( const DRegistry& );
	HKEY	current_key, root;
	bool	opened;
};
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_REGISTRY_H_INCLUDED
///////////////////////////////// [citkt_Registry_Win32.h] END
// No message box on XBOX
///////////////////////////////// [citkt_MessageBox_Win32.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITKT_MESSAGEBOX_H_INCLUDED
#define CITKT_MESSAGEBOX_H_INCLUDED
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//#include "citkt_Thread.h"
#define WIN32_LEAN_AND_MEAN
#define Array __Array
#undef Array
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
/////////////////////////////////////////////////////////////////////////////
//! small class that does MessageBox in a new thread, so our message loop gets left alone.
class DMessageBox : DThread
{
public:
	volatile long id;
	DMessageBox( LPCTSTR message, LPCTSTR title, UINT flags =MB_OK )
	{
		id = -1;
		m = message;
		t = title;
		f = flags;
		Start(NULL);
		Wait();
	}
protected:
	LPCTSTR t, m;
	UINT f;
	virtual void ThreadProc(void* q) 
	{ 
		long _id = ::MessageBoxW( NULL, U2W(m), U2W(t), f ); 
		::InterlockedExchange( &id, _id );
	}
};
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_MESSAGEBOX_H_INCLUDED
///////////////////////////////// [citkt_MessageBox_Win32.h] END
#endif
///////////////////////////////// [citkt_CritSec_Win32.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITKT_CRITSEC_WIN32_H_INCLUDED
#define CITKT_CRITSEC_WIN32_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#ifdef _XBOX
# include <Xtl.h>
#else
# define WIN32_LEAN_AND_MEAN
# define Array __Array
# include <windows.h>
# undef Array
#endif
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
///////////////////////////////////////////////////////////////////////////////
// Let the struct initialize/destroy the CRITICAL_SECTION data...
#define CRITSEC_AUTO_INIT_DEINIT
// Avoid using the heap for the internal data
#define CRITSEC_DONT_USE_HEAP
///////////////////////////////////////////////////////////////////////////////
// Win32 CriticalSection class
class DCriticalSection
{
public:
	// Constructors:
#ifdef CRITSEC_AUTO_INIT_DEINIT
# ifdef CRITSEC_DONT_USE_HEAP
	DCriticalSection () { Init(); }
# else // CRITSEC_DONT_USE_HEAP
	DCriticalSection () : pCriticalSection(NULL) { Init(); }
# endif // CRITSEC_DONT_USE_HEAP
#else // CRITSEC_AUTO_INIT_DEINIT
# ifdef CRITSEC_DONT_USE_HEAP
#error Invalid combination of preprocessor definitions
# else // CRITSEC_DONT_USE_HEAP
	DCriticalSection () : pCriticalSection(NULL) {}
# endif // CRITSEC_DONT_USE_HEAP
#endif // CRITSEC_AUTO_INIT_DEINIT
#ifdef CRITSEC_AUTO_INIT_DEINIT
	// Destructor:
	~DCriticalSection () { Deinit(); }
#endif // CRITSEC_AUTO_INIT_DEINIT
	// Methods:
#ifdef CRITSEC_DONT_USE_HEAP
	inline void Init() { InitializeCriticalSection( &sCriticalSection ); }
	inline void Deinit() { DeleteCriticalSection( &sCriticalSection ); }
	inline void Enter() { EnterCriticalSection( &sCriticalSection ); }
	inline void Leave() { LeaveCriticalSection( &sCriticalSection ); }
#else // CRITSEC_DONT_USE_HEAP
	void Init()
	{
		if (Inited()) return;
		pCriticalSection = new CRITICAL_SECTION;
		InitializeCriticalSection( pCriticalSection );
	}
	void Deinit()
	{
		if (!Inited()) return;
		DeleteCriticalSection( pCriticalSection );
		delete pCriticalSection;
		pCriticalSection = NULL;
	}
	inline bool Inited() { return pCriticalSection!=NULL; }
	inline void Enter() 
	{
		if (!Inited()) Init();
		EnterCriticalSection( pCriticalSection ); 
	}
	inline void Leave() { assert(Inited()); LeaveCriticalSection( pCriticalSection ); }
#endif // CRITSEC_DONT_USE_HEAP
private:
#ifdef CRITSEC_DONT_USE_HEAP
	CRITICAL_SECTION sCriticalSection;		// Initialized globally
#else //CRITSEC_DONT_USE_HEAP
	CRITICAL_SECTION *pCriticalSection;		// On the heap
#endif //CRITSEC_DONT_USE_HEAP
	// Hidden members (to avoid generated copy):
	DCriticalSection( const DCriticalSection& );
	DCriticalSection& operator = ( const DCriticalSection& );
};
///////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_CRITSEC_WIN32_H_INCLUDED
///////////////////////////////// [citkt_CritSec_Win32.h] END
// DCriticalSectionHelper, ENTER_CRITICAL_SECTION (must be included here)
///////////////////////////////// [citkt_CritSec.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITKT_CRITSEC_H_INCLUDED
#define CITKT_CRITSEC_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
///////////////////////////////////////////////////////////////////////////////
class DCriticalSectionHelper
{
public:
	// Constructors:
	DCriticalSectionHelper( DCriticalSection* csd ) : CSD(csd) { assert(CSD); CSD->Enter(); }
	DCriticalSectionHelper( DCriticalSection& csd ) : CSD(&csd) { CSD->Enter(); }
	// Destructor:
	~DCriticalSectionHelper() { CSD->Leave(); }
	// Cast-operator to allow for embedding a helper in if()
	operator bool () const { return CSD!=NULL; }
private:
	DCriticalSection *CSD;
	// Hidden members (to avoid generated copy):
	DCriticalSectionHelper( const DCriticalSectionHelper& );
	DCriticalSectionHelper& operator = ( const DCriticalSectionHelper& );
};
///////////////////////////////////////////////////////////////////////////////
// Use this macro to declare a CS helper which enters and leaves automatically.
#define ENTER_CRITICAL_SECTION(__csd) citkTypes::DCriticalSectionHelper __csd##helper (__csd)
#define _APPEND(a,b) __APPEND(a,b)
#define __APPEND(a,b) a ## b
// Use this macro to declare a scope with a CS helper which enters and leaves automatically.
#define synchronized(__csd) if (citkTypes::DCriticalSectionHelper _APPEND(__cs,__LINE__) (__csd))
///////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_CRITSEC_H_INCLUDED
///////////////////////////////// [citkt_CritSec.h] END
///////////////////////////////// [citkt_MemoryPoolSafe.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITKT_MEMORYPOOLSAFE_H_INCLUDED
#define CITKT_MEMORYPOOLSAFE_H_INCLUDED
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// NOTE: this will be included in citkTypesWin32 and citkTypesLinux
//       after citkTypes, so these are known:
//#include "citkt_MemoryPool.h"
//#include "citkTypesPlatform.h"
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
///////////////////////////////////////////////////////////////////////////////
template <class T>
class DMemoryPoolSafe : protected DMemoryPool<T>
{
public:
	//! Default constructor
	DMemoryPoolSafe( size_t max_blocks =DEFAULT_MAX ) : DMemoryPool<T>(max_blocks) {}
	
	//! Returns a 'new' instance
	//! NOTE: Constructor might not have been called!
	T*		Alloc()			{ ENTER_CRITICAL_SECTION(CS); return DMemoryPool<T>::Alloc(); }
	//! Returns an existing instance (if available) or NULL otherwise
	T*		Get()			{ ENTER_CRITICAL_SECTION(CS); return DMemoryPool<T>::Get(); }
	//! 'Frees' an instance. Deletes the object if the cache limit was reached
	//! NOTE: Destructor might not get called!
	void	Free( T *ptr )	{ ENTER_CRITICAL_SECTION(CS); DMemoryPool<T>::Free(ptr); }
	//! Free all cached items
	void	FreeAll()		{ ENTER_CRITICAL_SECTION(CS); DMemoryPool<T>::FreeAll(); }
	//! Return the number of cached memory blocks (atomic, not synchronized)
//	size_t	GetNumBlocks() const { return DMemoryPool<T>::GetNumBlocks(); }
	//! Return the amount of 'cached' memory (atomic, not synchronized)
//	size_t	GetSize() const { return DMemoryPool<T>::GetSize(); }
	//! Sets the number of maximum blocks to be cached (frees if less than current)
	void	SetMaxBlocks( size_t m ) { ENTER_CRITICAL_SECTION(CS); DMemoryPool<T>::SetMaxBlocks(m); }
protected:
	DCriticalSection	CS;
};
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_MEMORYPOOLSAFE_H_INCLUDED
///////////////////////////////// [citkt_MemoryPoolSafe.h] END
///////////////////////////////// [citkt_JobsThread.h]
//  Copyright (C) 1998-2002 Crystal Intertechnology BV.  All rights reserved.
//  
//  This file is part of citk.
//  
//  citk is distributed with NO WARRANTY OF ANY KIND.  No author or
//  distributor accepts any responsibility for the consequences of using it,
//  or for whether it serves any particular purpose or works at all, unless
//  he or she says so in writing.  Refer to the Crystal Intertechnology
//  License (the "License") for full details.
//  
//
#ifndef CITKT_JOBSTHREAD_H_INCLUDED
#define CITKT_JOBSTHREAD_H_INCLUDED
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//#include "citkt_Thread.h"
//#include "citkt_BufferVal.h"
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
namespace citkTypes {
///////////////////////////////////////////////////////////////////////////////
template <class _T>
class DJobsThread : DThread
{
public:
//	DJobsThread() {}						// nothing to init
//	~DJobsThread() {}						// NOTE: inherited will kill the thread
	//! This adds the specified job to the queue and starts or resumes the thread
	bool	AddJob( _T job )				// FIXME: by ref is better
	{
		{
			DCriticalSectionHelper csh(CS);
			Jobs.Add( job );				// operator =
		}
		// Start or resume the thread, if needed
		StopThread = false;					// FIXME: should be interlocked!
		if (Resume())
			return true;					// assume it gets done
		else
			return Start(NULL);
	}
	//! returns 'true' if jobs are available (thread busy)
	bool	HasJobs() const				{ return !IsSuspended(); }
	//! Finish the current pending jobs and stop the thread (returns false if timed out)
	bool	Finish( ctime_t ms =~0 )	{ StopThread=true; return Resume()?DThread::Wait(ms):true; }
protected:
	//! Implement this call to process one job; return false to quit the thread
	virtual bool JobProc(_T) = 0;			// FIXME: by ref is better
	//! Calls JobProc while jobs are present, suspends itself otherwise
	virtual void ThreadProc(void*)
	{
		do
		{
			while (1)
			{
				_T next;					// ctor
				{
					DCriticalSectionHelper csh(CS);
					if (Jobs.IsEmpty())
						break;				// suspends
					next = Jobs.Pop();		// operator =
				}
				// Do this job
				if (!JobProc(next))			// operator =
					return;					// quit
			} // while(1)
			// No more jobs; either suspend or stop the thread
			if (StopThread)
				break;
		}
		while (Suspend());
	}
private:
	citkTypes::BufferVal<_T>	Jobs;		// FIFO queue with jobs
	citkTypes::DCriticalSection	CS;			// protects Jobs array
	volatile bool				StopThread;	// FIXME: should be interlocked
};
///////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
} // namespace citkTypes
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
#endif // !CITKT_JOBSTHREAD_H_INCLUDED
///////////////////////////////// [citkt_JobsThread.h] END
using citkTypes::byte;
///////////////////////////////// [_citkTypesWin32.h] END
